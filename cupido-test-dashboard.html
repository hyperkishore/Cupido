<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cupido Test Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            line-height: 1.5;
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 1px solid #d2d2d7;
            padding: 16px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Tabs */
        .tabs {
            background: white;
            border-bottom: 1px solid #d2d2d7;
            padding: 0 32px;
            display: flex;
            gap: 32px;
        }

        .tab {
            padding: 12px 0;
            cursor: pointer;
            color: #6e6e73;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #1d1d1f;
        }

        .tab.active {
            color: #0071e3;
            border-bottom-color: #0071e3;
        }

        /* Main Content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px 32px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Controls Bar */
        .controls-bar {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls-left {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .controls-right {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #0071e3;
            color: white;
        }

        .btn-primary:hover {
            background: #0077ed;
        }

        .btn-secondary {
            background: white;
            color: #1d1d1f;
            border: 1px solid #d2d2d7;
        }

        .btn-secondary:hover {
            background: #f5f5f7;
        }

        .btn-danger {
            background: #ff3b30;
            color: white;
        }

        .btn-danger:hover {
            background: #ff4d42;
        }

        /* Select Dropdown */
        select {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle {
            position: relative;
            width: 44px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e5e5ea;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle input:checked + .toggle-slider {
            background-color: #0071e3;
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .toggle-label {
            font-size: 14px;
            color: #6e6e73;
        }

        /* Stats Summary */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            padding: 16px;
        }

        .stat-label {
            font-size: 13px;
            color: #6e6e73;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 600;
            color: #1d1d1f;
        }

        /* Test Table */
        .table-container {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow-x: auto;
            overflow-y: visible;
        }

        table {
            width: max-content;
            min-width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 12px 16px;
            text-align: left;
            font-size: 13px;
            font-weight: 600;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid #f5f5f7;
            font-size: 14px;
        }

        /* Column-specific widths */
        th:nth-child(1), td:nth-child(1) { width: 40px; } /* Checkbox */
        th:nth-child(2), td:nth-child(2) { min-width: 180px; white-space: nowrap; } /* Test Name */
        th:nth-child(3), td:nth-child(3) { min-width: 300px; max-width: 400px; } /* Description - wraps */
        th:nth-child(4), td:nth-child(4) { min-width: 150px; white-space: nowrap; } /* Module */
        th:nth-child(5), td:nth-child(5) { min-width: 180px; white-space: nowrap; } /* Category */
        th:nth-child(6), td:nth-child(6) { min-width: 100px; white-space: nowrap; } /* Status */
        th:nth-child(7), td:nth-child(7) { min-width: 100px; white-space: nowrap; } /* Last Run */
        th:nth-child(8), td:nth-child(8) { min-width: 90px; white-space: nowrap; } /* Duration */
        th:nth-child(9), td:nth-child(9) { width: 100px; white-space: nowrap; } /* Action */

        /* Description column wrapping */
        td:nth-child(3) {
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.4;
            max-height: 4.2em; /* ~3 lines */
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        tbody tr:hover {
            background: #fafafa;
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        /* Status Badge */
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-pending {
            background: #f5f5f7;
            color: #6e6e73;
        }

        .status-running {
            background: #e3f2fd;
            color: #0071e3;
        }

        .status-pass {
            background: #e8f5e9;
            color: #34c759;
        }

        .status-fail {
            background: #ffebee;
            color: #ff3b30;
        }

        /* Category Badge */
        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            background: #f5f5f7;
            color: #6e6e73;
        }

        /* Action Button in Table */
        .action-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: white;
            color: #1d1d1f;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #f5f5f7;
        }

        /* Console Output */
        .console {
            background: #1d1d1f;
            color: #f5f5f7;
            border-radius: 8px;
            padding: 16px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 24px;
        }

        .console-line {
            margin-bottom: 4px;
            display: flex;
            gap: 8px;
        }

        .console-timestamp {
            color: #6e6e73;
        }

        .console-info {
            color: #0071e3;
        }

        .console-success {
            color: #34c759;
        }

        .console-error {
            color: #ff3b30;
        }

        .console-warning {
            color: #ff9500;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 64px 32px;
            color: #6e6e73;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        /* Live Preview 2-Column Layout */
        .live-preview-container {
            display: grid;
            grid-template-columns: 550px 1fr;
            gap: 24px;
            height: calc(100vh - 200px);
        }

        /* iPhone Preview Column */
        .live-preview-iphone {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Simulator Controls Column */
        .live-preview-simulator {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            max-width: 500px;
        }

        /* Scaled iPhone Frame (65% for complete visibility with content) */
        .iphone-frame {
            width: 256px;
            height: 554px;
            background: #1d1d1f;
            border-radius: 35px;
            padding: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            margin: 20px auto;
        }

        .iphone-notch {
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 14px;
            background: #1d1d1f;
            border-radius: 0 0 10px 10px;
            z-index: 10;
        }

        .iphone-screen {
            width: 100%;
            height: 100%;
            border-radius: 26px;
            overflow: hidden;
            background: white;
            position: relative;
        }

        .live-preview-iframe {
            width: 393px;
            height: 852px;
            border: none;
            transform: scale(0.61);
            transform-origin: top left;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Panel Headers */
        .live-preview-header {
            padding: 12px 16px;
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .console-view.collapsed .live-preview-header {
            cursor: pointer;
        }

        .live-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Console Content */
        .live-preview-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f7;
        }

        .live-console {
            background: #1d1d1f;
            color: #f5f5f7;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            overflow-y: auto;
            padding: 12px;
            flex: 1;
            height: 100%;
        }

        .live-console-line {
            margin-bottom: 4px;
            display: flex;
            gap: 8px;
            line-height: 1.4;
        }

        /* Simulator Controls */
        .simulator-header {
            padding: 12px 16px;
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .simulator-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .sim-control-group {
            margin-bottom: 16px;
        }

        .sim-control-group:last-child {
            margin-bottom: 0;
        }

        .sim-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: #6e6e73;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sim-select,
        .sim-input,
        .sim-textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            color: #1d1d1f;
            background: white;
            font-family: inherit;
        }

        .sim-select:focus,
        .sim-input:focus,
        .sim-textarea:focus {
            outline: none;
            border-color: #0071e3;
        }

        .sim-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .sim-checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
        }

        .sim-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .sim-checkbox-label {
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
        }

        .sim-button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sim-btn {
            width: 100%;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .sim-btn-primary {
            background: #0071e3;
            color: white;
        }

        .sim-btn-primary:hover {
            background: #0077ed;
        }

        .sim-btn-secondary {
            background: white;
            color: #1d1d1f;
            border: 1px solid #d2d2d7;
        }

        .sim-btn-secondary:hover {
            background: #f5f5f7;
        }

        /* Toggle Button Styles */
        .toggle-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: white;
            color: #1d1d1f;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .toggle-btn:hover {
            background: #f5f5f7;
        }

        .toggle-btn svg {
            width: 14px;
            height: 14px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* Claude Code Status Indicator */
        .claude-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 6px;
            background: white;
            border: 1px solid #d2d2d7;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6e6e73;
            animation: pulse 2s infinite;
        }

        .status-dot.idle {
            background: #6e6e73;
            animation: none;
        }

        .status-dot.analyzing {
            background: #0071e3;
        }

        .status-dot.fixing {
            background: #ff9500;
        }

        .status-dot.testing {
            background: #34c759;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 13px;
            color: #1d1d1f;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #d2d2d7;
            border-top-color: #0071e3;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* New Simulator Styles */
        .simulator-content {
            padding: 20px;
            overflow-y: auto;
        }

        .simulator-group {
            margin-bottom: 20px;
        }

        .simulator-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .simulator-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            color: #1d1d1f;
            background: white;
            font-family: inherit;
            resize: vertical;
        }

        .simulator-input:focus {
            outline: none;
            border-color: #0071e3;
        }

        .simulator-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .simulator-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .simulator-checkbox span {
            font-size: 14px;
            color: #1d1d1f;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .preset-btn {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            background: white;
            font-size: 13px;
            color: #1d1d1f;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #f5f5f7;
            border-color: #0071e3;
        }

        .simulator-send-btn {
            width: 100%;
            padding: 12px;
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .simulator-send-btn:hover {
            background: #0077ed;
        }

        /* Range slider styles */
        .simulator-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #d2d2d7;
            outline: none;
            -webkit-appearance: none;
        }

        .simulator-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0071e3;
            cursor: pointer;
        }

        .simulator-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0071e3;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-value-display {
            font-size: 13px;
            font-weight: 600;
            color: #0071e3;
        }

        .simulator-number {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            font-size: 14px;
            color: #1d1d1f;
            background: white;
        }

        .simulator-number:focus {
            outline: none;
            border-color: #0071e3;
        }

        .persona-info {
            margin-top: 8px;
            padding: 12px;
            background: #f5f5f7;
            border-radius: 8px;
            font-size: 12px;
            color: #6e6e73;
        }

        /* Console Tab Styles */
        .console-header {
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .unified-console {
            height: calc(100vh - 280px);
            background: #1d1d1f;
            color: #f5f5f7;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            overflow-y: auto;
            padding: 16px;
        }

        /* Prompt Library Styles */
        .prompt-library-container {
            display: flex;
            height: calc(100vh - 200px);
            background: #ffffff;
            gap: 1px;
            overflow: hidden;
        }

        .prompt-sidebar {
            width: 380px;
            background: #f5f5f7;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #d2d2d7;
        }

        .prompt-toolbar {
            padding: 12px 16px;
            background: #ffffff;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .toolbar-search {
            flex: 1;
        }

        .filter-panel {
            padding: 16px;
            background: #ffffff;
            border-bottom: 1px solid #d2d2d7;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-label {
            font-size: 12px;
            font-weight: 600;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
            padding: 4px 0;
        }

        .filter-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .filter-checkbox:hover {
            color: #0071e3;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            background: #f5f5f7 url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M7 12C9.76142 12 12 9.76142 12 7C12 4.23858 9.76142 2 7 2C4.23858 2 2 4.23858 2 7C2 9.76142 4.23858 12 7 12Z" stroke="%236e6e73" stroke-width="1.5"/><path d="M11 11L14 14" stroke="%236e6e73" stroke-width="1.5" stroke-linecap="round"/></svg>') no-repeat 10px center;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #0071e3;
            background-color: #ffffff;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 13px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-select:hover {
            border-color: #86868b;
        }

        .filter-select:focus {
            outline: none;
            border-color: #0071e3;
        }

        .prompt-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .prompt-list-loading {
            padding: 40px 20px;
            text-align: center;
            color: #86868b;
            font-size: 14px;
        }

        .prompt-item {
            background: #ffffff;
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .prompt-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .prompt-item.selected {
            border-color: #0071e3;
            background: #f0f7ff;
        }

        .prompt-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .prompt-item-name {
            font-weight: 600;
            font-size: 15px;
            color: #1d1d1f;
            flex: 1;
        }

        .prompt-item-footer {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .prompt-tag {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .prompt-tag.cupido {
            background: #e3f2fd;
            color: #1976d2;
        }

        .prompt-tag.simulator {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .prompt-tag.extractor {
            background: #e8f5e9;
            color: #388e3c;
        }

        .prompt-tag.money2020 {
            background: #fff3e0;
            color: #f57c00;
        }

        .prompt-version-badge {
            font-size: 11px;
            color: #86868b;
            font-weight: 500;
        }

        /* Apple-style Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #d2d2d7;
            transition: .3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #34c759;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        /* Right Panel: Prompt Editor */
        .prompt-editor-panel {
            flex: 1;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #86868b;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .empty-state h3 {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 15px;
            color: #86868b;
        }

        .prompt-editor-header {
            padding: 16px 24px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fafafa;
        }

        .prompt-editor-title {
            font-size: 14px;
            font-weight: 600;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .version-navigator {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .version-display {
            font-size: 15px;
            font-weight: 600;
            color: #1d1d1f;
            padding: 4px 12px;
            background: #f5f5f7;
            border-radius: 6px;
        }

        .version-arrow {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .version-navigator:hover .version-arrow {
            opacity: 1;
        }

        .version-arrow:hover {
            background: #f5f5f7;
            border-color: #86868b;
        }

        .version-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .version-arrow:disabled:hover {
            background: #ffffff;
            border-color: #d2d2d7;
        }

        .prompt-editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #0071e3;
            box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.1);
        }

        .form-textarea {
            min-height: 300px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            resize: vertical;
        }

        .prompt-editor-actions {
            padding: 16px 24px;
            border-top: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fafafa;
        }

        .action-group {
            display: flex;
            gap: 12px;
        }

        .btn-delete {
            background: transparent;
            color: #ff3b30;
            border: 1px solid #ff3b30;
        }

        .btn-delete:hover {
            background: #ff3b30;
            color: white;
        }

        .version-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .version-type-btn {
            padding: 8px 16px;
            border: 1px solid #d2d2d7;
            background: #ffffff;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .version-type-btn:hover {
            border-color: #0071e3;
            background: #f0f7ff;
        }

        .version-type-btn.selected {
            background: #0071e3;
            color: white;
            border-color: #0071e3;
        }

        .btn-save-draft {
            background: #f5f5f7;
            color: #1d1d1f;
            border: 1px solid #d2d2d7;
        }

        .btn-save-draft:hover {
            background: #e8e8ed;
        }

        .btn-update-version {
            background: #0071e3;
            color: white;
        }

        .btn-update-version:hover {
            background: #0077ed;
        }

        /* Compare Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            z-index: 10001;
        }

        .compare-modal-content {
            width: 1400px;
            height: 85vh;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 32px;
            color: #86868b;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background-color: #f5f5f7;
        }

        /* Compare selectors */
        .compare-selectors {
            padding: 20px 24px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            gap: 20px;
        }

        .compare-selector-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .compare-selector-group label {
            font-size: 13px;
            font-weight: 500;
            color: #1d1d1f;
        }

        .compare-selector-group select {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: white;
            cursor: pointer;
        }

        /* Compare container */
        .compare-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #d2d2d7;
            overflow: hidden;
        }

        .compare-panel {
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .compare-panel-header {
            padding: 12px 16px;
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .compare-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Diff highlighting */
        .diff-line {
            display: block;
            margin: 0;
            padding: 2px 0;
        }

        .diff-added {
            background-color: #d1f4d1;
            color: #0d6932;
        }

        .diff-removed {
            background-color: #ffd8d8;
            color: #d60000;
            text-decoration: line-through;
        }

        .diff-unchanged {
            color: #1d1d1f;
        }

        .diff-changed {
            background-color: #fff4cc;
            color: #8b6914;
        }

        .btn-compare {
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-compare:hover {
            background: #0077ed;
        }

        /* Error Monitoring Styles */
        .error-monitoring-container {
            padding: 24px;
        }

        .error-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }

        .error-stat-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .error-stat-card h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #6e6e73;
            font-weight: 500;
        }

        .error-count {
            font-size: 32px;
            font-weight: 700;
            color: #ff3b30;
            margin: 8px 0;
        }

        .error-count.success {
            color: #34c759;
        }

        .error-count.critical {
            color: #ff3b30;
            animation: pulse 2s infinite;
        }

        .error-label {
            font-size: 12px;
            color: #8e8e93;
        }

        .error-patterns-section,
        .recent-errors-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .error-patterns-section h3,
        .recent-errors-section h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            color: #1d1d1f;
        }

        .error-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f2f2f7;
        }

        .error-item:last-child {
            border-bottom: none;
        }

        .error-message {
            flex: 1;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            color: #1d1d1f;
        }

        .error-count-badge {
            background: #ff3b30;
            color: white;
            border-radius: 12px;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .error-timestamp {
            font-size: 11px;
            color: #8e8e93;
            margin-left: 12px;
        }

        .auto-fix-badge {
            background: #34c759;
            color: white;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            margin-left: 8px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-title">Cupido Test Dashboard</div>
        <div class="header-actions">
            <!-- Buttons moved to controls bar for better UX -->
        </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
        <div class="tab active" onclick="switchTab('tests', event)">Tests</div>
        <div class="tab" onclick="switchTab('live', event)">Live Preview</div>
        <div class="tab" onclick="switchTab('console', event)">Console</div>
        <div class="tab" onclick="switchTab('history', event)">History</div>
        <div class="tab" onclick="switchTab('error-monitoring', event)">Error Monitor</div>
        <div class="tab" onclick="switchTab('prompts', event)">Prompt Library</div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Tests Tab -->
        <div class="tab-content active" id="tests-tab">
            <!-- Controls Bar -->
            <div class="controls-bar">
                <div class="controls-left">
                    <select id="test-scope" onchange="filterTestsByCategory()">
                        <option value="all" id="all-tests-option">All Tests (72)</option>
                        <option value="foundation">Foundation Tests (5)</option>
                        <option value="prompts">Prompt Management (3)</option>
                        <option value="console">Console Error Detection (5)</option>
                        <option value="message">Message Flow & UI (8)</option>
                        <option value="profile">Profile Extraction (6)</option>
                        <option value="database">Database Operations (5)</option>
                        <option value="error">Error Handling (6)</option>
                        <option value="state">State Management (6)</option>
                        <option value="api">API & Performance (4)</option>
                        <option value="simulator">Simulator Testing (18)</option>
                        <option value="infra">Infrastructure Validation (6)</option>
                    </select>
                    <button class="btn btn-primary" onclick="runSelectedTests()">‚ñ∂ Run Tests</button>
                    <button class="btn btn-secondary" onclick="exportResults()">üì§ Export Results</button>
                    <button class="btn btn-secondary" onclick="selectAll()">Select All</button>
                    <button class="btn btn-secondary" onclick="clearSelection()">Clear</button>
                    <button class="btn btn-primary" onclick="runBrowserDebug()" style="background: #ff3b30; border-color: #ff3b30;">üîç DEBUG</button>
                </div>
                <div class="controls-right">
                    <div class="toggle-container">
                        <label class="toggle-label">Store Logs</label>
                        <label class="toggle">
                            <input type="checkbox" id="store-logs">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Stats Summary -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Total Tests</div>
                    <div class="stat-value" id="total-tests">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Passed</div>
                    <div class="stat-value" style="color: #34c759;" id="passed-tests">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value" style="color: #ff3b30;" id="failed-tests">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Pending</div>
                    <div class="stat-value" style="color: #6e6e73;" id="pending-tests">40</div>
                </div>
            </div>

            <!-- Test Table -->
            <div class="table-container">
                <table id="test-table">
                    <thead>
                        <tr>
                            <th style="width: 40px;"><input type="checkbox" id="select-all" onchange="toggleAllTests()"></th>
                            <th>Test Name</th>
                            <th>Description</th>
                            <th>Module</th>
                            <th>Category</th>
                            <th>Status</th>
                            <th>Last Run</th>
                            <th>Duration</th>
                            <th style="width: 100px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="test-table-body">
                        <!-- Tests will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Live Preview Tab -->
        <div class="tab-content" id="live-tab">
            <div class="live-preview-container">
                <!-- iPhone Preview -->
                <div class="live-preview-iphone">
                    <div class="live-preview-header">
                        <div class="live-preview-title">Live App Preview</div>
                        <button class="btn btn-secondary" style="padding: 4px 12px; font-size: 12px;" onclick="exportChat()">Export Chat</button>
                    </div>
                    <div class="live-preview-content">
                        <div class="iphone-frame">
                            <div class="iphone-notch"></div>
                            <div class="iphone-screen">
                                <iframe
                                    id="live-app-iframe"
                                    class="live-preview-iframe"
                                    src="/app">
                                </iframe>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Simulator Controls -->
                <div class="live-preview-simulator">
                    <div class="live-preview-header">
                        <div class="live-preview-title">Simulator Controls</div>
                    </div>
                    <div class="simulator-content">
                        <!-- Persona Selection -->
                        <div class="simulator-group">
                            <label class="simulator-label">Simulator Persona</label>
                            <select id="simulator-persona" class="simulator-input">
                                <option value="">Loading personas...</option>
                            </select>
                            <div id="persona-info" class="persona-info" style="display: none;"></div>
                        </div>
                        
                        <!-- Simulator Control Buttons -->
                        <div class="simulator-group">
                            <label class="simulator-label">Controls</label>
                            <div class="preset-grid">
                                <button id="sim-start-btn" class="preset-btn" onclick="startSimulator()" style="background: #34c759; color: white;">‚ñ∂ Start</button>
                                <button id="sim-pause-btn" class="preset-btn" onclick="pauseSimulator()" disabled>‚è∏ Pause</button>
                                <button id="sim-stop-btn" class="preset-btn" onclick="stopSimulator()" disabled style="background: #ff3b30; color: white;">‚èπ Stop</button>
                            </div>
                        </div>
                        
                        <!-- Speed Control -->
                        <div class="simulator-group">
                            <div class="slider-value">
                                <label class="simulator-label" style="margin: 0;">Response Speed</label>
                                <span class="slider-value-display" id="speed-value">1x</span>
                            </div>
                            <input type="range" id="speed-slider" class="simulator-slider" min="0.5" max="3" step="0.5" value="1" oninput="updateSimulatorSpeed(this.value); document.getElementById('speed-value').textContent = this.value + 'x'">
                        </div>

                        <!-- Testing Variations -->
                        <div class="simulator-group">
                            <div class="slider-value">
                                <label class="simulator-label" style="margin: 0;">Rudeness Level</label>
                                <span class="slider-value-display" id="rudeness-value">50</span>
                            </div>
                            <input type="range" id="rudeness-slider" class="simulator-slider" min="0" max="100" value="50" oninput="updateRudenessValue(this.value)">
                        </div>

                        <div class="simulator-group">
                            <label class="simulator-label">Max Messages</label>
                            <input type="number" id="max-messages" class="simulator-number" min="1" max="100" value="10">
                        </div>

                        <div class="simulator-group">
                            <label class="simulator-label">Response Style</label>
                            <select id="response-style" class="simulator-input">
                                <option value="balanced">Balanced</option>
                                <option value="friendly">Friendly & Warm</option>
                                <option value="flirty">Flirty & Playful</option>
                                <option value="casual">Casual & Relaxed</option>
                                <option value="deep">Deep & Thoughtful</option>
                                <option value="humorous">Humorous & Witty</option>
                            </select>
                        </div>

                        <!-- Message Input -->
                        <div class="simulator-group">
                            <label class="simulator-label">Message</label>
                            <textarea id="sim-message" class="simulator-input" placeholder="Type your message..." rows="4"></textarea>
                        </div>

                        <!-- Include Contextual Image -->
                        <div class="simulator-group">
                            <label class="simulator-checkbox">
                                <input type="checkbox" id="include-image">
                                <span>Include contextual image (based on message)</span>
                            </label>
                        </div>

                        <!-- Quick Presets -->
                        <div class="simulator-group">
                            <label class="simulator-label">Quick Presets</label>
                            <div class="preset-grid">
                                <button class="preset-btn" onclick="loadPreset('intro')">üëã Intro</button>
                                <button class="preset-btn" onclick="loadPreset('question')">‚ùì Question</button>
                                <button class="preset-btn" onclick="loadPreset('casual')">üí¨ Casual</button>
                                <button class="preset-btn" onclick="loadPreset('deep')">ü§î Deep</button>
                            </div>
                        </div>

                        <!-- Send Button -->
                        <button class="simulator-send-btn" onclick="sendSimulatorMessage()">
                            <span>Send Message</span>
                        </button>

                        <!-- Automation Controls -->
                        <div class="simulator-group" style="border-top: 1px solid #d2d2d7; padding-top: 20px; margin-top: 20px;">
                            <label class="simulator-label">ü§ñ Automation</label>

                            <div style="margin-bottom: 12px;">
                                <div class="slider-value">
                                    <label class="simulator-label" style="margin: 0; font-size: 12px; font-weight: 500;">Message Delay (seconds)</label>
                                    <span class="slider-value-display" id="delay-value">2</span>
                                </div>
                                <input type="range" id="message-delay" class="simulator-slider" min="1" max="10" value="2" oninput="updateDelayValue(this.value)">
                            </div>

                            <div class="preset-grid">
                                <button class="preset-btn" onclick="startAutoConversation(5)">üîÑ Auto 5x</button>
                                <button class="preset-btn" onclick="startAutoConversation(10)">üîÑ Auto 10x</button>
                                <button class="preset-btn" onclick="stopAutoConversation()" style="background: #ff3b30; color: white;">‚èπ Stop</button>
                            </div>
                        </div>

                        <!-- Conversation Templates -->
                        <div class="simulator-group">
                            <label class="simulator-label">üí¨ Conversation Templates</label>
                            <div class="preset-grid">
                                <button class="preset-btn" onclick="loadTemplate('first-date')">üåπ First Date</button>
                                <button class="preset-btn" onclick="loadTemplate('deep-talk')">ü§î Deep Talk</button>
                                <button class="preset-btn" onclick="loadTemplate('flirty')">üòò Flirty</button>
                                <button class="preset-btn" onclick="loadTemplate('getting-to-know')">üëã Getting to Know</button>
                            </div>
                        </div>

                        <!-- Live Metrics -->
                        <div class="simulator-group" style="background: #f5f5f7; padding: 12px; border-radius: 8px;">
                            <label class="simulator-label">üìä Live Metrics</label>
                            <div id="live-metrics" style="font-size: 12px; color: #1d1d1f;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span>Response Time:</span>
                                    <span id="metric-response-time">--</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span>Messages Sent:</span>
                                    <span id="metric-messages">0</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span>Engagement Score:</span>
                                    <span id="metric-engagement">--</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>Detected Mood:</span>
                                    <span id="metric-mood">--</span>
                                </div>
                            </div>
                        </div>

                        <!-- Save/Load Scenario -->
                        <div class="simulator-group">
                            <label class="simulator-label">üíæ Test Scenarios</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                                <input type="text" id="scenario-name" class="simulator-input" style="flex: 1;" placeholder="Scenario name...">
                                <button class="preset-btn" onclick="saveScenario()" style="width: auto; padding: 8px 16px;">Save</button>
                            </div>
                            <select id="saved-scenarios" class="simulator-input" onchange="loadScenario(this.value)">
                                <option value="">Load scenario...</option>
                            </select>
                        </div>

                        <!-- Export Results -->
                        <button class="simulator-send-btn" onclick="exportTestResults()" style="background: #34c759;">
                            <span>üì• Export Test Results</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Console Tab -->
        <div class="tab-content" id="console-tab">
            <div class="console-header">
                <div style="display: flex; gap: 16px; align-items: center;">
                    <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Unified Console</h3>
                    <div class="claude-status">
                        <div class="status-dot idle" id="claude-status-dot"></div>
                        <div class="status-text" id="claude-status-text">Idle</div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="btn btn-secondary" onclick="filterConsole('all')">All</button>
                    <button class="btn btn-secondary" onclick="filterConsole('test')">Tests</button>
                    <button class="btn btn-secondary" onclick="filterConsole('app')">App</button>
                    <button class="btn btn-secondary" onclick="filterConsole('simulator')">Simulator</button>
                    <div style="border-left: 1px solid #d2d2d7; height: 24px; margin: 0 8px;"></div>
                    <span style="color: #6e6e73; font-size: 13px;">Show:</span>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                        <input type="checkbox" id="filter-info" checked onchange="filterLogLevels()">
                        <span style="color: #0071e3;">Info</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                        <input type="checkbox" id="filter-warning" checked onchange="filterLogLevels()">
                        <span style="color: #ff9500;">Warn</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                        <input type="checkbox" id="filter-error" checked onchange="filterLogLevels()">
                        <span style="color: #ff3b30;">Error</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                        <input type="checkbox" id="filter-success" checked onchange="filterLogLevels()">
                        <span style="color: #34c759;">Pass</span>
                    </label>
                    <div style="border-left: 1px solid #d2d2d7; height: 24px; margin: 0 8px;"></div>
                    <button class="btn btn-secondary" onclick="copyFilteredLogs()">Copy</button>
                    <button class="btn btn-secondary" onclick="clearUnifiedConsole()">Clear</button>
                </div>
            </div>
            <div class="unified-console" id="unified-console">
                <div class="console-line">
                    <span class="console-timestamp">[00:00:00]</span>
                    <span class="console-info">Unified console initialized. Test and app logs will appear here.</span>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div class="tab-content" id="history-tab">
            <div class="empty-state">
                <div class="empty-state-icon">üìä</div>
                <h3>Test History</h3>
                <p>View past test runs and results</p>
            </div>
        </div>

        <!-- Error Monitoring Tab -->
        <div class="tab-content" id="error-monitoring-tab">
            <div class="error-monitoring-container">
                <div class="error-stats-grid">
                    <!-- Error Statistics Cards -->
                    <div class="error-stat-card">
                        <h4>Last 24 Hours</h4>
                        <div class="error-count" id="errors-24h">-</div>
                        <div class="error-label">Total Errors</div>
                    </div>
                    <div class="error-stat-card">
                        <h4>Last Week</h4>
                        <div class="error-count" id="errors-week">-</div>
                        <div class="error-label">Total Errors</div>
                    </div>
                    <div class="error-stat-card">
                        <h4>Auto-Fixed</h4>
                        <div class="error-count success" id="errors-fixed">-</div>
                        <div class="error-label">Automatically Resolved</div>
                    </div>
                    <div class="error-stat-card">
                        <h4>Critical</h4>
                        <div class="error-count critical" id="errors-critical">-</div>
                        <div class="error-label">Requires Attention</div>
                    </div>
                </div>

                <!-- Error Patterns -->
                <div class="error-patterns-section">
                    <h3>Error Patterns</h3>
                    <div class="error-patterns-list" id="error-patterns-list">
                        <div class="loading">Loading error patterns...</div>
                    </div>
                </div>

                <!-- Recent Errors -->
                <div class="recent-errors-section">
                    <h3>Recent Errors</h3>
                    <div class="recent-errors-list" id="recent-errors-list">
                        <div class="loading">Loading recent errors...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Prompt Library Tab -->
        <div class="tab-content" id="prompts-tab">
            <div class="prompt-library-container">
                <!-- Left Panel: Prompt List -->
                <div class="prompt-sidebar">
                    <!-- Toolbar with New, Search, and Filter in one row -->
                    <div class="prompt-toolbar">
                        <button class="btn btn-primary btn-icon" id="new-prompt-btn" title="New Prompt">
                            <span style="font-size: 18px;">+</span>
                        </button>
                        <div class="toolbar-search">
                            <input type="text" id="prompt-search" placeholder="Search..." class="search-input">
                        </div>
                        <button class="btn btn-secondary btn-icon" id="filter-btn" title="Filter">
                            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M3 6h14M5 10h10M7 14h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Filter Panel (hidden by default) -->
                    <div class="filter-panel" id="filter-panel" style="display: none;">
                        <div class="filter-section">
                            <div class="filter-label">Tags</div>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="cupido" class="tag-checkbox"> Cupido App
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="simulator" class="tag-checkbox"> Simulator
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="extractor" class="tag-checkbox"> Extractor
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="money2020" class="tag-checkbox"> Money2020
                            </label>
                        </div>
                        <div class="filter-section">
                            <div class="filter-label">Status</div>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="active" class="status-checkbox"> Active
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="draft" class="status-checkbox"> Draft
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="archived" class="status-checkbox"> Archived
                            </label>
                        </div>
                    </div>

                    <!-- Prompt List -->
                    <div class="prompt-list" id="prompt-list">
                        <div class="prompt-list-loading">Loading prompts...</div>
                    </div>
                </div>

                <!-- Right Panel: Prompt Editor -->
                <div class="prompt-editor-panel" id="prompt-editor-panel">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <h3>No Prompt Selected</h3>
                        <p>Select a prompt from the list or create a new one</p>
                    </div>
                </div>

                <!-- Compare Versions Modal -->
                <div id="compare-modal" class="modal" style="display: none;">
                    <div class="modal-overlay" onclick="closeCompareModal()"></div>
                    <div class="modal-content compare-modal-content">
                        <div class="modal-header">
                            <h2>Compare Versions</h2>
                            <button class="modal-close" onclick="closeCompareModal()">√ó</button>
                        </div>

                        <!-- Version Selectors -->
                        <div class="compare-selectors">
                            <div class="compare-selector-group">
                                <label>From Version:</label>
                                <select id="compare-from-version" onchange="updateComparison()">
                                    <!-- Populated dynamically -->
                                </select>
                            </div>
                            <div class="compare-selector-group">
                                <label>To Version:</label>
                                <select id="compare-to-version" onchange="updateComparison()">
                                    <!-- Populated dynamically -->
                                </select>
                            </div>
                        </div>

                        <!-- Side-by-side comparison -->
                        <div class="compare-container">
                            <div class="compare-panel">
                                <div class="compare-panel-header" id="compare-from-header">Version 1.0.0</div>
                                <div class="compare-panel-content" id="compare-from-content"></div>
                            </div>
                            <div class="compare-panel">
                                <div class="compare-panel-header" id="compare-to-header">Version 2.0.0</div>
                                <div class="compare-panel-content" id="compare-to-content"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load comprehensive test functions -->
    <script src="comprehensive-test-functions.js"></script>
    
    <!-- Load infrastructure test functions -->
    <script src="infrastructure-tests.js"></script>

    <script>
        // Simulator state management - exposed on window for test access
        const simulatorState = {
            isActive: false,
            isPaused: false,
            speed: 1,
            selectedPersonaId: null,
            conversationHistory: [],
            typingDelayMin: 1000,
            typingDelayMax: 3000
        };
        
        // Expose simulator state globally for tests
        window.simulatorState = simulatorState;
        
        // Test configuration from comprehensive test functions
        const testConfig = {
            foundation: { name: 'Foundation Tests', count: 5 },
            prompts: { name: 'Prompt Management', count: 3 },
            console: { name: 'Console Error Detection', count: 5 },
            message: { name: 'Message Flow & UI', count: 8 },
            profile: { name: 'Profile Extraction', count: 6 },
            database: { name: 'Database Operations', count: 5 },
            error: { name: 'Error Handling', count: 6 },
            state: { name: 'State Management', count: 6 },
            api: { name: 'API & Performance', count: 4 },
            simulator: { name: 'Simulator Testing', count: 18 },
            infra: { name: 'Infrastructure Validation', count: 6 }
        };

        // Initialize tests
        let tests = [];
        let testResults = {};
        let selectedTests = new Set();
        let currentTest = null;
        let currentTestRun = {
            id: null,
            startTime: null,
            tests: []
        };

        // API Call Tracker
        const apiCalls = [];
        function trackApiCall(url, method, body, response, duration) {
            const call = {
                url,
                method,
                body,
                response,
                duration,
                timestamp: new Date().toISOString()
            };
            apiCalls.push(call);
            logToConsole(`API Call: ${method} ${url} (${duration}ms)`, 'info', 'app');
            return call;
        }
        
        // Simulator control functions
        async function handleCupidoMessage(userMessage) {
            if (!simulatorState.isActive || simulatorState.isPaused) return;
            
            // Add user message to conversation history
            simulatorState.conversationHistory.push({
                role: 'user',
                content: userMessage
            });
            
            // Calculate typing delay
            const delay = simulatorState.typingDelayMin + 
                Math.random() * (simulatorState.typingDelayMax - simulatorState.typingDelayMin);
            const adjustedDelay = delay / simulatorState.speed;
            
            logToConsole(`Simulator will respond in ${Math.round(adjustedDelay)}ms`, 'info', 'simulator');
            
            // Wait for typing delay
            setTimeout(async () => {
                if (!simulatorState.isActive || simulatorState.isPaused) return;
                
                try {
                    // Generate response from simulator API
                    const response = await fetch('/api/simulator/generate-response', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            personaPromptId: simulatorState.selectedPersonaId,
                            conversationHistory: simulatorState.conversationHistory.slice(-10), // Last 10 messages
                            userMessage: userMessage
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.response) {
                        // Add AI response to history
                        simulatorState.conversationHistory.push({
                            role: 'assistant',
                            content: data.response
                        });
                        
                        // Send response to Cupido app
                        const iframe = document.getElementById('app-iframe');
                        if (iframe && iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'simulator-response',
                                message: data.response,
                                personaName: data.personaName
                            }, '*');
                        }
                        
                        logToConsole(`[SIMULATOR ${data.personaName}] ${data.response}`, 'success', 'simulator');
                    }
                } catch (error) {
                    logToConsole(`Simulator error: ${error.message}`, 'error', 'simulator');
                }
            }, adjustedDelay);
        }
        
        function startSimulator() {
            const personaSelect = document.getElementById('simulator-persona');
            if (!personaSelect || !personaSelect.value) {
                alert('Please select a simulator persona first');
                return;
            }
            
            simulatorState.isActive = true;
            simulatorState.isPaused = false;
            simulatorState.selectedPersonaId = personaSelect.value;
            simulatorState.conversationHistory = [];
            
            updateSimulatorControls();
            logToConsole('Simulator started', 'success', 'simulator');
        }
        
        function pauseSimulator() {
            simulatorState.isPaused = !simulatorState.isPaused;
            updateSimulatorControls();
            logToConsole(simulatorState.isPaused ? 'Simulator paused' : 'Simulator resumed', 'info', 'simulator');
        }
        
        function stopSimulator() {
            simulatorState.isActive = false;
            simulatorState.isPaused = false;
            simulatorState.conversationHistory = [];
            updateSimulatorControls();
            logToConsole('Simulator stopped', 'info', 'simulator');
        }
        
        function updateSimulatorSpeed(speed) {
            simulatorState.speed = parseFloat(speed);
            logToConsole(`Simulator speed set to ${speed}x`, 'info', 'simulator');
        }
        
        function updateSimulatorControls() {
            const startBtn = document.getElementById('sim-start-btn');
            const pauseBtn = document.getElementById('sim-pause-btn');
            const stopBtn = document.getElementById('sim-stop-btn');
            const personaSelect = document.getElementById('simulator-persona');
            
            if (startBtn) startBtn.disabled = simulatorState.isActive;
            if (pauseBtn) {
                pauseBtn.disabled = !simulatorState.isActive;
                pauseBtn.textContent = simulatorState.isPaused ? 'Resume' : 'Pause';
            }
            if (stopBtn) stopBtn.disabled = !simulatorState.isActive;
            if (personaSelect) personaSelect.disabled = simulatorState.isActive;
        }
        
        async function loadSimulatorPersonas() {
            try {
                const response = await fetch('/api/prompts');
                const prompts = await response.json();
                
                // Filter for simulator tagged prompts
                const simulatorPrompts = prompts.filter(p => 
                    p.tags && p.tags.includes('simulator') && p.is_active
                );
                
                const personaSelect = document.getElementById('simulator-persona');
                if (personaSelect) {
                    personaSelect.innerHTML = '<option value="">Select persona...</option>';
                    simulatorPrompts.forEach(prompt => {
                        const option = document.createElement('option');
                        option.value = prompt.id;
                        option.textContent = `${prompt.name} (v${prompt.version || '1.0.0'})`;
                        personaSelect.appendChild(option);
                    });
                    
                    if (simulatorPrompts.length === 0) {
                        personaSelect.innerHTML = '<option value="">No simulator personas available</option>';
                        logToConsole('No simulator personas found. Create prompts with "simulator" tag.', 'warn', 'simulator');
                    }
                }
            } catch (error) {
                logToConsole(`Failed to load simulator personas: ${error.message}`, 'error', 'simulator');
            }
        }

        // Database Logger - stores all test runs in localStorage
        class TestLogger {
            constructor() {
                this.dbKey = 'cupido_test_logs';
                this.currentRunKey = 'cupido_current_test_run';
            }

            // Initialize a new test run
            startTestRun() {
                const runId = `test_run_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
                currentTestRun = {
                    id: runId,
                    startTime: new Date().toISOString(),
                    endTime: null,
                    tests: [],
                    environment: {
                        apiUrl: 'http://localhost:3001/api/chat',
                        appUrl: '/app',
                        userAgent: navigator.userAgent,
                        timestamp: Date.now()
                    }
                };
                localStorage.setItem(this.currentRunKey, JSON.stringify(currentTestRun));
                logToConsole(`Started test run: ${runId}`, 'info');
                return runId;
            }

            // Log a test execution
            logTest(testId, testName, status, message, details = {}) {
                const testLog = {
                    testId,
                    testName,
                    status,
                    message,
                    timestamp: new Date().toISOString(),
                    duration: details.duration || 0,
                    apiCalls: details.apiCalls || [],
                    errors: details.errors || [],
                    metadata: details.metadata || {}
                };

                currentTestRun.tests.push(testLog);
                localStorage.setItem(this.currentRunKey, JSON.stringify(currentTestRun));
            }

            // Finalize test run and save to history
            endTestRun() {
                currentTestRun.endTime = new Date().toISOString();
                currentTestRun.totalDuration = Date.now() - new Date(currentTestRun.startTime).getTime();

                const passed = currentTestRun.tests.filter(t => t.status === 'pass').length;
                const failed = currentTestRun.tests.filter(t => t.status === 'fail').length;

                currentTestRun.summary = {
                    total: currentTestRun.tests.length,
                    passed,
                    failed,
                    passRate: ((passed / currentTestRun.tests.length) * 100).toFixed(1)
                };

                // Save to history
                const history = this.getHistory();
                history.unshift(currentTestRun);

                // Keep only last 50 test runs
                if (history.length > 50) {
                    history.splice(50);
                }

                localStorage.setItem(this.dbKey, JSON.stringify(history));
                localStorage.removeItem(this.currentRunKey);

                logToConsole(`Test run completed: ${passed}/${currentTestRun.tests.length} passed`,
                    passed === currentTestRun.tests.length ? 'success' : 'error');

                // POST test results to API for automated analysis
                this.postResultsToAPI(currentTestRun);
            }

            // POST results to API for automated fix loop
            async postResultsToAPI(testRun) {
                try {
                    const response = await fetch('http://localhost:3001/api/test-results', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(testRun)
                    });

                    if (response.ok) {
                        console.log('Test results posted to API for automated analysis');
                    } else {
                        console.warn('Failed to post test results to API');
                    }
                } catch (error) {
                    console.warn('Could not post test results to API:', error.message);
                }
            }

            // Get test history
            getHistory() {
                const data = localStorage.getItem(this.dbKey);
                return data ? JSON.parse(data) : [];
            }

            // Get specific test run
            getTestRun(runId) {
                const history = this.getHistory();
                return history.find(run => run.id === runId);
            }

            // Clear all history
            clearHistory() {
                localStorage.removeItem(this.dbKey);
                localStorage.removeItem(this.currentRunKey);
                logToConsole('Test history cleared', 'info');
            }

            // Export logs as JSON
            exportLogs() {
                const history = this.getHistory();
                const dataStr = JSON.stringify(history, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `cupido_test_logs_${Date.now()}.json`;
                link.click();
                logToConsole('Logs exported', 'success');
            }
        }

        const testLogger = new TestLogger();

        // Generate test list from TEST_FUNCTIONS
        function initializeTests() {
            // CRITICAL: Add debugging and error handling for TEST_FUNCTIONS loading
            console.log('üîç initializeTests called');
            console.log('üîç window.TEST_FUNCTIONS available:', !!window.TEST_FUNCTIONS);
            
            if (window.TEST_FUNCTIONS) {
                const functionCount = Object.keys(window.TEST_FUNCTIONS).length;
                console.log(`üîç Found ${functionCount} test functions`);
                
                Object.keys(window.TEST_FUNCTIONS).forEach(testId => {
                    const [category, num] = testId.split('-');
                    const metadata = getTestMetadata(testId);
                    tests.push({
                        id: testId,
                        name: getTestName(testId),
                        description: metadata.description,
                        module: metadata.module,
                        category: testConfig[category]?.name || category,
                        status: 'pending',
                        lastRun: null,
                        duration: null
                    });
                });
                
                console.log(`üîç Initialized ${tests.length} tests`);
                logToConsole(`‚úÖ Loaded ${functionCount} test functions successfully`, 'success');
            } else {
                console.error('‚ùå TEST_FUNCTIONS not available - comprehensive-test-functions.js may not have loaded');
                logToConsole('‚ùå TEST_FUNCTIONS not loaded - checking in 1 second...', 'error');
                
                // Retry after 1 second to allow for script loading
                setTimeout(() => {
                    if (window.TEST_FUNCTIONS) {
                        console.log('üîÑ TEST_FUNCTIONS now available, retrying initialization...');
                        logToConsole('üîÑ TEST_FUNCTIONS loaded, retrying initialization...', 'info');
                        
                        // Clear tests array and reinitialize
                        tests.length = 0;
                        initializeTests();
                        renderTestTable();
                        updateStats();
                    } else {
                        console.error('‚ùå TEST_FUNCTIONS still not available after retry');
                        logToConsole('‚ùå CRITICAL: TEST_FUNCTIONS failed to load after retry', 'error');
                        logToConsole('üí° Try refreshing the page or check browser console for errors', 'warning');
                    }
                }, 1000);
                return; // Don't render table if no tests loaded
            }
            renderTestTable();
        }

        // Get test name from test ID
        function getTestName(testId) {
            const names = {
                'console-1': 'No ReferenceErrors',
                'console-2': 'No TypeErrors',
                'console-3': 'No Network Errors',
                'console-4': 'No Warning Messages',
                'console-5': 'Clean Console Output',
                'message-1': 'Send Message Flow',
                'message-2': 'Receive Message Flow',
                'message-3': 'Message UI Update',
                'message-4': 'Message History',
                'message-5': 'Message Retry',
                'message-6': 'Message Timestamps',
                'message-7': 'Message Status',
                'message-8': 'Message Ordering',
                'profile-1': 'Extract Profile Data',
                'profile-2': 'Profile Completeness',
                'profile-3': 'Profile Validation',
                'profile-4': 'Profile Update',
                'profile-5': 'Profile Persistence',
                'profile-6': 'Profile Display',
                'database-1': 'Save to Database',
                'database-2': 'Load from Database',
                'database-3': 'Update Database',
                'database-4': 'Delete from Database',
                'database-5': 'Database Sync',
                'error-1': 'Network Error Handling',
                'error-2': 'API Error Handling',
                'error-3': 'Validation Errors',
                'error-4': 'Error Recovery',
                'error-5': 'Error Display',
                'error-6': 'Error Logging',
                'state-1': 'State Initialization',
                'state-2': 'State Updates',
                'state-3': 'State Persistence',
                'state-4': 'State Reset',
                'state-5': 'State Validation',
                'state-6': 'Loading States',
                'api-1': 'API Connectivity',
                'api-2': 'API Response Time',
                'api-3': 'API Error Handling',
                'api-4': 'API Rate Limiting'
            };
            return names[testId] || testId;
        }

        // Get test metadata (description and module)
        function getTestMetadata(testId) {
            const metadata = {
                'console-1': {
                    description: 'Monitor for ReferenceError during message send (catches bugs like commonLocations)',
                    module: 'userProfileService.ts'
                },
                'console-2': {
                    description: 'Monitor for TypeError in profile operations and UI rendering',
                    module: 'userProfileService.ts'
                },
                'console-3': {
                    description: 'Monitor for network errors in API calls and image loading',
                    module: 'apiService.ts'
                },
                'console-4': {
                    description: 'Check for warning messages in console during normal operation',
                    module: 'SimpleReflectionChat.tsx'
                },
                'console-5': {
                    description: 'Ensure console is clean with no unexpected errors or warnings',
                    module: 'App.tsx'
                },
                'message-1': {
                    description: 'Verify message send flow from input to chat history',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-2': {
                    description: 'Verify AI response is received and displayed correctly',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-3': {
                    description: 'Check that UI updates immediately when message is sent',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-4': {
                    description: 'Verify message history persists and loads correctly',
                    module: 'chatDatabase.ts'
                },
                'message-5': {
                    description: 'Test message retry functionality on failure',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-6': {
                    description: 'Verify timestamps are correctly displayed for all messages',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-7': {
                    description: 'Check message status indicators (sending, sent, failed)',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-8': {
                    description: 'Verify messages appear in correct chronological order',
                    module: 'chatDatabase.ts'
                },
                'profile-1': {
                    description: 'Test extraction of profile data from conversation',
                    module: 'personalityInsightsService.ts'
                },
                'profile-2': {
                    description: 'Check profile completeness score calculation',
                    module: 'userProfileService.ts'
                },
                'profile-3': {
                    description: 'Validate profile data structure and required fields',
                    module: 'userProfileService.ts'
                },
                'profile-4': {
                    description: 'Test profile update when new information is extracted',
                    module: 'personalityInsightsService.ts'
                },
                'profile-5': {
                    description: 'Verify profile data persists across sessions',
                    module: 'userProfileService.ts'
                },
                'profile-6': {
                    description: 'Check profile display on PixelPerfectProfileScreen',
                    module: 'PixelPerfectProfileScreen.tsx'
                },
                'database-1': {
                    description: 'Test saving messages and profile to AsyncStorage',
                    module: 'chatDatabase.ts'
                },
                'database-2': {
                    description: 'Test loading saved data from AsyncStorage',
                    module: 'chatDatabase.ts'
                },
                'database-3': {
                    description: 'Test updating existing records in database',
                    module: 'chatDatabase.ts'
                },
                'database-4': {
                    description: 'Test deleting messages and clearing chat history',
                    module: 'chatDatabase.ts'
                },
                'database-5': {
                    description: 'Verify database sync with app state',
                    module: 'chatDatabase.ts'
                },
                'error-1': {
                    description: 'Test handling of network timeout and connection errors',
                    module: 'apiService.ts'
                },
                'error-2': {
                    description: 'Test handling of API errors (4xx, 5xx responses)',
                    module: 'apiService.ts'
                },
                'error-3': {
                    description: 'Test validation error handling for user input',
                    module: 'SimpleReflectionChat.tsx'
                },
                'error-4': {
                    description: 'Test error recovery and retry mechanisms',
                    module: 'SimpleReflectionChat.tsx'
                },
                'error-5': {
                    description: 'Verify error messages are displayed to user',
                    module: 'SimpleReflectionChat.tsx'
                },
                'error-6': {
                    description: 'Check that errors are logged for debugging',
                    module: 'apiService.ts'
                },
                'state-1': {
                    description: 'Test initial state setup when app loads',
                    module: 'App.tsx'
                },
                'state-2': {
                    description: 'Test state updates during message flow',
                    module: 'SimpleReflectionChat.tsx'
                },
                'state-3': {
                    description: 'Test state persistence across app restarts',
                    module: 'chatDatabase.ts'
                },
                'state-4': {
                    description: 'Test state reset when user clears data',
                    module: 'SimpleReflectionChat.tsx'
                },
                'state-5': {
                    description: 'Validate state consistency across components',
                    module: 'App.tsx'
                },
                'state-6': {
                    description: 'Test loading state indicators during operations',
                    module: 'SimpleReflectionChat.tsx'
                },
                'api-1': {
                    description: 'Test connectivity to Claude AI API',
                    module: 'apiService.ts'
                },
                'api-2': {
                    description: 'Measure and verify API response time is acceptable',
                    module: 'apiService.ts'
                },
                'api-3': {
                    description: 'Test graceful handling of API errors',
                    module: 'apiService.ts'
                },
                'api-4': {
                    description: 'Test rate limiting and request throttling',
                    module: 'apiService.ts'
                },
                
                // ==========================================
                // SIMULATOR TESTING (18 tests)
                // ==========================================
                'simulator-1': {
                    description: 'Verify simulator personas load correctly from database',
                    module: 'server.js'
                },
                'simulator-2': {
                    description: 'Test API endpoint /api/simulator/generate-response with valid data',
                    module: 'server.js'
                },
                'simulator-3': {
                    description: 'Test Raj persona generates authentic startup founder responses',
                    module: 'simulator_raj prompt'
                },
                'simulator-4': {
                    description: 'Test Sarah persona generates authentic artist responses',
                    module: 'simulator_sarah prompt'
                },
                'simulator-5': {
                    description: 'Verify conversation history is properly passed to simulator API',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-6': {
                    description: 'Test simulator auto-response to Cupido app messages via postMessage',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-7': {
                    description: 'Verify Start/Pause/Resume controls work correctly',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-8': {
                    description: 'Test Stop control properly resets simulator state',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-9': {
                    description: 'Verify speed controls affect typing delay timing (1x/2x/3x)',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-10': {
                    description: 'Test realistic typing delays (1-3 seconds with randomization)',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-11': {
                    description: 'Verify simulator metadata saves correctly to conversations table',
                    module: 'server.js'
                },
                'simulator-12': {
                    description: 'Test error handling when persona prompt not found',
                    module: 'server.js'
                },
                'simulator-13': {
                    description: 'Test error handling when Claude API fails',
                    module: 'server.js'
                },
                'simulator-14': {
                    description: 'Verify simulator state persistence during pause/resume cycles',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-15': {
                    description: 'Test simulator conversation history limit (last 10 messages)',
                    module: 'server.js'
                },
                'simulator-16': {
                    description: 'Verify persona switching updates simulator behavior correctly',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-17': {
                    description: 'Test iframe communication: Cupido app ‚Üí Dashboard postMessage',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-18': {
                    description: 'Test iframe communication: Dashboard ‚Üí Cupido app response injection',
                    module: 'cupido-test-dashboard.html'
                }
            };
            return metadata[testId] || { description: 'Test description', module: 'Unknown' };
        }

        // Render test table (optionally with filtered tests)
        function renderTestTable(filteredTests = null) {
            const tbody = document.getElementById('test-table-body');
            const testsToShow = filteredTests || tests;
            tbody.innerHTML = testsToShow.map(test => `
                <tr id="test-row-${test.id}">
                    <td><input type="checkbox" class="test-checkbox" value="${test.id}" onchange="toggleTestSelection('${test.id}')"></td>
                    <td>${test.name}</td>
                    <td style="color: #6e6e73; font-size: 13px;">${test.description}</td>
                    <td><span class="category-badge">${test.module}</span></td>
                    <td><span class="category-badge">${test.category}</span></td>
                    <td><span class="status-badge status-${test.status}">${test.status.charAt(0).toUpperCase() + test.status.slice(1)}</span></td>
                    <td>${test.lastRun || '-'}</td>
                    <td>${test.duration ? test.duration + 'ms' : '-'}</td>
                    <td><button class="action-btn" onclick="runSingleTest('${test.id}')">Run</button></td>
                </tr>
            `).join('');
        }

        // Filter tests based on category selection
        function filterTestsByCategory() {
            const selectedCategory = document.getElementById('test-scope').value;
            logToConsole(`üîç Filtering tests by category: ${selectedCategory}`, 'info');
            
            // If "all" is selected, show all tests
            if (selectedCategory === 'all') {
                renderTestTable();
                logToConsole(`‚úÖ Showing all ${tests.length} tests`, 'success');
                return;
            }
            
            // Filter tests by category
            const filteredTests = tests.filter(test => {
                const [testCategory] = test.id.split('-');
                return testCategory === selectedCategory;
            });
            
            // Render filtered test table
            renderTestTable(filteredTests);
            logToConsole(`‚úÖ Showing ${filteredTests.length} tests in category: ${testConfig[selectedCategory]?.name || selectedCategory}`, 'success');
        }

        // Tab switching
        function switchTab(tabName, event) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        // Test selection
        function toggleTestSelection(testId) {
            if (selectedTests.has(testId)) {
                selectedTests.delete(testId);
            } else {
                selectedTests.add(testId);
            }
        }

        function toggleAllTests() {
            const selectAll = document.getElementById('select-all').checked;
            document.querySelectorAll('.test-checkbox').forEach(cb => {
                cb.checked = selectAll;
                if (selectAll) {
                    selectedTests.add(cb.value);
                } else {
                    selectedTests.delete(cb.value);
                }
            });
        }

        function selectAll() {
            document.getElementById('select-all').checked = true;
            toggleAllTests();
        }

        function clearSelection() {
            document.getElementById('select-all').checked = false;
            toggleAllTests();
        }

        // Console logging
        function logToConsole(message, type = 'info', source = 'test') {
            const console = document.getElementById('unified-console');
            if (!console) return;

            const timestamp = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.className = 'console-line';
            line.setAttribute('data-source', source);
            line.innerHTML = `
                <span class="console-timestamp">[${timestamp}]</span>
                <span style="color: #6e6e73;">[${source.toUpperCase()}]</span>
                <span class="console-${type}">${message}</span>
            `;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
        }

        // Unified console functions
        function clearUnifiedConsole() {
            const console = document.getElementById('unified-console');
            if (console) {
                console.innerHTML = '<div class="console-line"><span class="console-timestamp">[' + new Date().toLocaleTimeString() + ']</span><span class="console-info">Console cleared</span></div>';
            }
        }

        function filterConsole(filter) {
            const lines = document.querySelectorAll('#unified-console .console-line');
            lines.forEach(line => {
                const source = line.getAttribute('data-source') || 'test';
                if (filter === 'all' || source === filter) {
                    line.style.display = 'flex';
                } else {
                    line.style.display = 'none';
                }
            });
            // Reapply log level filters
            filterLogLevels();
        }

        // Filter console by log levels (info/warning/error/success)
        function filterLogLevels() {
            const showInfo = document.getElementById('filter-info').checked;
            const showWarning = document.getElementById('filter-warning').checked;
            const showError = document.getElementById('filter-error').checked;
            const showSuccess = document.getElementById('filter-success').checked;
            
            const lines = document.querySelectorAll('#unified-console .console-line');
            lines.forEach(line => {
                // Skip if already hidden by source filter
                if (line.style.display === 'none') return;
                
                const hasInfo = line.querySelector('.console-info');
                const hasWarning = line.querySelector('.console-warning');
                const hasError = line.querySelector('.console-error');
                const hasSuccess = line.querySelector('.console-success');
                
                let shouldShow = false;
                if (hasInfo && showInfo) shouldShow = true;
                if (hasWarning && showWarning) shouldShow = true;
                if (hasError && showError) shouldShow = true;
                if (hasSuccess && showSuccess) shouldShow = true;
                
                // Show timestamps and general messages if info is enabled
                if (!hasInfo && !hasWarning && !hasError && !hasSuccess && showInfo) {
                    shouldShow = true;
                }
                
                line.style.display = shouldShow ? 'flex' : 'none';
            });
        }

        // Copy filtered logs to clipboard
        function copyFilteredLogs() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }
            
            const visibleLines = Array.from(consoleElement.querySelectorAll('.console-line'))
                .filter(line => line.style.display !== 'none');
            
            let logText = '';
            visibleLines.forEach(line => {
                const text = line.textContent.trim();
                if (text) {
                    logText += text + '\n';
                }
            });
            
            if (logText) {
                navigator.clipboard.writeText(logText).then(() => {
                    logToConsole(`Copied ${visibleLines.length} filtered log lines to clipboard`, 'success', 'dashboard');
                }).catch(err => {
                    console.error('Failed to copy logs:', err);
                    logToConsole('Failed to copy logs to clipboard', 'error', 'dashboard');
                });
            } else {
                logToConsole('No visible logs to copy', 'warning', 'dashboard');
            }
        }

        // Copy all console logs to clipboard
        function copyAllLogs() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }

            const lines = consoleElement.querySelectorAll('.console-line');
            let logText = '';

            lines.forEach(line => {
                // Extract text content from the line
                const text = line.textContent || line.innerText;
                if (text.trim()) {
                    logText += text + '\n';
                }
            });

            if (!logText.trim()) {
                alert('No logs to copy');
                return;
            }

            // Copy to clipboard
            navigator.clipboard.writeText(logText).then(() => {
                // Show success message in console
                const originalText = logText;
                logToConsole('‚úì All logs copied to clipboard!', 'success');

                // Remove the success message after 3 seconds
                setTimeout(() => {
                    const lines = consoleElement.querySelectorAll('.console-line');
                    const lastLine = lines[lines.length - 1];
                    if (lastLine && lastLine.textContent.includes('All logs copied')) {
                        lastLine.remove();
                    }
                }, 3000);
            }).catch(err => {
                console.error('Failed to copy logs:', err);
                alert('Failed to copy logs to clipboard. Error: ' + err.message);
            });
        }

        function copyFailuresOnly() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }

            const lines = consoleElement.querySelectorAll('.console-line');
            let allText = '';

            // Collect all text first
            lines.forEach(line => {
                const text = line.textContent || line.innerText;
                if (text.trim()) {
                    allText += text + '\n';
                }
            });

            // Split by test separators
            const testBlocks = allText.split('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            // Filter to only failed tests
            const failedTests = testBlocks.filter(block => {
                return block.includes('Status: FAILED ‚úó');
            });

            if (failedTests.length === 0) {
                alert('No failed tests found');
                return;
            }

            // Reconstruct with separators
            let failureText = 'FAILED TESTS REPORT\n';
            failureText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

            failedTests.forEach((test, index) => {
                if (test.trim()) {
                    failureText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
                    failureText += test.trim() + '\n';
                    failureText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
                }
            });

            failureText += `\nTotal Failed Tests: ${failedTests.length}\n`;

            // Copy to clipboard
            navigator.clipboard.writeText(failureText).then(() => {
                logToConsole(`‚úì ${failedTests.length} failed test(s) copied to clipboard!`, 'success');

                // Remove the success message after 3 seconds
                setTimeout(() => {
                    const lines = consoleElement.querySelectorAll('.console-line');
                    const lastLine = lines[lines.length - 1];
                    if (lastLine && lastLine.textContent.includes('failed test(s) copied')) {
                        lastLine.remove();
                    }
                }, 3000);
            }).catch(err => {
                console.error('Failed to copy failures:', err);
                alert('Failed to copy failures to clipboard. Error: ' + err.message);
            });
        }

        // Run tests
        async function runSelectedTests() {
            const scope = document.getElementById('test-scope').value;
            let testsToRun = [];

            if (scope === 'all') {
                testsToRun = selectedTests.size > 0 ? Array.from(selectedTests) : tests.map(t => t.id);
            } else {
                testsToRun = tests.filter(t => t.id.startsWith(scope + '-')).map(t => t.id);
            }

            if (testsToRun.length === 0) {
                logToConsole('No tests selected', 'warning');
                return;
            }

            logToConsole(`Starting ${testsToRun.length} tests...`, 'info');
            logToConsole('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');

            // Start test run logging
            testLogger.startTestRun();

            // Clear previous results
            testResults = {};
            apiCalls.length = 0;

            for (const testId of testsToRun) {
                await runSingleTest(testId);
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            logToConsole('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            logToConsole(`All tests completed`, 'success');

            // End test run logging
            testLogger.endTestRun();

            updateStats();
        }

        async function runSingleTest(testId) {
            if (currentTest) {
                logToConsole('Another test is running, please wait...', 'warning');
                return;
            }

            const test = tests.find(t => t.id === testId);
            if (!test) return;

            currentTest = testId;
            test.status = 'running';
            test.lastRun = new Date().toLocaleTimeString();
            renderTestTable();

            // Log detailed test start
            logToConsole('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            logToConsole(`Test: ${testId} (${test.name})`, 'info');
            logToConsole(`Category: ${test.category}`, 'info');
            logToConsole(`Status: RUNNING`, 'info');
            logToConsole(`Started at: ${test.lastRun}`, 'info');

            const startTime = Date.now();
            const testApiCalls = [];
            const testErrors = [];

            try {
                const testFn = window.TEST_FUNCTIONS[testId];
                if (testFn) {
                    logToConsole(`Executing test function...`, 'info');

                    const result = await testFn();
                    const duration = Date.now() - startTime;

                    test.status = result.pass ? 'pass' : 'fail';
                    test.duration = duration;

                    // Log detailed results
                    logToConsole(`Status: ${result.pass ? 'PASSED ‚úì' : 'FAILED ‚úó'}`, result.pass ? 'success' : 'error');
                    logToConsole(`Duration: ${duration}ms`, 'info');
                    logToConsole(`Result: ${result.message}`, result.pass ? 'success' : 'error');

                    if (!result.pass) {
                        // Log detailed failure information
                        if (result.errors && result.errors.length > 0) {
                            logToConsole(`Errors Found:`, 'error');
                            result.errors.forEach((err, idx) => {
                                logToConsole(`  ${idx + 1}. ${err}`, 'error');
                            });
                        }

                        // Log metadata for debugging
                        if (result.metadata) {
                            logToConsole(`Debug Information:`, 'info');
                            Object.keys(result.metadata).forEach(key => {
                                logToConsole(`  - ${key}: ${JSON.stringify(result.metadata[key])}`, 'info');
                            });
                        }

                        // Log suggestions based on test category
                        logToConsole(`Suggestions:`, 'warning');
                        if (testId.startsWith('console-')) {
                            logToConsole(`  - Check browser console for detailed error messages`, 'warning');
                            logToConsole(`  - Verify all required JavaScript files are loaded`, 'warning');
                            logToConsole(`  - Look for undefined variables or missing imports`, 'warning');
                        } else if (testId.startsWith('message-')) {
                            logToConsole(`  - Verify iframe communication is working`, 'warning');
                            logToConsole(`  - Check if Live Preview tab has loaded the app`, 'warning');
                            logToConsole(`  - Ensure message handlers are registered`, 'warning');
                            logToConsole(`  - Verify testID attributes are rendered as data-testid in DOM`, 'warning');
                            if (result.metadata && result.metadata.issue === 'DOM element not accessible') {
                                logToConsole(`  - HINT: ${result.metadata.hint}`, 'warning');
                            }
                        } else if (testId.startsWith('profile-')) {
                            logToConsole(`  - Check AI response for profile extraction`, 'warning');
                            logToConsole(`  - Verify profile service is running`, 'warning');
                        } else if (testId.startsWith('database-')) {
                            logToConsole(`  - Verify database connection`, 'warning');
                            logToConsole(`  - Check Supabase credentials`, 'warning');
                        } else if (testId.startsWith('api-')) {
                            logToConsole(`  - Ensure server is running on port 3001`, 'warning');
                            logToConsole(`  - Check API credentials`, 'warning');
                        }

                        testErrors.push(result.message);
                    }

                    // Log to database
                    testLogger.logTest(testId, test.name, result.pass ? 'pass' : 'fail', result.message, {
                        duration,
                        apiCalls: result.apiCalls || testApiCalls,
                        errors: testErrors,
                        metadata: result.metadata || {}
                    });

                    testResults[testId] = result.pass;
                } else {
                    const duration = Date.now() - startTime;
                    test.status = 'fail';
                    test.duration = duration;

                    logToConsole(`Status: FAILED ‚úó`, 'error');
                    logToConsole(`Duration: ${duration}ms`, 'info');
                    logToConsole(`Error: Test function not found`, 'error');
                    logToConsole(`Details:`, 'error');
                    logToConsole(`  - Test ID: ${testId}`, 'error');
                    logToConsole(`  - Function should be in: comprehensive-test-functions.js`, 'error');
                    logToConsole(`Suggestions:`, 'warning');
                    logToConsole(`  - Verify comprehensive-test-functions.js is loaded`, 'warning');
                    logToConsole(`  - Check that TEST_FUNCTIONS object contains '${testId}'`, 'warning');
                    logToConsole(`  - Reload the page to refresh test functions`, 'warning');

                    testErrors.push('Test function not found');

                    // Log to database
                    testLogger.logTest(testId, test.name, 'fail', 'Test function not found', {
                        duration,
                        apiCalls: testApiCalls,
                        errors: testErrors,
                        metadata: {}
                    });

                    testResults[testId] = false;
                }
            } catch (error) {
                const duration = Date.now() - startTime;
                test.status = 'fail';
                test.duration = duration;

                logToConsole(`Status: FAILED ‚úó`, 'error');
                logToConsole(`Duration: ${duration}ms`, 'info');
                logToConsole(`Error: ${error.message}`, 'error');

                if (error.stack) {
                    logToConsole(`Stack Trace:`, 'error');
                    const stackLines = error.stack.split('\n').slice(0, 5); // First 5 lines
                    stackLines.forEach(line => {
                        logToConsole(`  ${line.trim()}`, 'error');
                    });
                }

                logToConsole(`Details:`, 'error');
                logToConsole(`  - Error Type: ${error.name || 'Unknown'}`, 'error');
                logToConsole(`  - Test ID: ${testId}`, 'error');

                logToConsole(`Suggestions:`, 'warning');
                if (error.message.includes('iframe')) {
                    logToConsole(`  - Verify Live Preview tab has loaded the app`, 'warning');
                    logToConsole(`  - Check iframe ID is 'live-app-iframe'`, 'warning');
                    logToConsole(`  - Ensure app is running without errors`, 'warning');
                } else if (error.message.includes('timeout') || error.message.includes('Timeout')) {
                    logToConsole(`  - Server may be slow or unresponsive`, 'warning');
                    logToConsole(`  - Check network connectivity`, 'warning');
                    logToConsole(`  - Verify API server is running`, 'warning');
                } else {
                    logToConsole(`  - Check browser console for more details`, 'warning');
                    logToConsole(`  - Review the stack trace above`, 'warning');
                }

                testErrors.push(error.message);

                // Log to database
                testLogger.logTest(testId, test.name, 'fail', `Error: ${error.message}`, {
                    duration,
                    apiCalls: testApiCalls,
                    errors: testErrors,
                    metadata: { stack: error.stack }
                });

                testResults[testId] = false;
            }

            logToConsole('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            logToConsole('', 'info'); // Blank line for spacing

            currentTest = null;
            renderTestTable();
            updateStats();
        }

        // Update stats - automatically calculated from TEST_FUNCTIONS
        function updateStats() {
            // CRITICAL: Calculate total from actual TEST_FUNCTIONS object, not manual config
            const actualTestCount = window.TEST_FUNCTIONS ? Object.keys(window.TEST_FUNCTIONS).length : 0;
            
            const passed = tests.filter(t => t.status === 'pass').length;
            const failed = tests.filter(t => t.status === 'fail').length;
            const pending = tests.filter(t => t.status === 'pending').length;

            // Use actual test count, not hardcoded value
            document.getElementById('total-tests').textContent = actualTestCount;
            document.getElementById('passed-tests').textContent = passed;
            document.getElementById('failed-tests').textContent = failed;
            document.getElementById('pending-tests').textContent = pending;
            
            // Validation: Ensure tests array matches TEST_FUNCTIONS
            if (tests.length !== actualTestCount) {
                console.warn(`Test count mismatch: tests.length=${tests.length}, TEST_FUNCTIONS=${actualTestCount}`);
                logToConsole(`‚ö†Ô∏è  Test count mismatch detected: ${tests.length} vs ${actualTestCount}`, 'warning');
            }
        }

        // Export results
        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                tests: tests,
                summary: {
                    total: tests.length,
                    passed: tests.filter(t => t.status === 'pass').length,
                    failed: tests.filter(t => t.status === 'fail').length,
                    pending: tests.filter(t => t.status === 'pending').length
                }
            };

            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cupido-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            logToConsole('Test results exported', 'success');
        }

        // Show test history
        function showHistory() {
            const history = testLogger.getHistory();
            console.log('Test History:');
            console.table(history.map(run => ({
                id: run.id.slice(-8),
                startTime: new Date(run.startTime).toLocaleString(),
                total: run.summary?.total || 0,
                passed: run.summary?.passed || 0,
                failed: run.summary?.failed || 0,
                passRate: run.summary?.passRate + '%' || '0%'
            })));
            logToConsole(`Found ${history.length} test runs in history`, 'info');
        }

        // Auto-fix test failures
        async function autoFixFailures() {
            logToConsole('AUTO-FIX: Starting automated failure analysis...', 'info');

            try {
                // Fetch latest test results
                const response = await fetch('http://localhost:3001/api/test-results/latest');
                if (!response.ok) {
                    if (response.status === 404) {
                        logToConsole('AUTO-FIX: No test results available. Run tests first.', 'warning');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const testResults = await response.json();
                const failedTests = testResults.tests.filter(t => t.status === 'fail');

                if (failedTests.length === 0) {
                    logToConsole('AUTO-FIX: All tests passing! No fixes needed.', 'success');
                    return;
                }

                logToConsole(`AUTO-FIX: Found ${failedTests.length} failed test(s). Analyzing with Claude AI...`, 'info');

                // Build analysis prompt
                const analysisPrompt = `You are an expert software debugger analyzing test failures for a React Native web app.

Test Results Summary:
- Total: ${testResults.summary.total}
- Passed: ${testResults.summary.passed}
- Failed: ${testResults.summary.failed}

Failed Tests:
${failedTests.map((test, idx) => `
${idx + 1}. ${test.testName} (${test.testId})
   Status: ${test.status}
   Message: ${test.message}
   Errors: ${JSON.stringify(test.errors || [])}
   Metadata: ${JSON.stringify(test.metadata || {})}`).join('\n')}

Analyze these failures and provide:
1. Root cause of each failure
2. Which file(s) need to be fixed
3. Specific code changes needed
4. Risk level (LOW/MEDIUM/HIGH) for each fix

Format as JSON:
{
  "analysis": "overall analysis",
  "fixes": [
    {
      "testId": "test-id",
      "file": "path/to/file",
      "reason": "why this fix is needed",
      "riskLevel": "LOW|MEDIUM|HIGH",
      "changes": "description of changes"
    }
  ]
}`;

                // Call Claude AI for analysis
                const aiResponse = await fetch('http://localhost:3001/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: [
                            { role: 'user', content: analysisPrompt }
                        ],
                        modelType: 'sonnet'
                    })
                });

                if (!aiResponse.ok) {
                    throw new Error(`Claude API error: ${aiResponse.status}`);
                }

                const aiData = await aiResponse.json();
                const analysisText = aiData.message;

                // Try to parse JSON from Claude's response
                const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
                let analysis;
                if (jsonMatch) {
                    analysis = JSON.parse(jsonMatch[0]);
                } else {
                    logToConsole('AUTO-FIX: Could not parse structured response from Claude', 'warning');
                    logToConsole(`Analysis: ${analysisText}`, 'info');
                    return;
                }

                logToConsole(`AUTO-FIX Analysis: ${analysis.analysis}`, 'info');
                logToConsole(`AUTO-FIX: Proposed ${analysis.fixes.length} fix(es)`, 'info');

                // Process each fix
                for (let i = 0; i < analysis.fixes.length; i++) {
                    const fix = analysis.fixes[i];
                    logToConsole(`Fix ${i + 1}/${analysis.fixes.length}: ${fix.file}`, 'info');
                    logToConsole(`Test: ${fix.testId}`, 'info');
                    logToConsole(`Risk: ${fix.riskLevel}`, 'info');
                    logToConsole(`Reason: ${fix.reason}`, 'info');
                    logToConsole(`Changes: ${fix.changes}`, 'info');

                    // Determine if safe to auto-apply
                    const isRiskyFile = /server\.js$|\.env$|package\.json$|tsconfig\.json$/.test(fix.file);
                    const isSafe = fix.riskLevel === 'LOW' && !isRiskyFile;

                    if (isSafe) {
                        logToConsole(`AUTO-FIX: Low risk - requesting detailed fix instructions...`, 'success');

                        // Get detailed fix from Claude
                        const fixPrompt = `Generate the exact code changes for this fix:

File: ${fix.file}
Reason: ${fix.reason}
Changes needed: ${fix.changes}

Provide specific, actionable instructions for the developer to apply this fix manually.
Include the exact code snippets that need to be changed.`;

                        const fixResponse = await fetch('http://localhost:3001/api/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                messages: [
                                    { role: 'user', content: fixPrompt }
                                ],
                                modelType: 'sonnet'
                            })
                        });

                        if (fixResponse.ok) {
                            const fixData = await fixResponse.json();
                            logToConsole(`Fix Instructions:\n${fixData.message}`, 'info');
                        }
                    } else {
                        logToConsole(`AUTO-FIX: ${fix.riskLevel} risk or critical file - manual review required`, 'warning');
                        logToConsole(`Action required: Please review and apply this fix manually`, 'warning');
                    }
                }

                logToConsole(`AUTO-FIX: Analysis complete! Review the fix instructions above.`, 'success');

            } catch (error) {
                logToConsole(`AUTO-FIX Error: ${error.message}`, 'error');
                console.error('Auto-fix error:', error);
            }
        }

        // Global functions for console access
        window.showHistory = showHistory;
        window.autoFixFailures = autoFixFailures;
        window.exportLogs = () => testLogger.exportLogs();
        window.clearHistory = () => testLogger.clearHistory();

        // Live Preview Functions
        let claudeStatus = 'idle';

        // Persona definitions from chatsim.html
        const SIMULATOR_PERSONAS = {
            sarah: {
                name: 'Sarah Chen',
                age: 28,
                occupation: 'Product Manager at Google',
                location: 'San Francisco, CA',
                bio: 'Tech enthusiast who loves hiking and photography. Looking for someone ambitious and adventurous.',
                interests: ['Technology', 'Hiking', 'Photography', 'Travel']
            },
            mike: {
                name: 'Mike Rodriguez',
                age: 32,
                occupation: 'Graphic Designer',
                location: 'Brooklyn, NY',
                bio: 'Creative soul with a passion for art and good coffee. Seeking genuine connections.',
                interests: ['Design', 'Art', 'Coffee', 'Music']
            },
            emily: {
                name: 'Emily Watson',
                age: 24,
                occupation: 'PhD Student in Biology',
                location: 'Boston, MA',
                bio: 'Science nerd who enjoys running and reading sci-fi novels. Love deep conversations.',
                interests: ['Science', 'Running', 'Reading', 'Nature']
            },
            raj: {
                name: 'Raj Patel',
                age: 35,
                occupation: 'Entrepreneur',
                location: 'Austin, TX',
                bio: 'Startup founder balancing work and life. Foodie who loves trying new restaurants.',
                interests: ['Business', 'Food', 'Travel', 'Fitness']
            },
            rachel: {
                name: 'Rachel Kim',
                age: 29,
                occupation: 'Artist',
                location: 'Portland, OR',
                bio: 'Painter and yoga instructor. Seeking someone creative and mindful.',
                interests: ['Art', 'Yoga', 'Meditation', 'Sustainability']
            },
            alex: {
                name: 'Alex Torres',
                age: 31,
                occupation: 'Startup Founder',
                location: 'Miami, FL',
                bio: 'Serial entrepreneur passionate about tech and social impact. Love the beach and good books.',
                interests: ['Technology', 'Entrepreneurship', 'Reading', 'Beach Sports']
            }
        };


        // Update persona info display
        function updatePersonaInfo() {
            const personaSelect = document.getElementById('persona-select');
            const personaId = personaSelect.value;
            const personaInfo = document.getElementById('persona-info');

            if (!personaId) {
                personaInfo.style.display = 'none';
                return;
            }

            // Get prompt data from the selected option
            const selectedOption = personaSelect.options[personaSelect.selectedIndex];
            const promptData = selectedOption.dataset.promptData;

            if (promptData) {
                // Using Supabase simulator prompt
                const prompt = JSON.parse(promptData);
                personaInfo.style.display = 'block';
                personaInfo.innerHTML = `
                    <div style="margin-top: 8px; padding: 12px; background: #f5f5f7; border-radius: 8px;">
                        <div style="font-weight: 600; color: #1d1d1f;">${prompt.name}</div>
                        <div style="font-size: 12px; color: #6e6e73; margin-top: 4px;">Version: ${prompt.version}</div>
                        ${prompt.description ? `<div style="font-size: 12px; color: #1d1d1f; margin-top: 8px;">${prompt.description}</div>` : ''}
                        <div style="font-size: 11px; color: #86868b; margin-top: 8px;">From Supabase Prompt Library</div>
                    </div>
                `;
            } else if (typeof SIMULATOR_PERSONAS !== 'undefined' && SIMULATOR_PERSONAS[personaId]) {
                // Fallback to hardcoded personas (for backwards compatibility)
                const persona = SIMULATOR_PERSONAS[personaId];
                personaInfo.style.display = 'block';
                personaInfo.innerHTML = `
                    <div style="margin-top: 8px; padding: 12px; background: #f5f5f7; border-radius: 8px;">
                        <div style="font-weight: 600; color: #1d1d1f;">${persona.name}, ${persona.age}</div>
                        <div style="font-size: 12px; color: #6e6e73; margin-top: 4px;">${persona.occupation}</div>
                        <div style="font-size: 12px; color: #6e6e73;">${persona.location}</div>
                        <div style="font-size: 12px; color: #1d1d1f; margin-top: 8px;">${persona.bio}</div>
                    </div>
                `;
            }
        }

        // Load preset messages
        function loadPreset(presetType) {
            const messageInput = document.getElementById('sim-message');
            const presets = {
                intro: "Hey! I just saw your profile and thought we might have some things in common. What do you like to do in your free time?",
                question: "What's something you're really passionate about?",
                casual: "How's your day going?",
                deep: "What's something you've learned about yourself recently?"
            };

            messageInput.value = presets[presetType] || '';
            logToConsole(`Loaded preset: ${presetType}`, 'info', 'app');
        }

        // Update rudeness slider value display
        function updateRudenessValue(value) {
            document.getElementById('rudeness-value').textContent = value;
        }

        // Get contextual search query from message
        function getImageSearchQuery(message) {
            // Extract key nouns/topics from the message for image search
            const keywords = ['coffee', 'travel', 'beach', 'mountain', 'food', 'sunset', 'city', 'nature', 'art', 'music', 'fitness', 'yoga', 'hiking', 'restaurant', 'book', 'movie', 'concert', 'weekend', 'adventure'];
            const lowerMessage = message.toLowerCase();

            for (const keyword of keywords) {
                if (lowerMessage.includes(keyword)) {
                    return keyword;
                }
            }

            // Default to lifestyle images if no keyword found
            return 'lifestyle';
        }

        // Simulator Control Functions
        async function sendSimulatorMessage() {
            const messageInput = document.getElementById('sim-message');
            const message = messageInput.value.trim();
            const includeImage = document.getElementById('include-image').value === 'true';
            const personaId = document.getElementById('persona-select').value;
            const rudenessLevel = document.getElementById('rudeness-slider').value;
            const maxMessages = document.getElementById('max-messages').value;
            const responseStyle = document.getElementById('response-style').value;

            if (!message) {
                logToConsole('Error: Message cannot be empty', 'error', 'app');
                return;
            }

            const messageData = {
                type: 'simulator-message',
                content: message,
                persona: personaId ? SIMULATOR_PERSONAS[personaId] : null,
                testingParams: {
                    rudenessLevel: parseInt(rudenessLevel),
                    maxMessages: parseInt(maxMessages),
                    responseStyle: responseStyle
                }
            };

            // Add contextual image if checkbox is checked
            if (includeImage) {
                const searchQuery = getImageSearchQuery(message);
                // Use Unsplash Source API with contextual search
                messageData.imageUrl = `https://source.unsplash.com/400x300/?${searchQuery}`;
                logToConsole(`Including contextual image (${searchQuery}) in message`, 'info', 'app');
            }

            // Post message to iframe
            const iframe = document.getElementById('live-app-iframe');
            iframe.contentWindow.postMessage(messageData, '*');

            const personaName = personaId ? SIMULATOR_PERSONAS[personaId].name : 'User';
            const params = `Style: ${responseStyle}, Rudeness: ${rudenessLevel}`;
            logToConsole(`Sent message from ${personaName}: "${message}"${includeImage ? ' (with contextual image)' : ''} [${params}]`, 'info', 'app');
            messageInput.value = '';
        }


        function exportChat() {
            const iframe = document.getElementById('live-app-iframe');

            // Request chat export from iframe
            iframe.contentWindow.postMessage({
                type: 'export-chat'
            }, '*');

            logToConsole('Exporting chat history...', 'info', 'app');
        }

        // ============================================
        // ADVANCED TESTING FEATURES
        // ============================================

        // Update delay slider value display
        function updateDelayValue(value) {
            document.getElementById('delay-value').textContent = value;
        }

        // Automation state management
        let autoConversationInterval = null;
        let autoMessageCount = 0;
        let autoTargetCount = 0;
        let testMetrics = {
            messagesSent: 0,
            responseTimes: [],
            startTime: null,
            lastMessageTime: null,
            engagementScore: 0,
            detectedMood: 'neutral'
        };

        // Conversation templates with pre-built message flows
        const CONVERSATION_TEMPLATES = {
            'first-date': [
                "Hi! It's nice to finally meet you üòä",
                "What kind of things do you enjoy doing on weekends?",
                "That sounds fun! Do you have any favorite spots in the city?",
                "I'd love to hear more about that sometime!"
            ],
            'deep-talk': [
                "What's something you're really passionate about?",
                "That's fascinating. What drew you to that initially?",
                "Do you think that's shaped who you are today?",
                "What's a belief you used to have that you've changed your mind about?"
            ],
            'flirty': [
                "You have such a great vibe! üòä",
                "What's your idea of a perfect date?",
                "I have to admit, I'm really enjoying talking with you",
                "So when are we making this happen? üòâ"
            ],
            'getting-to-know': [
                "Tell me something interesting about yourself!",
                "What's been the highlight of your week so far?",
                "If you could travel anywhere right now, where would you go?",
                "What's something that always makes you smile?"
            ]
        };

        // Start automated conversation with specified message count
        async function startAutoConversation(count) {
            if (autoConversationInterval) {
                logToConsole('‚ö†Ô∏è Automation already running. Stop current run first.', 'warn', 'app');
                return;
            }

            autoTargetCount = count;
            autoMessageCount = 0;
            testMetrics.startTime = Date.now();
            testMetrics.messagesSent = 0;
            testMetrics.responseTimes = [];

            const delaySeconds = parseInt(document.getElementById('message-delay').value);
            const naturalMessages = getNextNaturalMessage.messages || [];

            logToConsole(`ü§ñ Starting automated conversation: ${count} messages with ${delaySeconds}s delay`, 'info', 'app');
            updateMetrics();

            autoConversationInterval = setInterval(async () => {
                if (autoMessageCount >= autoTargetCount) {
                    stopAutoConversation();
                    return;
                }

                // Get next message from natural conversation flow
                const messageIndex = autoMessageCount % naturalMessages.length;
                const message = naturalMessages[messageIndex] || `Test message ${autoMessageCount + 1}`;

                // Set the message in the input and send it
                const messageInput = document.getElementById('sim-message');
                messageInput.value = message;

                const sendStartTime = Date.now();
                await sendSimulatorMessage();

                // Track metrics
                autoMessageCount++;
                testMetrics.messagesSent++;
                testMetrics.lastMessageTime = Date.now();

                // Simulate response time tracking (in real scenario, would track actual bot response)
                const responseTime = Math.random() * 2000 + 500; // 0.5-2.5s
                testMetrics.responseTimes.push(responseTime);

                updateMetrics();

                logToConsole(`üì§ Auto-sent message ${autoMessageCount}/${autoTargetCount}`, 'info', 'app');
            }, delaySeconds * 1000);
        }

        // Stop automated conversation
        function stopAutoConversation() {
            if (autoConversationInterval) {
                clearInterval(autoConversationInterval);
                autoConversationInterval = null;
                logToConsole(`‚èπ Automation stopped. Sent ${autoMessageCount}/${autoTargetCount} messages`, 'info', 'app');

                // Final metrics update
                updateMetrics();
            }
        }

        // Load conversation template
        function loadTemplate(templateType) {
            const template = CONVERSATION_TEMPLATES[templateType];

            if (!template) {
                logToConsole(`‚ö†Ô∏è Template "${templateType}" not found`, 'warn', 'app');
                return;
            }

            // Stop any running automation
            if (autoConversationInterval) {
                stopAutoConversation();
            }

            logToConsole(`üìã Loading "${templateType}" template (${template.length} messages)`, 'info', 'app');

            // Override the natural message flow temporarily
            const originalMessages = getNextNaturalMessage.messages;
            getNextNaturalMessage.messages = [...template];

            // Start automated conversation with template length
            setTimeout(() => {
                startAutoConversation(template.length);

                // Restore original messages after template completes
                setTimeout(() => {
                    getNextNaturalMessage.messages = originalMessages;
                }, template.length * parseInt(document.getElementById('message-delay').value) * 1000 + 1000);
            }, 100);
        }

        // Update live metrics display
        function updateMetrics() {
            // Update messages sent
            document.getElementById('metric-messages').textContent = testMetrics.messagesSent;

            // Calculate and display average response time
            if (testMetrics.responseTimes.length > 0) {
                const avgResponseTime = testMetrics.responseTimes.reduce((a, b) => a + b, 0) / testMetrics.responseTimes.length;
                document.getElementById('metric-response-time').textContent = `${(avgResponseTime / 1000).toFixed(2)}s`;
            } else {
                document.getElementById('metric-response-time').textContent = '--';
            }

            // Calculate engagement score (0-100 based on response time and message count)
            if (testMetrics.messagesSent > 0) {
                const avgResponseTime = testMetrics.responseTimes.length > 0
                    ? testMetrics.responseTimes.reduce((a, b) => a + b, 0) / testMetrics.responseTimes.length
                    : 1000;

                // Lower response time = higher engagement
                // More messages = higher engagement
                const responseScore = Math.max(0, 100 - (avgResponseTime / 30)); // Max 3s for good score
                const messageScore = Math.min(100, testMetrics.messagesSent * 5); // Cap at 100
                testMetrics.engagementScore = Math.round((responseScore + messageScore) / 2);

                document.getElementById('metric-engagement').textContent = `${testMetrics.engagementScore}/100`;
            } else {
                document.getElementById('metric-engagement').textContent = '--';
            }

            // Detect mood based on rudeness level and response style
            const rudenessLevel = parseInt(document.getElementById('rudeness-slider').value);
            const responseStyle = document.getElementById('response-style').value;

            if (rudenessLevel > 70) {
                testMetrics.detectedMood = 'üò§ Confrontational';
            } else if (rudenessLevel > 50) {
                testMetrics.detectedMood = 'üòê Neutral';
            } else if (responseStyle === 'flirty') {
                testMetrics.detectedMood = 'üòò Flirty';
            } else if (responseStyle === 'friendly') {
                testMetrics.detectedMood = 'üòä Friendly';
            } else if (responseStyle === 'deep') {
                testMetrics.detectedMood = 'ü§î Thoughtful';
            } else if (responseStyle === 'humorous') {
                testMetrics.detectedMood = 'üòÑ Playful';
            } else {
                testMetrics.detectedMood = 'üòå Casual';
            }

            document.getElementById('metric-mood').textContent = testMetrics.detectedMood;
        }

        // Save current test scenario configuration
        function saveScenario() {
            const scenarioName = document.getElementById('scenario-name').value.trim();

            if (!scenarioName) {
                logToConsole('‚ö†Ô∏è Please enter a scenario name', 'warn', 'app');
                return;
            }

            // Collect current configuration
            const scenario = {
                name: scenarioName,
                timestamp: new Date().toISOString(),
                config: {
                    rudenessLevel: parseInt(document.getElementById('rudeness-slider').value),
                    maxMessages: parseInt(document.getElementById('max-messages').value),
                    responseStyle: document.getElementById('response-style').value,
                    messageDelay: parseInt(document.getElementById('message-delay').value),
                    persona: document.getElementById('persona-select').value,
                    includeImage: document.getElementById('include-image').value === 'true'
                },
                metrics: { ...testMetrics }
            };

            // Save to localStorage
            let savedScenarios = JSON.parse(localStorage.getItem('cupido-test-scenarios') || '[]');
            savedScenarios.push(scenario);
            localStorage.setItem('cupido-test-scenarios', JSON.stringify(savedScenarios));

            // Update dropdown
            updateScenarioDropdown();

            logToConsole(`üíæ Saved scenario: "${scenarioName}"`, 'success', 'app');

            // Clear scenario name input
            document.getElementById('scenario-name').value = '';
        }

        // Load saved test scenario
        function loadScenario(scenarioName) {
            if (!scenarioName) return;

            const savedScenarios = JSON.parse(localStorage.getItem('cupido-test-scenarios') || '[]');
            const scenario = savedScenarios.find(s => s.name === scenarioName);

            if (!scenario) {
                logToConsole(`‚ö†Ô∏è Scenario "${scenarioName}" not found`, 'warn', 'app');
                return;
            }

            // Apply configuration
            const config = scenario.config;
            document.getElementById('rudeness-slider').value = config.rudenessLevel;
            updateRudenessValue(config.rudenessLevel);
            document.getElementById('max-messages').value = config.maxMessages;
            document.getElementById('response-style').value = config.responseStyle;
            document.getElementById('message-delay').value = config.messageDelay;
            updateDelayValue(config.messageDelay);
            document.getElementById('persona-select').value = config.persona;
            document.getElementById('include-image').checked = config.includeImage;

            logToConsole(`üìÇ Loaded scenario: "${scenarioName}"`, 'success', 'app');
            logToConsole(`Config: Rudeness=${config.rudenessLevel}, Style=${config.responseStyle}, Delay=${config.messageDelay}s`, 'info', 'app');
        }

        // Update scenario dropdown with saved scenarios
        function updateScenarioDropdown() {
            const savedScenarios = JSON.parse(localStorage.getItem('cupido-test-scenarios') || '[]');
            const dropdown = document.getElementById('saved-scenarios');

            // Clear existing options (except first one)
            dropdown.innerHTML = '<option value="">Load scenario...</option>';

            // Add saved scenarios
            savedScenarios.forEach(scenario => {
                const option = document.createElement('option');
                option.value = scenario.name;
                option.textContent = `${scenario.name} (${new Date(scenario.timestamp).toLocaleDateString()})`;
                dropdown.appendChild(option);
            });
        }

        // Export comprehensive test results
        function exportTestResults() {
            const testResults = {
                exportDate: new Date().toISOString(),
                testConfiguration: {
                    rudenessLevel: parseInt(document.getElementById('rudeness-slider').value),
                    maxMessages: parseInt(document.getElementById('max-messages').value),
                    responseStyle: document.getElementById('response-style').value,
                    messageDelay: parseInt(document.getElementById('message-delay').value),
                    persona: document.getElementById('persona-select').value,
                    includeImage: document.getElementById('include-image').value === 'true'
                },
                metrics: {
                    ...testMetrics,
                    averageResponseTime: testMetrics.responseTimes.length > 0
                        ? testMetrics.responseTimes.reduce((a, b) => a + b, 0) / testMetrics.responseTimes.length
                        : 0,
                    totalDuration: testMetrics.startTime ? Date.now() - testMetrics.startTime : 0
                },
                testHistory: window.testHistory || [],
                consoleLog: window.consoleLog || []
            };

            // Create downloadable JSON file
            const dataStr = JSON.stringify(testResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cupido-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            logToConsole('üì• Test results exported successfully', 'success', 'app');
            logToConsole(`Exported: ${testMetrics.messagesSent} messages, ${(window.testHistory || []).length} tests, ${(window.consoleLog || []).length} log entries`, 'info', 'app');
        }

        // Initialize scenarios dropdown on load
        function initializeAdvancedFeatures() {
            updateScenarioDropdown();

            // Update metrics display periodically
            setInterval(() => {
                if (autoConversationInterval || testMetrics.messagesSent > 0) {
                    updateMetrics();
                }
            }, 1000);
        }

        // ============================================
        // END ADVANCED TESTING FEATURES
        // ============================================

        function updateClaudeStatus(status, message) {
            claudeStatus = status;
            const statusDot = document.getElementById('claude-status-dot');
            const statusText = document.getElementById('claude-status-text');

            statusDot.className = 'status-dot ' + status;
            statusText.textContent = message || status.charAt(0).toUpperCase() + status.slice(1);

            logToConsole(`Claude Code: ${message || status}`, status === 'idle' ? 'info' : 'success', 'app');
        }

        // Monitor console errors from iframe
        function setupConsoleMonitoring() {
            // Listen for messages from the iframe
            window.addEventListener('message', (event) => {
                if (!event.data || !event.data.type) return;

                switch (event.data.type) {
                    case 'console':
                        const { level, message } = event.data;
                        logToConsole(`[APP] ${message}`, level, 'app');
                        break;

                    case 'app-console-log':
                        // App console forwarding
                        const logLevel = event.data.level === 'error' ? 'error' :
                                       event.data.level === 'warn' ? 'warn' : 'info';
                        logToConsole(`[APP] ${event.data.message}`, logLevel, 'app');
                        break;

                    case 'api-call':
                        // Log API calls from the app
                        const { url, method, duration, status } = event.data;
                        logToConsole(`API Call: ${method} ${url} - ${status} (${duration}ms)`, 'info', 'app');
                        trackApiCall(url, method, event.data.body, event.data.response, duration);
                        break;

                    case 'message-sent':
                        // Log when user sends a message
                        logToConsole(`User sent message: "${event.data.message}"`, 'info', 'app');
                        break;

                    case 'message-received':
                        // Log when AI response is received
                        logToConsole(`AI response received (${event.data.duration}ms)`, 'success', 'app');
                        break;

                    case 'chat-export':
                        // Handle exported chat data
                        const chatData = event.data.data;
                        downloadChatExport(chatData);
                        logToConsole('Chat exported successfully', 'success', 'app');
                        break;

                    case 'cupido-message':
                        // Handle messages from Cupido app
                        if (simulatorState.isActive && event.data.sender === 'user') {
                            logToConsole(`[CUPIDO USER] ${event.data.message}`, 'info', 'app');
                            // Auto-generate simulator response after a delay
                            handleCupidoMessage(event.data.message);
                        }
                        break;
                    
                    case 'simulator-response':
                        // Handle simulator responses
                        const response = event.data.response;
                        logToConsole(`[SIMULATOR] ${response}`, 'info', 'app');
                        break;

                    case 'app-error':
                        logToConsole(`[ERROR] ${event.data.error}`, 'error', 'app');
                        break;

                    case 'app-info':
                        logToConsole(`[INFO] ${event.data.message}`, 'info', 'app');
                        break;
                }
            });

            // Simulate Claude Code status changes for demo
            // In production, this would be connected to actual backend
            setInterval(() => {
                if (Math.random() > 0.95) {
                    const statuses = [
                        { status: 'analyzing', message: 'Analyzing code...' },
                        { status: 'fixing', message: 'Applying fixes...' },
                        { status: 'testing', message: 'Running tests...' }
                    ];
                    const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
                    updateClaudeStatus(randomStatus.status, randomStatus.message);

                    setTimeout(() => {
                        updateClaudeStatus('idle', 'Idle');
                    }, 3000);
                }
            }, 10000);
        }

        // Download chat export
        function downloadChatExport(chatData) {
            const dataStr = JSON.stringify(chatData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cupido-chat-export-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Add keyboard support for simulator message input
        function setupKeyboardShortcuts() {
            const messageInput = document.getElementById('sim-message');
            if (messageInput) {
                messageInput.addEventListener('keydown', (e) => {
                    // Send on Enter (without Shift for new line)
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendSimulatorMessage();
                    }
                });
            }
        }

        // Initialize Live Preview
        function initializeLivePreview() {
            setupConsoleMonitoring();
            setupKeyboardShortcuts();
            loadSimulatorPersonas(); // Load simulator prompts from Supabase
            logToConsole('Live Preview initialized', 'success', 'app');
            logToConsole('Monitoring console output from app...', 'info', 'app');
            logToConsole('Simulator controls ready for testing', 'info', 'app');
        }

        // Load simulator-tagged prompts for persona selector
        async function loadSimulatorPersonas() {
            try {
                const response = await fetch('/api/prompts');
                if (!response.ok) throw new Error('Failed to load prompts');

                const allPrompts = await response.json();

                // Filter for simulator-tagged prompts only
                const simulatorPrompts = allPrompts.filter(p =>
                    p.tags && p.tags.includes('simulator')
                );

                // Populate the persona selector
                const personaSelect = document.getElementById('persona-select');
                if (personaSelect) {
                    // Clear existing options except the first "Select persona..."
                    personaSelect.innerHTML = '<option value="">Select persona...</option>';

                    // Add simulator prompts as options
                    simulatorPrompts.forEach(prompt => {
                        const option = document.createElement('option');
                        option.value = prompt.prompt_id;
                        option.textContent = `${prompt.prompt_name} (v${prompt.active_version || prompt.version_string})`;
                        option.dataset.promptData = JSON.stringify({
                            id: prompt.prompt_id,
                            name: prompt.prompt_name,
                            description: prompt.description || '',
                            systemPrompt: prompt.system_prompt,
                            version: prompt.active_version || prompt.version_string
                        });
                        personaSelect.appendChild(option);
                    });

                    logToConsole(`Loaded ${simulatorPrompts.length} simulator persona(s) from Supabase`, 'success', 'app');
                }
            } catch (error) {
                console.error('Failed to load simulator personas:', error);
                logToConsole('Failed to load simulator personas from Supabase', 'error', 'app');
            }
        }

        // Update test scope dropdown with actual counts
        function updateTestScopeDropdown() {
            const dropdown = document.getElementById('test-scope');
            if (!dropdown) return;
            
            // Update "All Tests" option
            const allOption = dropdown.querySelector('option[value="all"]');
            if (allOption) {
                allOption.textContent = `All Tests (${tests.length})`;
            }
            
            // Update category counts
            Object.keys(testConfig).forEach(category => {
                const option = dropdown.querySelector(`option[value="${category}"]`);
                if (option) {
                    option.textContent = `${testConfig[category].name} (${testConfig[category].count})`;
                }
            });
        }

        // Error monitoring functions
        async function loadErrorStats() {
            try {
                const response = await fetch('/api/error-stats');
                const stats = await response.json();
                
                document.getElementById('errors-24h').textContent = stats.last24h;
                document.getElementById('errors-week').textContent = stats.lastWeek;
                
                const autoFixed = stats.topErrors.filter(e => e.autoFixed).length;
                document.getElementById('errors-fixed').textContent = autoFixed;
                
                const critical = stats.topErrors.filter(e => !e.autoFixed).length;
                document.getElementById('errors-critical').textContent = critical;
                
                // Render error patterns
                const patternsContainer = document.getElementById('error-patterns-list');
                if (stats.patterns.length === 0) {
                    patternsContainer.innerHTML = '<div class="loading">No error patterns detected</div>';
                } else {
                    patternsContainer.innerHTML = stats.patterns.slice(0, 10).map(pattern => `
                        <div class="error-item">
                            <div class="error-message">${pattern.pattern}</div>
                            <div>
                                <span class="error-count-badge">${pattern.count}</span>
                                <span class="error-timestamp">${new Date(pattern.lastSeen).toLocaleString()}</span>
                            </div>
                        </div>
                    `).join('');
                }
                
                // Render recent errors
                const errorsContainer = document.getElementById('recent-errors-list');
                if (stats.topErrors.length === 0) {
                    errorsContainer.innerHTML = '<div class="loading">No recent errors</div>';
                } else {
                    errorsContainer.innerHTML = stats.topErrors.map(error => `
                        <div class="error-item">
                            <div class="error-message">${error.message}</div>
                            <div>
                                ${error.autoFixed ? '<span class="auto-fix-badge">Auto-Fixed</span>' : ''}
                                <span class="error-timestamp">${new Date(error.timestamp).toLocaleString()}</span>
                            </div>
                        </div>
                    `).join('');
                }
                
            } catch (error) {
                console.error('Failed to load error stats:', error);
                document.getElementById('errors-24h').textContent = 'Error';
                document.getElementById('errors-week').textContent = 'Error';
                document.getElementById('errors-fixed').textContent = 'Error';
                document.getElementById('errors-critical').textContent = 'Error';
            }
        }

        // Enhanced tab switching to load error monitoring data
        // Store reference to original switchTab function (defined earlier)
        const originalSwitchTabFunction = function(tabName, event) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabName + '-tab').classList.add('active');
        };

        // Override the global switchTab function
        window.switchTab = function(tabName, event) {
            originalSwitchTabFunction(tabName, event);
            
            // Load error monitoring data when switching to error monitoring tab
            if (tabName === 'error-monitoring') {
                loadErrorStats();
                // Auto-refresh every 30 seconds
                if (window.errorMonitoringInterval) {
                    clearInterval(window.errorMonitoringInterval);
                }
                window.errorMonitoringInterval = setInterval(loadErrorStats, 30000);
            } else {
                // Clear auto-refresh when leaving error monitoring tab
                if (window.errorMonitoringInterval) {
                    clearInterval(window.errorMonitoringInterval);
                    window.errorMonitoringInterval = null;
                }
            }
            
            // Initialize prompt library when switching to prompts tab
            if (tabName === 'prompts') {
                initializePromptLibrary();
            }
        };

        // BROWSER DEBUG FUNCTION - Co-founder level debugging
        function runBrowserDebug() {
            logToConsole('üîç BROWSER DEBUG STARTING...', 'info');
            logToConsole('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            
            // Check TEST_FUNCTIONS availability
            logToConsole(`üîç window.TEST_FUNCTIONS available: ${!!window.TEST_FUNCTIONS}`, 'info');
            if (window.TEST_FUNCTIONS) {
                const functionCount = Object.keys(window.TEST_FUNCTIONS).length;
                logToConsole(`üîç TEST_FUNCTIONS count: ${functionCount}`, 'success');
                logToConsole(`üîç First few functions: ${Object.keys(window.TEST_FUNCTIONS).slice(0, 5).join(', ')}`, 'info');
            } else {
                logToConsole('‚ùå TEST_FUNCTIONS is not available', 'error');
            }
            
            // Check tests array
            logToConsole(`üîç tests array length: ${tests ? tests.length : 'tests array not found'}`, 'info');
            
            // Check DOM elements
            logToConsole('üîç DOM elements:', 'info');
            logToConsole(`  total-tests element: ${document.getElementById('total-tests')?.textContent}`, 'info');
            logToConsole(`  passed-tests element: ${document.getElementById('passed-tests')?.textContent}`, 'info');
            logToConsole(`  pending-tests element: ${document.getElementById('pending-tests')?.textContent}`, 'info');
            
            // Check testConfig
            logToConsole('üîç testConfig:', 'info');
            if (typeof testConfig !== 'undefined') {
                const totalFromConfig = Object.values(testConfig).reduce((sum, cat) => sum + cat.count, 0);
                logToConsole(`  testConfig total: ${totalFromConfig}`, 'info');
                logToConsole(`  testConfig categories: ${Object.keys(testConfig).length}`, 'info');
            } else {
                logToConsole('  testConfig not found', 'error');
            }
            
            // Check script tags
            logToConsole('üîç Checking script tags:', 'info');
            const scripts = document.querySelectorAll('script[src]');
            scripts.forEach((script, i) => {
                logToConsole(`  Script ${i + 1}: ${script.src}`, 'info');
            });
            
            // Manual initialization test
            logToConsole('üîç Manual initialization test:', 'info');
            if (typeof initializeTests === 'function') {
                logToConsole('‚úÖ initializeTests function exists', 'success');
                logToConsole('üîÑ Calling initializeTests manually...', 'info');
                
                // Clear and reinitialize
                tests.length = 0;
                initializeTests();
                renderTestTable();
                updateStats();
                
                logToConsole(`üîç After manual call - tests array length: ${tests ? tests.length : 'tests array not found'}`, 'info');
            } else {
                logToConsole('‚ùå initializeTests function not found', 'error');
            }
            
            logToConsole('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            logToConsole('üîç BROWSER DEBUG COMPLETE', 'info');
            logToConsole('üìã Check console output above for detailed analysis', 'warning');
        }

        // Capture JavaScript errors
        window.jsErrors = [];
        window.addEventListener('error', (event) => {
            const errorMsg = `${event.error?.message || event.message} at ${event.filename}:${event.lineno}`;
            window.jsErrors.push(errorMsg);
            logToConsole(`‚ùå JS Error: ${errorMsg}`, 'error');
        });

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initializeTests();
            updateTestScopeDropdown();
            renderTestTable();
            loadSimulatorPersonas();
            logToConsole('Cupido Test Dashboard initialized', 'info');
            logToConsole(`${tests.length} tests loaded across ${Object.keys(testConfig).length} categories`, 'info');
            logToConsole('Test logging enabled - all runs saved to localStorage', 'info');

            // Show previous test count
            const history = testLogger.getHistory();
            if (history.length > 0) {
                logToConsole(`Found ${history.length} previous test run(s) in history`, 'info');
            }

            // Show available console commands
            logToConsole('', 'info');
            logToConsole('=== Available Console Commands ===', 'info');
            logToConsole('showHistory()           - View all previous test runs', 'info');
            logToConsole('exportLogs()            - Download logs as JSON file', 'info');
            logToConsole('clearHistory()          - Clear all stored test logs', 'info');
            logToConsole('autoFixFailures()       - Auto-fix failed tests with Claude', 'info');
            logToConsole('', 'info');

            // Initialize live preview
            initializeLivePreview();

            // Initialize advanced testing features
            initializeAdvancedFeatures();
            logToConsole('Advanced testing features ready: Automation, Templates, Metrics, Scenarios', 'success', 'app');
            
            // Auto-run debug after initial load to help diagnose issues
            setTimeout(() => {
                logToConsole('üîÑ Auto-running debug analysis after page load...', 'warning');
                runBrowserDebug();
            }, 3000);
            
            // Auto-run infrastructure validation tests
            setTimeout(() => {
                logToConsole('üèóÔ∏è  Auto-running infrastructure validation tests...', 'info');
                logToConsole('These tests validate our diagnostic scripts and system health', 'info');
                
                // Run infrastructure tests automatically
                const infrastructureTests = ['infra-1', 'infra-2', 'infra-3', 'infra-4', 'infra-5', 'infra-6'];
                infrastructureTests.forEach((testId, index) => {
                    setTimeout(() => {
                        runSingleTest(testId);
                    }, (index + 1) * 2000); // Stagger tests 2 seconds apart
                });
            }, 5000); // Start after debug analysis completes
        });

        // ============================================================
        // PROMPT LIBRARY FUNCTIONALITY
        // ============================================================

        // State management for Prompt Library
        const promptLibraryState = {
            allPrompts: [],
            filteredPrompts: [],
            selectedPrompt: null,
            selectedVersionHistory: [],
            currentVersionIndex: 0,
            selectedVersionType: 'patch',
            isDirty: false
        };

        // Initialize Prompt Library when tab is clicked
        function initializePromptLibrary() {
            loadPrompts();
            setupPromptLibraryEventListeners();
        }

        // Load all prompts from API
        async function loadPrompts() {
            try {
                const response = await fetch('/api/prompts');
                if (!response.ok) throw new Error('Failed to load prompts');

                const data = await response.json();
                // API returns array directly, not {prompts: []}
                // Map API fields to expected format
                promptLibraryState.allPrompts = (Array.isArray(data) ? data : []).map(p => ({
                    id: p.prompt_id,
                    prompt_id: p.prompt_id,
                    prompt_name: p.prompt_name,
                    version_string: p.active_version || '1.0.0',
                    system_prompt: p.system_prompt,
                    description: p.description,
                    is_visible: p.is_active !== false, // Default to visible if not specified
                    is_active: p.is_active,
                    is_default: p.is_default,
                    tags: p.tags || [],
                    category: p.category,
                    status: p.is_active ? 'active' : 'draft'
                }));
                filterAndRenderPrompts();
            } catch (error) {
                console.error('Error loading prompts:', error);
                document.getElementById('prompt-list').innerHTML =
                    '<div class="prompt-list-loading" style="color: #ff3b30;">Error loading prompts</div>';
            }
        }

        // Filter and render prompts based on search and filters
        function filterAndRenderPrompts() {
            const searchTerm = document.getElementById('prompt-search')?.value.toLowerCase() || '';

            // Get selected tags from checkboxes
            const selectedTags = Array.from(document.querySelectorAll('.tag-checkbox:checked'))
                .map(cb => cb.value);

            // Get selected statuses from checkboxes
            const selectedStatuses = Array.from(document.querySelectorAll('.status-checkbox:checked'))
                .map(cb => cb.value);

            promptLibraryState.filteredPrompts = promptLibraryState.allPrompts.filter(prompt => {
                const matchesSearch = !searchTerm || prompt.prompt_name.toLowerCase().includes(searchTerm);

                // If no tags selected, show all; otherwise, prompt must have at least one selected tag
                const matchesTag = selectedTags.length === 0 ||
                    (prompt.tags && prompt.tags.some(tag => selectedTags.includes(tag)));

                // If no statuses selected, show all; otherwise, prompt must match one of the selected statuses
                const matchesStatus = selectedStatuses.length === 0 ||
                    selectedStatuses.includes(prompt.status);

                return matchesSearch && matchesTag && matchesStatus;
            });

            renderPromptList();
        }

        // Render the prompt list in the sidebar
        function renderPromptList() {
            const listContainer = document.getElementById('prompt-list');

            if (promptLibraryState.filteredPrompts.length === 0) {
                listContainer.innerHTML = '<div class="prompt-list-loading">No prompts found</div>';
                return;
            }

            listContainer.innerHTML = promptLibraryState.filteredPrompts.map(prompt => {
                const isSelected = promptLibraryState.selectedPrompt?.id === prompt.id;
                const tags = prompt.tags || [];

                return `
                    <div class="prompt-item ${isSelected ? 'selected' : ''}" data-prompt-id="${prompt.id}">
                        <div class="prompt-item-header">
                            <div class="prompt-item-name">${prompt.prompt_name}</div>
                            <label class="toggle-switch" onclick="event.stopPropagation()">
                                <input type="checkbox" ${prompt.is_active ? 'checked' : ''}
                                       onchange="togglePromptActive('${prompt.id}', '${prompt.version_string}', this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="prompt-item-footer">
                            ${tags.map(tag => `<span class="prompt-tag ${tag}">${tag}</span>`).join('')}
                            <span class="prompt-version-badge">v${prompt.version_string}</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Add click handlers to prompt items
            document.querySelectorAll('.prompt-item').forEach(item => {
                item.addEventListener('click', () => {
                    const promptId = item.dataset.promptId;
                    selectPrompt(promptId);
                });
            });
        }

        // Toggle prompt activation
        async function togglePromptActive(promptId, versionString, isActive) {
            try {
                console.log(`Toggling ${promptId} v${versionString} to ${isActive ? 'active' : 'inactive'}`);

                const response = await fetch(`/api/prompts/${promptId}/toggle-active`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        versionString: versionString,
                        isActive: isActive
                    })
                });

                if (!response.ok) throw new Error('Failed to update activation');

                const result = await response.json();
                console.log(`‚úÖ ${result.message}`);

                // Update local state
                const prompt = promptLibraryState.allPrompts.find(p => p.id === promptId);
                if (prompt) {
                    prompt.is_active = isActive;
                    prompt.status = isActive ? 'active' : 'draft';
                }

                // If we're viewing this prompt's versions, reload them to see the change
                if (promptLibraryState.selectedPrompt?.prompt_id === promptId) {
                    await selectPrompt(promptId);
                }
            } catch (error) {
                console.error('Error updating activation:', error);
                // Reload prompts to reset the toggle
                await loadPrompts();
            }
        }

        // Select a prompt and display it
        async function selectPrompt(promptId) {
            console.log('Selecting prompt:', promptId);
            const prompt = promptLibraryState.allPrompts.find(p => p.id === promptId);

            if (!prompt) {
                console.error('Prompt not found:', promptId);
                return;
            }

            console.log('Found prompt:', prompt.prompt_name);

            try {
                // Fetch all versions of this prompt
                console.log('Fetching all versions for:', promptId);
                const response = await fetch(`/api/prompts/${promptId}/versions`);
                if (!response.ok) throw new Error('Failed to load versions');

                const versions = await response.json();
                console.log(`Loaded ${versions.length} versions:`, versions.map(v => v.version_string));

                // Map versions to expected format
                const mappedVersions = versions.map(v => ({
                    id: v.id,
                    prompt_id: v.prompt_id,
                    prompt_name: v.prompt_name,
                    version_string: v.version_string,
                    system_prompt: v.system_prompt,
                    description: v.description,
                    is_active: v.is_active,
                    is_visible: v.is_visible,
                    tags: v.tags || [],
                    category: v.category,
                    status: v.status,
                    major_version: v.major_version,
                    minor_version: v.minor_version,
                    patch_version: v.patch_version
                }));

                // Set as selected prompt
                promptLibraryState.selectedPrompt = mappedVersions[0]; // Most recent version first
                promptLibraryState.selectedVersionHistory = mappedVersions;
                promptLibraryState.currentVersionIndex = 0;

                renderPromptEditor();
                renderPromptList(); // Re-render to update selection
            } catch (error) {
                console.error('Error loading versions:', error);
                // Fallback to single version
                promptLibraryState.selectedPrompt = prompt;
                promptLibraryState.selectedVersionHistory = [prompt];
                promptLibraryState.currentVersionIndex = 0;
                renderPromptEditor();
                renderPromptList();
            }
        }

        // Navigate between versions
        function navigateVersion(direction) {
            const history = promptLibraryState.selectedVersionHistory;
            let newIndex = promptLibraryState.currentVersionIndex + direction;

            // Clamp to valid range
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= history.length) newIndex = history.length - 1;

            if (newIndex !== promptLibraryState.currentVersionIndex) {
                promptLibraryState.currentVersionIndex = newIndex;
                promptLibraryState.selectedPrompt = history[newIndex];
                renderPromptEditor();
                console.log(`Navigated to version ${newIndex + 1}/${history.length}: v${history[newIndex].version_string}`);
            }
        }

        // Render the prompt editor panel
        function renderPromptEditor() {
            const editorPanel = document.getElementById('prompt-editor-panel');
            const prompt = promptLibraryState.selectedPrompt;

            if (!prompt) {
                editorPanel.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <h3>No Prompt Selected</h3>
                        <p>Select a prompt from the list or create a new one</p>
                    </div>
                `;
                return;
            }

            const canGoPrev = promptLibraryState.currentVersionIndex > 0;
            const canGoNext = promptLibraryState.currentVersionIndex < promptLibraryState.selectedVersionHistory.length - 1;

            editorPanel.innerHTML = `
                <!-- Header with version navigation -->
                <div class="prompt-editor-header">
                    <div class="prompt-editor-title">Prompt Editor</div>
                    <div class="version-navigator">
                        <button class="version-arrow" onclick="navigateVersion(-1)" ${!canGoPrev ? 'disabled' : ''}>
                            ‚Üê
                        </button>
                        <div class="version-display">v${prompt.version_string}</div>
                        <button class="version-arrow" onclick="navigateVersion(1)" ${!canGoNext ? 'disabled' : ''}>
                            ‚Üí
                        </button>
                        ${promptLibraryState.selectedVersionHistory.length > 1 ?
                            '<button class="btn btn-compare" onclick="openCompareModal()" style="margin-left: 12px; padding: 6px 12px; font-size: 13px;">Compare</button>' : ''}
                    </div>
                </div>

                <!-- Editor content -->
                <div class="prompt-editor-content">
                    <div class="form-group">
                        <label class="form-label">Prompt Name</label>
                        <input type="text" class="form-input" id="prompt-name-input"
                               value="${prompt.prompt_name}" onchange="markDirty()">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" class="form-input" id="prompt-description-input"
                               value="${prompt.description || ''}" onchange="markDirty()">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Tag (Use Case)</label>
                        <select class="form-input" id="prompt-tag-input" onchange="markDirty()">
                            <option value="cupido" ${(prompt.tags && prompt.tags.includes('cupido')) ? 'selected' : ''}>Cupido (Main App)</option>
                            <option value="simulator" ${(prompt.tags && prompt.tags.includes('simulator')) ? 'selected' : ''}>Simulator (Testing)</option>
                            <option value="extractor" ${(prompt.tags && prompt.tags.includes('extractor')) ? 'selected' : ''}>Extractor (Profile)</option>
                            <option value="money2020" ${(prompt.tags && prompt.tags.includes('money2020')) ? 'selected' : ''}>Money2020 (Demo)</option>
                            <option value="custom" ${(prompt.tags && prompt.tags.includes('custom')) ? 'selected' : ''}>Custom</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="prompt-default-input"
                                   ${prompt.is_default ? 'checked' : ''}
                                   onchange="markDirty()"
                                   style="width: auto; height: auto;">
                            <span>Set as default prompt for this tag</span>
                        </label>
                        <div style="font-size: 12px; color: #86868b; margin-top: 4px;">
                            Default prompt will be automatically selected when the app starts
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">System Prompt</label>
                        <textarea class="form-input form-textarea" id="prompt-text-input"
                                  onchange="markDirty()">${prompt.system_prompt}</textarea>
                    </div>
                </div>

                <!-- Actions -->
                <div class="prompt-editor-actions">
                    <div class="action-group">
                        <button class="btn btn-delete" onclick="deletePrompt()">Delete</button>
                    </div>
                    <div class="action-group">
                        <button class="btn btn-save-draft" onclick="saveDraft()">Save Draft</button>
                        <div class="version-selector">
                            <button class="version-type-btn ${promptLibraryState.selectedVersionType === 'patch' ? 'selected' : ''}"
                                    onclick="selectVersionType('patch')">Patch</button>
                            <button class="version-type-btn ${promptLibraryState.selectedVersionType === 'minor' ? 'selected' : ''}"
                                    onclick="selectVersionType('minor')">Minor</button>
                            <button class="version-type-btn ${promptLibraryState.selectedVersionType === 'major' ? 'selected' : ''}"
                                    onclick="selectVersionType('major')">Major</button>
                        </div>
                        <button class="btn btn-update-version" onclick="updateVersion()">Update Version</button>
                    </div>
                </div>
            `;
        }

        // Mark editor as dirty (has unsaved changes)
        function markDirty() {
            promptLibraryState.isDirty = true;
        }

        // Select version type for update
        function selectVersionType(type) {
            promptLibraryState.selectedVersionType = type;
            renderPromptEditor();
        }

        // Save draft without creating new version
        async function saveDraft() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt) return;

            const name = document.getElementById('prompt-name-input').value;
            const description = document.getElementById('prompt-description-input').value;
            const systemPrompt = document.getElementById('prompt-text-input').value;
            const tag = document.getElementById('prompt-tag-input').value;
            const isDefault = document.getElementById('prompt-default-input').checked;

            try {
                console.log('Saving draft for prompt:', prompt.prompt_id);
                const response = await fetch(`/api/prompts/${prompt.prompt_id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        promptName: name,         // Server expects camelCase
                        description: description,
                        systemPrompt: systemPrompt,  // Server expects camelCase
                        tags: [tag],              // Send as array with single tag
                        isDefault: isDefault,
                        commitMessage: 'Draft saved via dashboard'
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error:', response.status, errorText);
                    throw new Error(`Failed to save draft: ${response.status}`);
                }

                const data = await response.json();
                console.log('Draft saved response:', data);
                promptLibraryState.isDirty = false;
                await loadPrompts();
                console.log('‚úÖ Draft saved successfully');
            } catch (error) {
                console.error('Error saving draft:', error);
                alert('Failed to save draft');
            }
        }

        // Update version (create new version)
        async function updateVersion() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt) return;

            const name = document.getElementById('prompt-name-input').value;
            const description = document.getElementById('prompt-description-input').value;
            const systemPrompt = document.getElementById('prompt-text-input').value;
            const tag = document.getElementById('prompt-tag-input').value;
            const isDefault = document.getElementById('prompt-default-input').checked;
            const versionType = promptLibraryState.selectedVersionType;

            try {
                console.log('Creating new version:', versionType, 'for prompt:', prompt.prompt_id);
                const response = await fetch(`/api/prompts/${prompt.prompt_id}/versions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        promptName: name,              // Server expects camelCase
                        systemPrompt: systemPrompt,    // Server expects camelCase
                        versionType: versionType,      // Server expects camelCase
                        tags: [tag],                   // Send as array with single tag
                        isDefault: isDefault,
                        commitMessage: `${versionType} version update via dashboard`,
                        notes: description || '',
                        createdBy: 'dashboard',
                        activate: false
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error response:', response.status, errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText}`);
                }

                const data = await response.json();
                console.log('Server response:', data);
                promptLibraryState.isDirty = false;
                await loadPrompts();
                // Server returns versionId directly, not nested in .version
                if (data.prompt_id || data.versionId) {
                    await selectPrompt(data.prompt_id || data.versionId);
                }
                console.log(`‚úÖ New ${versionType} version created: v${data.version_string}`);
            } catch (error) {
                console.error('Error creating version:', error);
                alert(`Failed to create new version: ${error.message}`);
            }
        }

        // Delete current version
        async function deletePrompt() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt) return;

            // Check if version is active
            if (prompt.is_active) {
                alert(`Cannot delete active version!\n\nPlease deactivate v${prompt.version_string} before deleting it.`);
                return;
            }

            if (!confirm(`Delete version ${prompt.version_string} of "${prompt.prompt_name}"?\n\nThis cannot be undone.`)) {
                return;
            }

            try {
                console.log(`Deleting ${prompt.prompt_id} v${prompt.version_string}`);

                const response = await fetch(`/api/prompts/${prompt.prompt_id}/versions/${prompt.version_string}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to delete version');
                }

                const result = await response.json();
                console.log(`‚úÖ ${result.message}`);

                // Reload prompts and clear selection
                promptLibraryState.selectedPrompt = null;
                promptLibraryState.selectedVersionHistory = [];
                await loadPrompts();
                renderPromptEditor();

            } catch (error) {
                console.error('Error deleting version:', error);
                alert(`Failed to delete version: ${error.message}`);
            }
        }

        // Create new prompt
        async function createNewPrompt() {
            const name = prompt('Enter prompt name:');
            if (!name) return;

            try {
                const response = await fetch('/api/prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt_name: name,
                        system_prompt: 'Enter your system prompt here...',
                        description: ''
                    })
                });

                if (!response.ok) throw new Error('Failed to create prompt');

                const data = await response.json();
                await loadPrompts();
                await selectPrompt(data.prompt.id);
                console.log('New prompt created successfully');
            } catch (error) {
                console.error('Error creating prompt:', error);
                alert('Failed to create new prompt');
            }
        }

        // Setup event listeners for Prompt Library
        function setupPromptLibraryEventListeners() {
            // Search input
            const searchInput = document.getElementById('prompt-search');
            if (searchInput) {
                searchInput.addEventListener('input', filterAndRenderPrompts);
            }

            // Filter button toggle
            const filterBtn = document.getElementById('filter-btn');
            const filterPanel = document.getElementById('filter-panel');
            if (filterBtn && filterPanel) {
                filterBtn.addEventListener('click', () => {
                    const isVisible = filterPanel.style.display !== 'none';
                    filterPanel.style.display = isVisible ? 'none' : 'grid';
                });
            }

            // Filter checkboxes
            const tagCheckboxes = document.querySelectorAll('.tag-checkbox');
            const statusCheckboxes = document.querySelectorAll('.status-checkbox');
            tagCheckboxes.forEach(cb => cb.addEventListener('change', filterAndRenderPrompts));
            statusCheckboxes.forEach(cb => cb.addEventListener('change', filterAndRenderPrompts));

            // New prompt button
            const newPromptBtn = document.getElementById('new-prompt-btn');
            if (newPromptBtn) {
                newPromptBtn.addEventListener('click', createNewPrompt);
            }
        }

        // ============================================================
        // COMPARE VERSIONS MODAL FUNCTIONALITY
        // ============================================================

        // Compare versions state
        let compareState = {
            fromVersion: null,
            toVersion: null,
            versions: []
        };

        // Open compare modal
        function openCompareModal() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt || !promptLibraryState.selectedVersionHistory) {
                alert('Please select a prompt first');
                return;
            }

            const versions = promptLibraryState.selectedVersionHistory;
            if (versions.length < 2) {
                alert('This prompt only has one version. Cannot compare.');
                return;
            }

            compareState.versions = versions;

            // Populate version selectors
            const fromSelect = document.getElementById('compare-from-version');
            const toSelect = document.getElementById('compare-to-version');

            fromSelect.innerHTML = versions.map((v, i) =>
                `<option value="${i}">${v.version_string}${v.is_active ? ' (active)' : ''}</option>`
            ).join('');

            toSelect.innerHTML = versions.map((v, i) =>
                `<option value="${i}">${v.version_string}${v.is_active ? ' (active)' : ''}</option>`
            ).join('');

            // Default: compare current vs previous (or latest vs previous)
            const currentIndex = promptLibraryState.currentVersionIndex || 0;
            const previousIndex = Math.min(currentIndex + 1, versions.length - 1);

            fromSelect.value = previousIndex;
            toSelect.value = currentIndex;

            compareState.fromVersion = versions[previousIndex];
            compareState.toVersion = versions[currentIndex];

            // Show modal
            document.getElementById('compare-modal').style.display = 'flex';

            // Update comparison
            updateComparison();
        }

        // Close compare modal
        function closeCompareModal() {
            document.getElementById('compare-modal').style.display = 'none';
        }

        // Update comparison when selectors change
        function updateComparison() {
            const fromIndex = parseInt(document.getElementById('compare-from-version').value);
            const toIndex = parseInt(document.getElementById('compare-to-version').value);

            compareState.fromVersion = compareState.versions[fromIndex];
            compareState.toVersion = compareState.versions[toIndex];

            renderComparison();
        }

        // Render the comparison with diff highlighting
        function renderComparison() {
            const from = compareState.fromVersion;
            const to = compareState.toVersion;

            // Update headers
            document.getElementById('compare-from-header').textContent =
                `v${from.version_string}${from.is_active ? ' (active)' : ''}`;
            document.getElementById('compare-to-header').textContent =
                `v${to.version_string}${to.is_active ? ' (active)' : ''}`;

            // Simple line-by-line diff
            const fromLines = (from.system_prompt || '').split('\n');
            const toLines = (to.system_prompt || '').split('\n');

            const fromHtml = generateDiffHtml(fromLines, toLines, 'from');
            const toHtml = generateDiffHtml(fromLines, toLines, 'to');

            document.getElementById('compare-from-content').innerHTML = fromHtml;
            document.getElementById('compare-to-content').innerHTML = toHtml;
        }

        // Generate diff HTML (simple line-based diff)
        function generateDiffHtml(fromLines, toLines, side) {
            const lines = side === 'from' ? fromLines : toLines;
            const otherLines = side === 'from' ? toLines : fromLines;

            let html = '';

            lines.forEach((line, i) => {
                let className = 'diff-unchanged';

                if (i >= otherLines.length) {
                    // Line was added/removed
                    className = side === 'from' ? 'diff-removed' : 'diff-added';
                } else if (line !== otherLines[i]) {
                    // Line was changed
                    if (side === 'from' && !toLines.includes(line)) {
                        className = 'diff-removed';
                    } else if (side === 'to' && !fromLines.includes(line)) {
                        className = 'diff-added';
                    } else {
                        className = 'diff-changed';
                    }
                }

                html += `<span class="diff-line ${className}">${escapeHtml(line)}\n</span>`;
            });

            return html;
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add prompt library initialization to the existing switchTab override
        // This should be combined with the error monitoring switchTab override above
    </script>
</body>
</html>
