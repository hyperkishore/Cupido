<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cupido Test Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            line-height: 1.5;
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 1px solid #d2d2d7;
            padding: 16px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Tabs */
        .tabs {
            background: white;
            border-bottom: 1px solid #d2d2d7;
            padding: 0 32px;
            display: flex;
            gap: 32px;
        }

        .tab {
            padding: 12px 0;
            cursor: pointer;
            color: #6e6e73;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #1d1d1f;
        }

        .tab.active {
            color: #0071e3;
            border-bottom-color: #0071e3;
        }

        /* Main Content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px 32px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Controls Bar */
        .controls-bar {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls-left {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .controls-right {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #0071e3;
            color: white;
        }

        .btn-primary:hover {
            background: #0077ed;
        }

        .btn-secondary {
            background: white;
            color: #1d1d1f;
            border: 1px solid #d2d2d7;
        }

        .btn-secondary:hover {
            background: #f5f5f7;
        }

        .btn-danger {
            background: #ff3b30;
            color: white;
        }

        .btn-danger:hover {
            background: #ff4d42;
        }

        /* Select Dropdown */
        select {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle {
            position: relative;
            width: 44px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e5e5ea;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle input:checked + .toggle-slider {
            background-color: #0071e3;
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .toggle-label {
            font-size: 14px;
            color: #6e6e73;
        }

        /* Stats Summary */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            padding: 16px;
        }

        .stat-label {
            font-size: 13px;
            color: #6e6e73;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 600;
            color: #1d1d1f;
        }

        /* Test Table */
        .table-container {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow-x: auto;
            overflow-y: visible;
        }

        table {
            width: max-content;
            min-width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 12px 16px;
            text-align: left;
            font-size: 13px;
            font-weight: 600;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid #f5f5f7;
            font-size: 14px;
        }

        /* Column-specific widths */
        th:nth-child(1), td:nth-child(1) { width: 40px; } /* Checkbox */
        th:nth-child(2), td:nth-child(2) { min-width: 180px; white-space: nowrap; } /* Test Name */
        th:nth-child(3), td:nth-child(3) { min-width: 300px; max-width: 400px; } /* Description - wraps */
        th:nth-child(4), td:nth-child(4) { min-width: 150px; white-space: nowrap; } /* Module */
        th:nth-child(5), td:nth-child(5) { min-width: 180px; white-space: nowrap; } /* Category */
        th:nth-child(6), td:nth-child(6) { min-width: 100px; white-space: nowrap; } /* Status */
        th:nth-child(7), td:nth-child(7) { min-width: 100px; white-space: nowrap; } /* Last Run */
        th:nth-child(8), td:nth-child(8) { min-width: 90px; white-space: nowrap; } /* Duration */
        th:nth-child(9), td:nth-child(9) { width: 100px; white-space: nowrap; } /* Action */

        /* Description column wrapping */
        td:nth-child(3) {
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.4;
            max-height: 4.2em; /* ~3 lines */
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        tbody tr:hover {
            background: #fafafa;
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        /* Status Badge */
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-pending {
            background: #f5f5f7;
            color: #6e6e73;
            animation: pulse-pending 2s ease-in-out infinite;
        }

        .status-running {
            background: #e3f2fd;
            color: #0071e3;
            animation: pulse-running 1.5s ease-in-out infinite;
        }

        @keyframes pulse-pending {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        @keyframes pulse-running {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .status-pass {
            background: #e8f5e9;
            color: #34c759;
        }

        .status-fail {
            background: #ffebee;
            color: #ff3b30;
        }

        .status-running {
            background: #e3f2fd;
            color: #0071e3;
            animation: pulse-running 1.5s ease-in-out infinite;
        }

        /* Category Badge */
        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            background: #f5f5f7;
            color: #6e6e73;
        }

        /* Action Button in Table */
        .action-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: white;
            color: #1d1d1f;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #f5f5f7;
        }

        /* Console Output */
        .console {
            background: #1d1d1f;
            color: #f5f5f7;
            border-radius: 8px;
            padding: 16px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 24px;
        }

        .console-line {
            margin-bottom: 4px;
            display: flex;
            gap: 8px;
        }

        .console-timestamp {
            color: #6e6e73;
        }

        .console-info {
            color: #0071e3;
        }

        .console-success {
            color: #34c759;
        }

        .console-error {
            color: #ff3b30;
        }

        .console-warning {
            color: #ff9500;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 64px 32px;
            color: #6e6e73;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        /* Live Preview 2-Column Layout */
        .live-preview-container {
            display: grid;
            grid-template-columns: 550px 1fr;
            gap: 24px;
            height: calc(100vh - 200px);
        }

        /* iPhone Preview Column */
        .live-preview-iphone {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Simulator Controls Column */
        .live-preview-simulator {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            max-width: 500px;
        }

        /* Scaled iPhone Frame (65% for complete visibility with content) */
        .iphone-frame {
            width: 256px;
            height: 554px;
            background: #1d1d1f;
            border-radius: 35px;
            padding: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            margin: 20px auto;
        }

        .iphone-notch {
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 14px;
            background: #1d1d1f;
            border-radius: 0 0 10px 10px;
            z-index: 10;
        }

        .iphone-screen {
            width: 100%;
            height: 100%;
            border-radius: 26px;
            overflow: hidden;
            background: white;
            position: relative;
        }

        .live-preview-iframe {
            width: 393px;
            height: 852px;
            border: none;
            transform: scale(0.61);
            transform-origin: top left;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Panel Headers */
        .live-preview-header {
            padding: 12px 16px;
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .console-view.collapsed .live-preview-header {
            cursor: pointer;
        }

        .live-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Console Content */
        .live-preview-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f7;
        }

        .live-console {
            background: #1d1d1f;
            color: #f5f5f7;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            overflow-y: auto;
            padding: 12px;
            flex: 1;
            height: 100%;
        }

        .live-console-line {
            margin-bottom: 4px;
            display: flex;
            gap: 8px;
            line-height: 1.4;
        }

        /* Simulator Controls */
        .simulator-header {
            padding: 12px 16px;
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .simulator-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .sim-control-group {
            margin-bottom: 16px;
        }

        .sim-control-group:last-child {
            margin-bottom: 0;
        }

        .sim-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: #6e6e73;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sim-select,
        .sim-input,
        .sim-textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            color: #1d1d1f;
            background: white;
            font-family: inherit;
        }

        .sim-select:focus,
        .sim-input:focus,
        .sim-textarea:focus {
            outline: none;
            border-color: #0071e3;
        }

        .sim-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .sim-checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
        }

        .sim-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .sim-checkbox-label {
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
        }

        .sim-button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sim-btn {
            width: 100%;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .sim-btn-primary {
            background: #007AFF;
            color: white;
        }

        .sim-btn-primary:hover {
            background: #0051D5;
        }

        .sim-btn-secondary {
            background: #f2f2f7;
            color: #007AFF;
            border: 1px solid #e5e5e7;
        }

        .sim-btn-secondary:hover {
            background: #e5e5ea;
        }

        /* Toggle Button Styles */
        .toggle-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: white;
            color: #1d1d1f;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .toggle-btn:hover {
            background: #f5f5f7;
        }

        .toggle-btn svg {
            width: 14px;
            height: 14px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* Claude Code Status Indicator */
        .claude-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 6px;
            background: white;
            border: 1px solid #d2d2d7;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6e6e73;
            animation: pulse 2s infinite;
        }

        .status-dot.idle {
            background: #6e6e73;
            animation: none;
        }

        .status-dot.analyzing {
            background: #0071e3;
        }

        .status-dot.fixing {
            background: #ff9500;
        }

        .status-dot.testing {
            background: #34c759;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 13px;
            color: #1d1d1f;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #d2d2d7;
            border-top-color: #0071e3;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* New Simulator Styles */
        .simulator-content {
            padding: 20px;
            overflow-y: auto;
        }

        .simulator-group {
            margin-bottom: 20px;
        }

        .simulator-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .simulator-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            color: #1d1d1f;
            background: white;
            font-family: inherit;
            resize: vertical;
        }

        .simulator-input:focus {
            outline: none;
            border-color: #0071e3;
        }

        .simulator-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .simulator-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .simulator-checkbox span {
            font-size: 14px;
            color: #1d1d1f;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .preset-btn {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            background: white;
            font-size: 13px;
            color: #1d1d1f;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #f5f5f7;
            border-color: #0071e3;
        }

        .simulator-send-btn {
            width: 100%;
            padding: 12px;
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .simulator-send-btn:hover {
            background: #0077ed;
        }

        /* Range slider styles */
        .simulator-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #d2d2d7;
            outline: none;
            -webkit-appearance: none;
        }

        .simulator-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0071e3;
            cursor: pointer;
        }

        .simulator-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0071e3;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-value-display {
            font-size: 13px;
            font-weight: 600;
            color: #0071e3;
        }

        .simulator-number {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            font-size: 14px;
            color: #1d1d1f;
            background: white;
        }

        .simulator-number:focus {
            outline: none;
            border-color: #0071e3;
        }

        .persona-info {
            margin-top: 8px;
            padding: 12px;
            background: #f5f5f7;
            border-radius: 8px;
            font-size: 12px;
            color: #6e6e73;
        }

        /* Console Tab Styles */
        .console-header {
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .console-controls {
            display: flex;
            gap: 24px;
            align-items: center;
            flex-wrap: wrap;
        }

        .console-filters {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .console-filter-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 13px;
        }

        .console-filter-item input[type="checkbox"] {
            margin: 0;
        }

        .console-filter-label {
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .console-filter-label.info {
            color: #007AFF;
            background: rgba(0, 122, 255, 0.1);
        }

        .console-filter-label.warning {
            color: #FF9500;
            background: rgba(255, 149, 0, 0.1);
        }

        .console-filter-label.error {
            color: #FF3B30;
            background: rgba(255, 59, 48, 0.1);
        }

        .console-filter-label.success {
            color: #34C759;
            background: rgba(52, 199, 89, 0.1);
        }

        .console-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .console-actions .btn {
            font-size: 12px;
            padding: 6px 10px;
        }

        .unified-console {
            height: calc(100vh - 280px);
            background: #1d1d1f;
            color: #f5f5f7;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            overflow-y: auto;
            padding: 16px;
        }

        /* Prompt Library Styles */
        .prompt-library-container {
            display: flex;
            height: calc(100vh - 200px);
            background: #ffffff;
            gap: 1px;
            overflow: hidden;
        }

        .prompt-sidebar {
            width: 380px;
            background: #f5f5f7;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #d2d2d7;
        }

        .prompt-toolbar {
            padding: 12px 16px;
            background: #ffffff;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .toolbar-search {
            flex: 1;
        }

        .filter-panel {
            padding: 16px;
            background: #ffffff;
            border-bottom: 1px solid #d2d2d7;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-label {
            font-size: 12px;
            font-weight: 600;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #1d1d1f;
            cursor: pointer;
            padding: 4px 0;
        }

        .filter-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .filter-checkbox:hover {
            color: #0071e3;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            background: #f5f5f7 url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M7 12C9.76142 12 12 9.76142 12 7C12 4.23858 9.76142 2 7 2C4.23858 2 2 4.23858 2 7C2 9.76142 4.23858 12 7 12Z" stroke="%236e6e73" stroke-width="1.5"/><path d="M11 11L14 14" stroke="%236e6e73" stroke-width="1.5" stroke-linecap="round"/></svg>') no-repeat 10px center;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #0071e3;
            background-color: #ffffff;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 13px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-select:hover {
            border-color: #86868b;
        }

        .filter-select:focus {
            outline: none;
            border-color: #0071e3;
        }

        .prompt-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .prompt-list-loading {
            padding: 40px 20px;
            text-align: center;
            color: #86868b;
            font-size: 14px;
        }

        .prompt-item {
            background: #ffffff;
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .prompt-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .prompt-item.selected {
            border-color: #0071e3;
            background: #f0f7ff;
        }

        .prompt-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .prompt-item-name {
            font-weight: 600;
            font-size: 15px;
            color: #1d1d1f;
            flex: 1;
        }

        .prompt-item-footer {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .prompt-tag {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .prompt-tag.cupido {
            background: #e3f2fd;
            color: #1976d2;
        }

        .prompt-tag.simulator {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .prompt-tag.extractor {
            background: #e8f5e9;
            color: #388e3c;
        }

        .prompt-tag.money2020 {
            background: #fff3e0;
            color: #f57c00;
        }

        .prompt-version-badge {
            font-size: 11px;
            color: #86868b;
            font-weight: 500;
        }

        /* Apple-style Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #d2d2d7;
            transition: .3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #34c759;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        /* Right Panel: Prompt Editor */
        .prompt-editor-panel {
            flex: 1;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #86868b;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .empty-state h3 {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 15px;
            color: #86868b;
        }

        .prompt-editor-header {
            padding: 16px 24px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fafafa;
        }

        .prompt-editor-title {
            font-size: 14px;
            font-weight: 600;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .version-navigator {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .version-display {
            font-size: 15px;
            font-weight: 600;
            color: #1d1d1f;
            padding: 4px 12px;
            background: #f5f5f7;
            border-radius: 6px;
        }

        .version-arrow {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .version-navigator:hover .version-arrow {
            opacity: 1;
        }

        .version-arrow:hover {
            background: #f5f5f7;
            border-color: #86868b;
        }

        .version-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .version-arrow:disabled:hover {
            background: #ffffff;
            border-color: #d2d2d7;
        }

        .prompt-editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #0071e3;
            box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.1);
        }

        .form-textarea {
            min-height: 300px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            resize: vertical;
        }

        .prompt-editor-actions {
            padding: 16px 24px;
            border-top: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fafafa;
        }

        .action-group {
            display: flex;
            gap: 12px;
        }

        .btn-delete {
            background: transparent;
            color: #ff3b30;
            border: 1px solid #ff3b30;
        }

        .btn-delete:hover {
            background: #ff3b30;
            color: white;
        }

        .version-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .version-type-btn {
            padding: 8px 16px;
            border: 1px solid #d2d2d7;
            background: #ffffff;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .version-type-btn:hover {
            border-color: #0071e3;
            background: #f0f7ff;
        }

        .version-type-btn.selected {
            background: #0071e3;
            color: white;
            border-color: #0071e3;
        }

        .btn-save-draft {
            background: #f5f5f7;
            color: #1d1d1f;
            border: 1px solid #d2d2d7;
        }

        .btn-save-draft:hover {
            background: #e8e8ed;
        }

        .btn-update-version {
            background: #0071e3;
            color: white;
        }

        .btn-update-version:hover {
            background: #0077ed;
        }

        /* Compare Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            z-index: 10001;
        }

        .compare-modal-content {
            width: 1400px;
            height: 85vh;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 32px;
            color: #86868b;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background-color: #f5f5f7;
        }

        /* Compare selectors */
        .compare-selectors {
            padding: 20px 24px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            gap: 20px;
        }

        .compare-selector-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .compare-selector-group label {
            font-size: 13px;
            font-weight: 500;
            color: #1d1d1f;
        }

        .compare-selector-group select {
            padding: 8px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: white;
            cursor: pointer;
        }

        /* Compare container */
        .compare-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #d2d2d7;
            overflow: hidden;
        }

        .compare-panel {
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .compare-panel-header {
            padding: 12px 16px;
            background: #f5f5f7;
            border-bottom: 1px solid #d2d2d7;
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .compare-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Diff highlighting */
        .diff-line {
            display: block;
            margin: 0;
            padding: 2px 0;
        }

        .diff-added {
            background-color: #d1f4d1;
            color: #0d6932;
        }

        .diff-removed {
            background-color: #ffd8d8;
            color: #d60000;
            text-decoration: line-through;
        }

        .diff-unchanged {
            color: #1d1d1f;
        }

        .diff-changed {
            background-color: #fff4cc;
            color: #8b6914;
        }

        .btn-compare {
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-compare:hover {
            background: #0077ed;
        }

        /* Error Monitoring Styles */
        .error-monitoring-container {
            padding: 24px;
        }

        .error-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }

        .error-stat-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .error-stat-card h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #6e6e73;
            font-weight: 500;
        }

        .error-count {
            font-size: 32px;
            font-weight: 700;
            color: #ff3b30;
            margin: 8px 0;
        }

        .error-count.success {
            color: #34c759;
        }

        .error-count.critical {
            color: #ff3b30;
            animation: pulse 2s infinite;
        }

        .error-label {
            font-size: 12px;
            color: #8e8e93;
        }

        .error-patterns-section,
        .recent-errors-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .error-patterns-section h3,
        .recent-errors-section h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            color: #1d1d1f;
        }

        .error-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f2f2f7;
        }

        .error-item:last-child {
            border-bottom: none;
        }

        .error-message {
            flex: 1;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            color: #1d1d1f;
        }

        .error-count-badge {
            background: #ff3b30;
            color: white;
            border-radius: 12px;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .error-timestamp {
            font-size: 11px;
            color: #8e8e93;
            margin-left: 12px;
        }

        .auto-fix-badge {
            background: #34c759;
            color: white;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            margin-left: 8px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        /* Health Check Tab Styles - Apple Design System */
        .health-check-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
        }

        .health-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 0 20px;
        }

        .health-header h2 {
            font-size: 32px;
            font-weight: 700;
            color: #1d1d1f;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .health-header p {
            font-size: 17px;
            color: #86868b;
            margin-bottom: 24px;
            line-height: 1.4;
        }

        .health-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 48px;
        }

        .health-stat-card {
            background: #ffffff;
            border: 1px solid #e5e5e7;
            border-radius: 18px;
            padding: 24px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            transition: all 0.3s ease;
        }

        .health-stat-card:hover {
            border-color: #007AFF;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.1);
        }

        .health-stat-label {
            font-size: 15px;
            color: #86868b;
            font-weight: 500;
            margin-bottom: 12px;
            letter-spacing: -0.24px;
        }

        .health-stat-value {
            font-size: 36px;
            font-weight: 700;
            color: #1d1d1f;
            letter-spacing: -1px;
        }

        .health-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
            gap: 24px;
            margin-bottom: 48px;
        }

        .health-category {
            background: #ffffff;
            border: 1px solid #e5e5e7;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            transition: all 0.3s ease;
        }

        .health-category:hover {
            border-color: #d1d1d6;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .health-category-header {
            background: #f5f5f7;
            padding: 20px 24px;
            border-bottom: 1px solid #e5e5e7;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .health-category-header h3 {
            font-size: 17px;
            font-weight: 600;
            color: #1d1d1f;
            margin: 0;
            letter-spacing: -0.43px;
        }

        .health-category-count {
            font-size: 15px;
            color: #86868b;
            font-weight: 500;
            background: #e5e5e7;
            padding: 4px 12px;
            border-radius: 12px;
        }

        .health-items {
            padding: 16px 20px;
        }

        .health-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f5f5f7;
        }

        .health-item:last-child {
            border-bottom: none;
        }

        .health-item-info {
            flex: 1;
        }

        .health-item-name {
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1f;
            margin-bottom: 4px;
        }

        .health-item-description {
            font-size: 12px;
            color: #6e6e73;
            line-height: 1.4;
        }

        .health-item-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .health-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .health-status-indicator.running {
            background: #34c759;
        }

        .health-status-indicator.stopped {
            background: #8e8e93;
        }

        .health-status-indicator.error {
            background: #ff3b30;
        }

        .health-status-indicator.warning {
            background: #ff9500;
        }

        .health-status-text {
            font-size: 12px;
            font-weight: 500;
            color: #6e6e73;
        }

        .health-action-btn {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            background: white;
            color: #0071e3;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .health-action-btn:hover {
            background: #f5f5f7;
        }

        .health-logs {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            overflow: hidden;
        }

        .health-logs-header {
            background: #f5f5f7;
            padding: 16px 20px;
            border-bottom: 1px solid #d2d2d7;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .health-logs-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: #1d1d1f;
            margin: 0;
        }

        .health-logs-content {
            max-height: 300px;
            overflow-y: auto;
            padding: 16px 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            background: #fafafa;
        }

        .health-log-entry {
            margin-bottom: 8px;
            display: flex;
            gap: 12px;
        }

        .health-log-timestamp {
            color: #6e6e73;
            flex-shrink: 0;
        }

        .health-log-message {
            color: #1d1d1f;
            flex: 1;
        }

        .health-log-level-info {
            color: #0071e3;
        }

        .health-log-level-success {
            color: #34c759;
        }

        .health-log-level-warning {
            color: #ff9500;
        }

        .health-log-level-error {
            color: #ff3b30;
        }

        /* Apple-style refresh button */
        .health-refresh-btn {
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .health-refresh-btn:hover {
            background: #0051D5;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.4);
        }

        .health-refresh-btn:active {
            transform: translateY(0);
            background: #004494;
        }

        /* Apple-style action buttons */
        .health-action-btn {
            background: #f2f2f7;
            color: #007AFF;
            border: none;
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .health-action-btn:hover {
            background: #e5e5ea;
            color: #0051D5;
        }

        /* Health Table Styles */
        .health-actions {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .health-run-btn, .health-refresh-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;
        }

        .health-run-btn {
            background: #007AFF;
            color: white;
        }

        .health-run-btn:hover {
            background: #0051D5;
        }

        .health-refresh-btn {
            background: #F2F2F7;
            color: #007AFF;
        }

        .health-refresh-btn:hover {
            background: #E5E5EA;
        }

        .health-table-container {
            margin: 24px 0;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #E5E5EA;
            background: white;
        }

        .health-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;
        }

        .health-table thead th {
            background: #F2F2F7;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            color: #1D1D1F;
            border-bottom: 1px solid #E5E5EA;
        }

        .health-table tbody td {
            padding: 12px 16px;
            border-bottom: 1px solid #F2F2F7;
            vertical-align: middle;
        }

        .health-table tbody tr:hover {
            background: #F9F9FB;
        }

        .health-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
        }

        .health-status.passed {
            background: #E8F5E8;
            color: #34C759;
        }

        .health-status.failed {
            background: #FFEBE8;
            color: #FF3B30;
        }

        .health-status.pending {
            background: #F0F0F7;
            color: #8E8E93;
            animation: pulse-pending 2s ease-in-out infinite;
        }

        .health-status.running {
            background: #e3f2fd;
            color: #0071e3;
            animation: pulse-running 1.5s ease-in-out infinite;
        }

        .health-summary {
            display: flex;
            gap: 24px;
            justify-content: center;
            padding: 20px;
            background: #F9F9FB;
            border-radius: 12px;
            margin-top: 24px;
        }

        .health-stat {
            text-align: center;
        }

        .health-stat .stat-value {
            display: block;
            font-size: 24px;
            font-weight: 600;
            color: #1D1D1F;
            margin-bottom: 4px;
        }

        .health-stat .stat-label {
            font-size: 12px;
            color: #8E8E93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .test-action-btn {
            background: none;
            border: 1px solid #E5E5EA;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 12px;
            color: #007AFF;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .test-action-btn:hover {
            background: #F2F2F7;
            border-color: #007AFF;
        }

    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-title">Cupido Test Dashboard</div>
        <div class="header-actions">
            <!-- Buttons moved to controls bar for better UX -->
        </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
        <div class="tab active" onclick="switchTab('health', event)">Scripts</div>
        <div class="tab" onclick="switchTab('tests', event)">Tests</div>
        <div class="tab" onclick="switchTab('live', event)">Live Preview</div>
        <div class="tab" onclick="switchTab('console', event)">Console</div>
        <div class="tab" onclick="switchTab('history', event)">History</div>
        <div class="tab" onclick="switchTab('error-monitoring', event)">Error Monitor</div>
        <div class="tab" onclick="switchTab('prompts', event)">Prompt Library</div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Tests Tab -->
        <div class="tab-content" id="tests-tab">
            <!-- Controls Bar -->
            <div class="controls-bar">
                <div class="controls-left">
                    <select id="test-scope" onchange="filterTestsByCategory()">
                        <option value="all" id="all-tests-option">All Tests (81)</option>
                        <option value="foundation">Foundation Tests (5)</option>
                        <option value="prompts">Prompt Management (3)</option>
                        <option value="console">Console Error Detection (5)</option>
                        <option value="phase2">Phase 2: Revolutionary Analytics (8)</option>
                        <option value="phase3">Phase 3: Advanced Automation (7)</option>
                        <option value="message">Message Flow & UI (8)</option>
                        <option value="profile">Profile Extraction (6)</option>
                        <option value="database">Database Operations (5)</option>
                        <option value="error">Error Handling (6)</option>
                        <option value="state">State Management (6)</option>
                        <option value="api">API & Performance (4)</option>
                        <option value="simulator">Simulator Testing (18)</option>
                        <option value="infra">Infrastructure Validation (6)</option>
                    </select>
                    <button class="btn btn-primary" onclick="runSelectedTests()">Run Tests</button>
                </div>
                <div class="controls-right">
                    <div class="toggle-container">
                        <label class="toggle-label">Store Logs</label>
                        <label class="toggle">
                            <input type="checkbox" id="store-logs">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Stats Summary -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Total Tests</div>
                    <div class="stat-value" id="total-tests">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Passed</div>
                    <div class="stat-value" style="color: #34c759;" id="passed-tests">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value" style="color: #ff3b30;" id="failed-tests">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Pending</div>
                    <div class="stat-value" style="color: #6e6e73;" id="pending-tests">40</div>
                </div>
            </div>

            <!-- Test Table -->
            <div class="table-container">
                <table id="test-table">
                    <thead>
                        <tr>
                            <th style="width: 40px;"><input type="checkbox" id="select-all" onchange="toggleAllTests()"></th>
                            <th>Test Name</th>
                            <th>Description</th>
                            <th>Module</th>
                            <th>Category</th>
                            <th>Status</th>
                            <th>Last Run</th>
                            <th>Duration</th>
                            <th style="width: 100px;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="test-table-body">
                        <!-- Tests will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Live Preview Tab -->
        <div class="tab-content" id="live-tab">
            <div class="live-preview-container">
                <!-- iPhone Preview -->
                <div class="live-preview-iphone">
                    <div class="live-preview-header">
                        <div class="live-preview-title">Live App Preview</div>
                        <button class="btn btn-secondary" style="padding: 4px 12px; font-size: 12px;" onclick="exportChat()">Export Chat</button>
                    </div>
                    <div class="live-preview-content">
                        <div class="iphone-frame">
                            <div class="iphone-notch"></div>
                            <div class="iphone-screen">
                                <iframe
                                    id="live-app-iframe"
                                    class="live-preview-iframe"
                                    src="/app">
                                </iframe>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Simulator Controls -->
                <div class="live-preview-simulator">
                    <div class="live-preview-header">
                        <div class="live-preview-title">Simulator Controls</div>
                    </div>
                    <div class="simulator-content">
                        <!-- Persona Selection -->
                        <div class="simulator-group">
                            <label class="simulator-label">Simulator Persona</label>
                            <select id="simulator-persona" class="simulator-input" onchange="updatePersonaInfo()">
                                <option value="">Loading personas...</option>
                            </select>
                            <div id="persona-info" class="persona-info" style="display: none;"></div>
                        </div>
                        
                        <!-- Simulator Control Buttons -->
                        <div class="simulator-group">
                            <label class="simulator-label">Controls</label>
                            <div class="preset-grid">
                                <button id="sim-start-btn" class="preset-btn" onclick="startSimulator()" style="background: #34c759; color: white;"> Start</button>
                                <button id="sim-pause-btn" class="preset-btn" onclick="pauseSimulator()" disabled> Pause</button>
                                <button id="sim-stop-btn" class="preset-btn" onclick="stopSimulator()" disabled style="background: #ff3b30; color: white;"> Stop</button>
                            </div>
                        </div>
                        
                        <!-- Speed Control -->
                        <div class="simulator-group">
                            <div class="slider-value">
                                <label class="simulator-label" style="margin: 0;">Response Speed</label>
                                <span class="slider-value-display" id="speed-value">1x</span>
                            </div>
                            <input type="range" id="speed-slider" class="simulator-slider" min="0.5" max="3" step="0.5" value="1" oninput="updateSimulatorSpeed(this.value); document.getElementById('speed-value').textContent = this.value + 'x'">
                        </div>

                        <!-- Testing Variations -->
                        <div class="simulator-group">
                            <div class="slider-value">
                                <label class="simulator-label" style="margin: 0;">Rudeness Level</label>
                                <span class="slider-value-display" id="rudeness-value">50</span>
                            </div>
                            <input type="range" id="rudeness-slider" class="simulator-slider" min="0" max="100" value="50" oninput="updateRudenessValue(this.value)">
                        </div>

                        <div class="simulator-group">
                            <label class="simulator-label">Max Messages</label>
                            <input type="number" id="max-messages" class="simulator-number" min="1" max="100" value="10">
                        </div>

                        <div class="simulator-group">
                            <label class="simulator-label">Response Style</label>
                            <select id="response-style" class="simulator-input">
                                <option value="balanced">Balanced</option>
                                <option value="friendly">Friendly & Warm</option>
                                <option value="flirty">Flirty & Playful</option>
                                <option value="casual">Casual & Relaxed</option>
                                <option value="deep">Deep & Thoughtful</option>
                                <option value="humorous">Humorous & Witty</option>
                            </select>
                        </div>

                        <!-- Message Input -->
                        <div class="simulator-group">
                            <label class="simulator-label">Message</label>
                            <textarea id="sim-message" class="simulator-input" placeholder="Type your message..." rows="4"></textarea>
                        </div>

                        <!-- Include Contextual Image -->
                        <div class="simulator-group">
                            <label class="simulator-checkbox">
                                <input type="checkbox" id="include-image">
                                <span>Include contextual image (based on message)</span>
                            </label>
                        </div>

                        <!-- Quick Presets -->
                        <div class="simulator-group">
                            <label class="simulator-label">Quick Presets</label>
                            <div class="preset-grid">
                                <button class="preset-btn" onclick="loadPreset('intro')"> Intro</button>
                                <button class="preset-btn" onclick="loadPreset('question')"> Question</button>
                                <button class="preset-btn" onclick="loadPreset('casual')"> Casual</button>
                                <button class="preset-btn" onclick="loadPreset('deep')"> Deep</button>
                            </div>
                        </div>

                        <!-- Send Button -->
                        <button class="simulator-send-btn" onclick="sendSimulatorMessage()">
                            <span>Send Message</span>
                        </button>

                        <!-- Automation Controls -->
                        <div class="simulator-group" style="border-top: 1px solid #d2d2d7; padding-top: 20px; margin-top: 20px;">
                            <label class="simulator-label"> Automation</label>

                            <div style="margin-bottom: 12px;">
                                <div class="slider-value">
                                    <label class="simulator-label" style="margin: 0; font-size: 12px; font-weight: 500;">Message Delay (seconds)</label>
                                    <span class="slider-value-display" id="delay-value">2</span>
                                </div>
                                <input type="range" id="message-delay" class="simulator-slider" min="1" max="10" value="2" oninput="updateDelayValue(this.value)">
                            </div>

                            <div class="preset-grid">
                                <button class="preset-btn" onclick="startAutoConversation(5)"> Auto 5x</button>
                                <button class="preset-btn" onclick="startAutoConversation(10)"> Auto 10x</button>
                                <button class="preset-btn" onclick="stopAutoConversation()" style="background: #ff3b30; color: white;"> Stop</button>
                            </div>
                        </div>

                        <!-- Conversation Templates -->
                        <div class="simulator-group">
                            <label class="simulator-label"> Conversation Templates</label>
                            <div class="preset-grid">
                                <button class="preset-btn" onclick="loadTemplate('first-date')"> First Date</button>
                                <button class="preset-btn" onclick="loadTemplate('deep-talk')"> Deep Talk</button>
                                <button class="preset-btn" onclick="loadTemplate('flirty')"> Flirty</button>
                                <button class="preset-btn" onclick="loadTemplate('getting-to-know')"> Getting to Know</button>
                            </div>
                        </div>

                        <!-- Live Metrics -->
                        <div class="simulator-group" style="background: #f5f5f7; padding: 12px; border-radius: 8px;">
                            <label class="simulator-label"> Live Metrics</label>
                            <div id="live-metrics" style="font-size: 12px; color: #1d1d1f;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span>Response Time:</span>
                                    <span id="metric-response-time">--</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span>Messages Sent:</span>
                                    <span id="metric-messages">0</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span>Engagement Score:</span>
                                    <span id="metric-engagement">--</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>Detected Mood:</span>
                                    <span id="metric-mood">--</span>
                                </div>
                            </div>
                        </div>

                        <!-- Save/Load Scenario -->
                        <div class="simulator-group">
                            <label class="simulator-label"> Test Scenarios</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                                <input type="text" id="scenario-name" class="simulator-input" style="flex: 1;" placeholder="Scenario name...">
                                <button class="preset-btn" onclick="saveScenario()" style="width: auto; padding: 8px 16px;">Save</button>
                            </div>
                            <select id="saved-scenarios" class="simulator-input" onchange="loadScenario(this.value)">
                                <option value="">Load scenario...</option>
                            </select>
                        </div>

                        <!-- Export Results -->
                        <button class="simulator-send-btn" onclick="exportTestResults()" style="background: #34c759;">
                            <span> Export Test Results</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Console Tab -->
        <div class="tab-content" id="console-tab">
            <div class="console-header">
                <h3 style="margin: 0; font-size: 17px; font-weight: 600; color: #1d1d1f;">Console Output</h3>
                <div class="console-controls">
                    <!-- Log Level Filters -->
                    <div class="console-filters">
                        <label class="console-filter-item">
                            <input type="checkbox" id="filter-info" checked onchange="filterLogLevels()">
                            <span class="console-filter-label info">Info</span>
                        </label>
                        <label class="console-filter-item">
                            <input type="checkbox" id="filter-warning" checked onchange="filterLogLevels()">
                            <span class="console-filter-label warning">Warning</span>
                        </label>
                        <label class="console-filter-item">
                            <input type="checkbox" id="filter-error" checked onchange="filterLogLevels()">
                            <span class="console-filter-label error">Error</span>
                        </label>
                        <label class="console-filter-item">
                            <input type="checkbox" id="filter-success" checked onchange="filterLogLevels()">
                            <span class="console-filter-label success">Success</span>
                        </label>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="console-actions">
                        <button class="btn btn-secondary" onclick="copyErrorsOnly()" title="Copy only errors and warnings with stack traces">
                             Copy Errors
                        </button>
                        <button class="btn btn-secondary" onclick="copyFilteredLogs()" title="Copy filtered logs">
                             Copy Filtered
                        </button>
                        <button class="btn btn-secondary" onclick="copyAllLogs()" title="Copy all logs">
                             Copy All
                        </button>
                        <button class="btn btn-secondary" onclick="clearUnifiedConsole()" title="Clear console">
                             Clear
                        </button>
                    </div>
                </div>
            </div>
            <div class="unified-console" id="unified-console">
                <div class="console-line">
                    <span class="console-timestamp">[00:00:00]</span>
                    <span class="console-info">Unified console initialized. Test and app logs will appear here.</span>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div class="tab-content" id="history-tab">
            <div class="empty-state">
                <div class="empty-state-icon"></div>
                <h3>Test History</h3>
                <p>View past test runs and results</p>
            </div>
        </div>

        <!-- Error Monitoring Tab -->
        <div class="tab-content" id="error-monitoring-tab">
            <div class="error-monitoring-container">
                <div class="error-stats-grid">
                    <!-- Error Statistics Cards -->
                    <div class="error-stat-card">
                        <h4>Last 24 Hours</h4>
                        <div class="error-count" id="errors-24h">-</div>
                        <div class="error-label">Total Errors</div>
                    </div>
                    <div class="error-stat-card">
                        <h4>Last Week</h4>
                        <div class="error-count" id="errors-week">-</div>
                        <div class="error-label">Total Errors</div>
                    </div>
                    <div class="error-stat-card">
                        <h4>Auto-Fixed</h4>
                        <div class="error-count success" id="errors-fixed">-</div>
                        <div class="error-label">Automatically Resolved</div>
                    </div>
                    <div class="error-stat-card">
                        <h4>Critical</h4>
                        <div class="error-count critical" id="errors-critical">-</div>
                        <div class="error-label">Requires Attention</div>
                    </div>
                </div>

                <!-- Error Patterns -->
                <div class="error-patterns-section">
                    <h3>Error Patterns</h3>
                    <div class="error-patterns-list" id="error-patterns-list">
                        <div class="loading">Loading error patterns...</div>
                    </div>
                </div>

                <!-- Recent Errors -->
                <div class="recent-errors-section">
                    <h3>Recent Errors</h3>
                    <div class="recent-errors-list" id="recent-errors-list">
                        <div class="loading">Loading recent errors...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Prompt Library Tab -->
        <div class="tab-content" id="prompts-tab">
            <div class="prompt-library-container">
                <!-- Left Panel: Prompt List -->
                <div class="prompt-sidebar">
                    <!-- Toolbar with New, Search, and Filter in one row -->
                    <div class="prompt-toolbar">
                        <button class="btn btn-primary btn-icon" id="new-prompt-btn" title="New Prompt">
                            <span style="font-size: 18px;">+</span>
                        </button>
                        <div class="toolbar-search">
                            <input type="text" id="prompt-search" placeholder="Search..." class="search-input">
                        </div>
                        <button class="btn btn-secondary btn-icon" id="filter-btn" title="Filter">
                            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M3 6h14M5 10h10M7 14h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Filter Panel (hidden by default) -->
                    <div class="filter-panel" id="filter-panel" style="display: none;">
                        <div class="filter-section">
                            <div class="filter-label">Tags</div>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="cupido" class="tag-checkbox"> Cupido App
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="simulator" class="tag-checkbox"> Simulator
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="extractor" class="tag-checkbox"> Extractor
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="money2020" class="tag-checkbox"> Money2020
                            </label>
                        </div>
                        <div class="filter-section">
                            <div class="filter-label">Status</div>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="active" class="status-checkbox"> Active
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="draft" class="status-checkbox"> Draft
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="archived" class="status-checkbox"> Archived
                            </label>
                        </div>
                    </div>

                    <!-- Prompt List -->
                    <div class="prompt-list" id="prompt-list">
                        <div class="prompt-list-loading">Loading prompts...</div>
                    </div>
                </div>

                <!-- Right Panel: Prompt Editor -->
                <div class="prompt-editor-panel" id="prompt-editor-panel">
                    <div class="empty-state">
                        <div class="empty-state-icon"></div>
                        <h3>No Prompt Selected</h3>
                        <p>Select a prompt from the list or create a new one</p>
                    </div>
                </div>

                <!-- Compare Versions Modal -->
                <div id="compare-modal" class="modal" style="display: none;">
                    <div class="modal-overlay" onclick="closeCompareModal()"></div>
                    <div class="modal-content compare-modal-content">
                        <div class="modal-header">
                            <h2>Compare Versions</h2>
                            <button class="modal-close" onclick="closeCompareModal()"></button>
                        </div>

                        <!-- Version Selectors -->
                        <div class="compare-selectors">
                            <div class="compare-selector-group">
                                <label>From Version:</label>
                                <select id="compare-from-version" onchange="updateComparison()">
                                    <!-- Populated dynamically -->
                                </select>
                            </div>
                            <div class="compare-selector-group">
                                <label>To Version:</label>
                                <select id="compare-to-version" onchange="updateComparison()">
                                    <!-- Populated dynamically -->
                                </select>
                            </div>
                        </div>

                        <!-- Side-by-side comparison -->
                        <div class="compare-container">
                            <div class="compare-panel">
                                <div class="compare-panel-header" id="compare-from-header">Version 1.0.0</div>
                                <div class="compare-panel-content" id="compare-from-content"></div>
                            </div>
                            <div class="compare-panel">
                                <div class="compare-panel-header" id="compare-to-header">Version 2.0.0</div>
                                <div class="compare-panel-content" id="compare-to-content"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scripts Tab -->
        <div class="tab-content active" id="health-tab">
            <div class="health-check-container">
                <div class="health-header">
                    <h2>
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" style="display: inline-block; vertical-align: text-top; margin-right: 8px;">
                            <path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20zm-1 15-4-4 1.41-1.41L11 14.17l6.59-6.59L19 9l-8 8z" fill="#34C759"/>
                        </svg>
                        Development Scripts
                    </h2>
                    <div class="health-actions">
                        <button class="health-run-btn" onclick="runAllHealthChecks()">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M8 1l7 4-7 4L1 5l7-4z" fill="currentColor"/>
                            </svg>
                            Run Health Check Scripts
                        </button>
                        <button class="health-refresh-btn" onclick="refreshHealthTable()">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M8 1.5a6.5 6.5 0 0 1 6.5 6.5h-2A4.5 4.5 0 1 0 8 12.5V11a.5.5 0 0 1 .854-.354l2 2a.5.5 0 0 1 0 .708l-2 2A.5.5 0 0 1 8 15v-1.5A6.5 6.5 0 0 1 8 1.5z" fill="currentColor"/>
                            </svg>
                            Refresh
                        </button>
                    </div>
                </div>

                <!-- System Health Table -->
                <div class="health-table-container">
                    <table class="health-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Test Name</th>
                                <th>Category</th>
                                <th>Module</th>
                                <th>Last Run</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="health-table-body">
                            <!-- Tests will be populated here -->
                        </tbody>
                    </table>
                </div>
                
                <!-- Summary Stats -->
                <div class="health-summary">
                    <div class="health-stat">
                        <span class="stat-value" id="passed-count">0</span>
                        <span class="stat-label">Scripts Passed</span>
                    </div>
                    <div class="health-stat">
                        <span class="stat-value" id="failed-count">0</span>
                        <span class="stat-label">Scripts Failed</span>
                    </div>
                    <div class="health-stat">
                        <span class="stat-value" id="pending-count">0</span>
                        <span class="stat-label">Scripts Available</span>
                    </div>
                    <div class="health-stat">
                        <span class="stat-value" id="health-percentage">0%</span>
                        <span class="stat-label">System Health</span>
                    </div>
                </div>


                    <!-- Core Services section removed -->

                    <!-- Automation Scripts section removed -->

                    <!-- Revolutionary Systems section removed -->

                    <!-- Test & Debug Scripts section removed -->

                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Load comprehensive test functions -->
    <script src="comprehensive-test-functions.js"></script>
    
    <!-- Load infrastructure test functions -->
    <script src="infrastructure-tests.js"></script>

    <script>
        // Simulator state management - exposed on window for test access
        const simulatorState = {
            isActive: false,
            isPaused: false,
            speed: 1,
            selectedPersonaId: null,
            conversationHistory: [],
            typingDelayMin: 1000,
            typingDelayMax: 3000
        };
        
        // Expose simulator state globally for tests
        window.simulatorState = simulatorState;
        
        // Test configuration from comprehensive test functions
        const testConfig = {
            foundation: { name: 'Foundation Tests', count: 5 },
            prompts: { name: 'Prompt Management', count: 3 },
            console: { name: 'Console Error Detection', count: 5 },
            phase2: { name: 'Phase 2: Revolutionary Analytics', count: 8 },
            phase3: { name: 'Phase 3: Advanced Automation', count: 7 },
            message: { name: 'Message Flow & UI', count: 8 },
            dashboard: { name: 'Dashboard UI State Management', count: 5 },
            profile: { name: 'Profile Extraction', count: 6 },
            database: { name: 'Database Operations', count: 5 },
            error: { name: 'Error Handling', count: 6 },
            state: { name: 'State Management', count: 6 },
            api: { name: 'API & Performance', count: 4 },
            simulator: { name: 'Simulator Testing', count: 18 },
            infra: { name: 'Infrastructure Validation', count: 6 }
        };

        // Initialize tests
        let tests = [];
        let testResults = {};
        let selectedTests = new Set();
        let currentTest = null;
        let currentTestRun = {
            id: null,
            startTime: null,
            tests: []
        };

        // API Call Tracker
        const apiCalls = [];
        function trackApiCall(url, method, body, response, duration, targetArray = null) {
            const call = {
                url,
                method,
                body,
                response,
                duration,
                timestamp: new Date().toISOString()
            };
            
            // Push to both global and per-test arrays
            apiCalls.push(call);
            if (targetArray) {
                targetArray.push(call);
            }
            
            logToConsole(`API Call: ${method} ${url} (${duration}ms)`, 'info', 'app');
            return call;
        }
        
        // Simulator control functions
        async function handleCupidoMessage(userMessage) {
            if (!simulatorState.isActive || simulatorState.isPaused) return;
            
            // Add user message to conversation history
            simulatorState.conversationHistory.push({
                role: 'user',
                content: userMessage
            });
            
            // Calculate typing delay
            const delay = simulatorState.typingDelayMin + 
                Math.random() * (simulatorState.typingDelayMax - simulatorState.typingDelayMin);
            const adjustedDelay = delay / simulatorState.speed;
            
            logToConsole(`Simulator will respond in ${Math.round(adjustedDelay)}ms`, 'info', 'simulator');
            
            // Wait for typing delay
            setTimeout(async () => {
                if (!simulatorState.isActive || simulatorState.isPaused) return;
                
                try {
                    // Generate response from simulator API
                    const response = await fetch('/api/simulator/generate-response', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            personaPromptId: simulatorState.selectedPersonaId,
                            conversationHistory: simulatorState.conversationHistory.slice(-10), // Last 10 messages
                            userMessage: userMessage
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.response) {
                        // Add AI response to history
                        simulatorState.conversationHistory.push({
                            role: 'assistant',
                            content: data.response
                        });
                        
                        // Send response to Cupido app
                        const iframe = document.getElementById('live-app-iframe');
                        if (iframe && iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'simulator-response',
                                message: data.response,
                                personaName: data.personaName
                            }, '*');
                        }
                        
                        logToConsole(`[SIMULATOR ${data.personaName}] ${data.response}`, 'success', 'simulator');
                    }
                } catch (error) {
                    logToConsole(`Simulator error: ${error.message}`, 'error', 'simulator');
                }
            }, adjustedDelay);
        }
        
        function startSimulator() {
            const personaSelect = document.getElementById('simulator-persona');
            if (!personaSelect || !personaSelect.value) {
                alert('Please select a simulator persona first');
                return;
            }
            
            simulatorState.isActive = true;
            simulatorState.isPaused = false;
            simulatorState.selectedPersonaId = personaSelect.value;
            simulatorState.conversationHistory = [];
            
            updateSimulatorControls();
            logToConsole('Simulator started', 'success', 'simulator');
        }
        
        function pauseSimulator() {
            simulatorState.isPaused = !simulatorState.isPaused;
            updateSimulatorControls();
            logToConsole(simulatorState.isPaused ? 'Simulator paused' : 'Simulator resumed', 'info', 'simulator');
        }
        
        function stopSimulator() {
            simulatorState.isActive = false;
            simulatorState.isPaused = false;
            simulatorState.conversationHistory = [];
            updateSimulatorControls();
            logToConsole('Simulator stopped', 'info', 'simulator');
        }
        
        function updateSimulatorSpeed(speed) {
            simulatorState.speed = parseFloat(speed);
            logToConsole(`Simulator speed set to ${speed}x`, 'info', 'simulator');
        }
        
        function updateSimulatorControls() {
            const startBtn = document.getElementById('sim-start-btn');
            const pauseBtn = document.getElementById('sim-pause-btn');
            const stopBtn = document.getElementById('sim-stop-btn');
            const personaSelect = document.getElementById('simulator-persona');
            
            if (startBtn) startBtn.disabled = simulatorState.isActive;
            if (pauseBtn) {
                pauseBtn.disabled = !simulatorState.isActive;
                pauseBtn.textContent = simulatorState.isPaused ? 'Resume' : 'Pause';
            }
            if (stopBtn) stopBtn.disabled = !simulatorState.isActive;
            if (personaSelect) personaSelect.disabled = simulatorState.isActive;
        }
        

        // Database Logger - stores all test runs in localStorage
        class TestLogger {
            constructor() {
                this.dbKey = 'cupido_test_logs';
                this.currentRunKey = 'cupido_current_test_run';
                this.apiUrl = '/api/test-logs';
            }

            // Initialize a new test run
            startTestRun() {
                const runId = `test_run_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
                currentTestRun = {
                    id: runId,
                    startTime: new Date().toISOString(),
                    endTime: null,
                    tests: [],
                    environment: {
                        apiUrl: `${window.location.origin}/api/chat`,
                        appUrl: '/app',
                        userAgent: navigator.userAgent,
                        timestamp: Date.now()
                    }
                };
                localStorage.setItem(this.currentRunKey, JSON.stringify(currentTestRun));
                logToConsole(`Started test run: ${runId}`, 'info');
                return runId;
            }

            // Log a test execution
            logTest(testId, testName, status, message, details = {}) {
                const testLog = {
                    testId,
                    testName,
                    status,
                    message,
                    timestamp: new Date().toISOString(),
                    duration: details.duration || 0,
                    apiCalls: details.apiCalls || [],
                    errors: details.errors || [],
                    metadata: details.metadata || {}
                };

                currentTestRun.tests.push(testLog);
                localStorage.setItem(this.currentRunKey, JSON.stringify(currentTestRun));
            }

            // Finalize test run and save to history
            endTestRun() {
                currentTestRun.endTime = new Date().toISOString();
                currentTestRun.totalDuration = Date.now() - new Date(currentTestRun.startTime).getTime();

                const passed = currentTestRun.tests.filter(t => t.status === 'pass').length;
                const failed = currentTestRun.tests.filter(t => t.status === 'fail').length;

                currentTestRun.summary = {
                    total: currentTestRun.tests.length,
                    passed,
                    failed,
                    passRate: ((passed / currentTestRun.tests.length) * 100).toFixed(1)
                };

                // Save to history
                const history = this.getHistory();
                history.unshift(currentTestRun);

                // Keep only last 50 test runs
                if (history.length > 50) {
                    history.splice(50);
                }

                localStorage.setItem(this.dbKey, JSON.stringify(history));
                localStorage.removeItem(this.currentRunKey);

                logToConsole(`Test run completed: ${passed}/${currentTestRun.tests.length} passed`,
                    passed === currentTestRun.tests.length ? 'success' : 'error');

                // POST test results to API for automated analysis
                this.postResultsToAPI(currentTestRun);
            }

            // POST results to API for automated fix loop
            async postResultsToAPI(testRun) {
                try {
                    const response = await fetch(`${window.location.origin}/api/test-results`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(testRun)
                    });

                    if (response.ok) {
                        console.log('Test results posted to API for automated analysis');
                    } else {
                        console.warn('Failed to post test results to API');
                    }
                } catch (error) {
                    console.warn('Could not post test results to API:', error.message);
                }
            }

            // Get test history
            getHistory() {
                const data = localStorage.getItem(this.dbKey);
                return data ? JSON.parse(data) : [];
            }

            // Get specific test run
            getTestRun(runId) {
                const history = this.getHistory();
                return history.find(run => run.id === runId);
            }

            // Clear all history
            clearHistory() {
                localStorage.removeItem(this.dbKey);
                localStorage.removeItem(this.currentRunKey);
                logToConsole('Test history cleared', 'info');
            }

            // Export logs as JSON
            exportLogs() {
                const history = this.getHistory();
                const dataStr = JSON.stringify(history, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `cupido_test_logs_${Date.now()}.json`;
                link.click();
                logToConsole('Logs exported', 'success');
            }
        }

        const testLogger = new TestLogger();

        // Generate test list from TEST_FUNCTIONS
        function initializeTests() {
            // CRITICAL: Add debugging and error handling for TEST_FUNCTIONS loading
            console.log(' initializeTests called');
            console.log(' window.TEST_FUNCTIONS available:', !!window.TEST_FUNCTIONS);
            
            if (window.TEST_FUNCTIONS) {
                const functionCount = Object.keys(window.TEST_FUNCTIONS).length;
                console.log(` Found ${functionCount} test functions`);
                
                Object.keys(window.TEST_FUNCTIONS).forEach(testId => {
                    const [category, num] = testId.split('-');
                    // Use TEST_METADATA from comprehensive-test-functions.js if available
                    const metadata = window.TEST_METADATA?.[testId] || getTestMetadata(testId);
                    tests.push({
                        id: testId,
                        name: metadata.name || getTestName(testId),
                        description: metadata.description || 'Test description',
                        module: metadata.module || 'Unknown',
                        category: metadata.category || testConfig[category]?.name || category,
                        status: 'pending',
                        lastRun: null,
                        duration: null
                    });
                });
                
                console.log(` Initialized ${tests.length} tests`);
                
                // CRITICAL: Export tests to global window for comprehensive-test-functions.js
                window.tests = tests;
                
                logToConsole(` Loaded ${functionCount} test functions successfully`, 'success');
            } else {
                console.error(' TEST_FUNCTIONS not available - comprehensive-test-functions.js may not have loaded');
                logToConsole(' TEST_FUNCTIONS not loaded - checking in 1 second...', 'error');
                
                // Retry after 1 second to allow for script loading
                setTimeout(() => {
                    if (window.TEST_FUNCTIONS) {
                        console.log(' TEST_FUNCTIONS now available, retrying initialization...');
                        logToConsole(' TEST_FUNCTIONS loaded, retrying initialization...', 'info');
                        
                        // Clear tests array and reinitialize
                        tests.length = 0;
                        initializeTests();
                        renderTestTable();
                        updateStats();
                    } else {
                        console.error(' TEST_FUNCTIONS still not available after retry');
                        logToConsole(' CRITICAL: TEST_FUNCTIONS failed to load after retry', 'error');
                        logToConsole(' Try refreshing the page or check browser console for errors', 'warning');
                    }
                }, 1000);
                return; // Don't render table if no tests loaded
            }
            renderTestTable();
        }

        // Get test name from test ID
        function getTestName(testId) {
            const names = {
                'console-1': 'No ReferenceErrors',
                'console-2': 'No TypeErrors',
                'console-3': 'No Network Errors',
                'console-4': 'No Warning Messages',
                'console-5': 'Clean Console Output',
                'message-1': 'Send Message Flow',
                'message-2': 'Receive Message Flow',
                'message-3': 'Message UI Update',
                'message-4': 'Message History',
                'message-5': 'Message Retry',
                'message-6': 'Message Timestamps',
                'message-7': 'Message Status',
                'message-8': 'Message Ordering',
                'profile-1': 'Extract Profile Data',
                'profile-2': 'Profile Completeness',
                'profile-3': 'Profile Validation',
                'profile-4': 'Profile Update',
                'profile-5': 'Profile Persistence',
                'profile-6': 'Profile Display',
                'database-1': 'Save to Database',
                'database-2': 'Load from Database',
                'database-3': 'Update Database',
                'database-4': 'Delete from Database',
                'database-5': 'Database Sync',
                'error-1': 'Network Error Handling',
                'error-2': 'API Error Handling',
                'error-3': 'Validation Errors',
                'error-4': 'Error Recovery',
                'error-5': 'Error Display',
                'error-6': 'Error Logging',
                'state-1': 'State Initialization',
                'state-2': 'State Updates',
                'state-3': 'State Persistence',
                'state-4': 'State Reset',
                'state-5': 'State Validation',
                'state-6': 'Loading States',
                'api-1': 'API Connectivity',
                'api-2': 'API Response Time',
                'api-3': 'API Error Handling',
                'api-4': 'API Rate Limiting'
            };
            return names[testId] || testId;
        }

        // Get test metadata (description and module)
        function getTestMetadata(testId) {
            const metadata = {
                'console-1': {
                    description: 'Monitor for ReferenceError during message send (catches bugs like commonLocations)',
                    module: 'userProfileService.ts'
                },
                'console-2': {
                    description: 'Monitor for TypeError in profile operations and UI rendering',
                    module: 'userProfileService.ts'
                },
                'console-3': {
                    description: 'Monitor for network errors in API calls and image loading',
                    module: 'apiService.ts'
                },
                'console-4': {
                    description: 'Check for warning messages in console during normal operation',
                    module: 'SimpleReflectionChat.tsx'
                },
                'console-5': {
                    description: 'Ensure console is clean with no unexpected errors or warnings',
                    module: 'App.tsx'
                },
                'message-1': {
                    description: 'Verify message send flow from input to chat history',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-2': {
                    description: 'Verify AI response is received and displayed correctly',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-3': {
                    description: 'Check that UI updates immediately when message is sent',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-4': {
                    description: 'Verify message history persists and loads correctly',
                    module: 'chatDatabase.ts'
                },
                'message-5': {
                    description: 'Test message retry functionality on failure',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-6': {
                    description: 'Verify timestamps are correctly displayed for all messages',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-7': {
                    description: 'Check message status indicators (sending, sent, failed)',
                    module: 'SimpleReflectionChat.tsx'
                },
                'message-8': {
                    description: 'Verify messages appear in correct chronological order',
                    module: 'chatDatabase.ts'
                },
                'profile-1': {
                    description: 'Test extraction of profile data from conversation',
                    module: 'personalityInsightsService.ts'
                },
                'profile-2': {
                    description: 'Check profile completeness score calculation',
                    module: 'userProfileService.ts'
                },
                'profile-3': {
                    description: 'Validate profile data structure and required fields',
                    module: 'userProfileService.ts'
                },
                'profile-4': {
                    description: 'Test profile update when new information is extracted',
                    module: 'personalityInsightsService.ts'
                },
                'profile-5': {
                    description: 'Verify profile data persists across sessions',
                    module: 'userProfileService.ts'
                },
                'profile-6': {
                    description: 'Check profile display on PixelPerfectProfileScreen',
                    module: 'PixelPerfectProfileScreen.tsx'
                },
                'database-1': {
                    description: 'Test saving messages and profile to AsyncStorage',
                    module: 'chatDatabase.ts'
                },
                'database-2': {
                    description: 'Test loading saved data from AsyncStorage',
                    module: 'chatDatabase.ts'
                },
                'database-3': {
                    description: 'Test updating existing records in database',
                    module: 'chatDatabase.ts'
                },
                'database-4': {
                    description: 'Test deleting messages and clearing chat history',
                    module: 'chatDatabase.ts'
                },
                'database-5': {
                    description: 'Verify database sync with app state',
                    module: 'chatDatabase.ts'
                },
                'error-1': {
                    description: 'Test handling of network timeout and connection errors',
                    module: 'apiService.ts'
                },
                'error-2': {
                    description: 'Test handling of API errors (4xx, 5xx responses)',
                    module: 'apiService.ts'
                },
                'error-3': {
                    description: 'Test validation error handling for user input',
                    module: 'SimpleReflectionChat.tsx'
                },
                'error-4': {
                    description: 'Test error recovery and retry mechanisms',
                    module: 'SimpleReflectionChat.tsx'
                },
                'error-5': {
                    description: 'Verify error messages are displayed to user',
                    module: 'SimpleReflectionChat.tsx'
                },
                'error-6': {
                    description: 'Check that errors are logged for debugging',
                    module: 'apiService.ts'
                },
                'state-1': {
                    description: 'Test initial state setup when app loads',
                    module: 'App.tsx'
                },
                'state-2': {
                    description: 'Test state updates during message flow',
                    module: 'SimpleReflectionChat.tsx'
                },
                'state-3': {
                    description: 'Test state persistence across app restarts',
                    module: 'chatDatabase.ts'
                },
                'state-4': {
                    description: 'Test state reset when user clears data',
                    module: 'SimpleReflectionChat.tsx'
                },
                'state-5': {
                    description: 'Validate state consistency across components',
                    module: 'App.tsx'
                },
                'state-6': {
                    description: 'Test loading state indicators during operations',
                    module: 'SimpleReflectionChat.tsx'
                },
                'api-1': {
                    description: 'Test connectivity to Claude AI API',
                    module: 'apiService.ts'
                },
                'api-2': {
                    description: 'Measure and verify API response time is acceptable',
                    module: 'apiService.ts'
                },
                'api-3': {
                    description: 'Test graceful handling of API errors',
                    module: 'apiService.ts'
                },
                'api-4': {
                    description: 'Test rate limiting and request throttling',
                    module: 'apiService.ts'
                },
                
                // ==========================================
                // SIMULATOR TESTING (18 tests)
                // ==========================================
                'simulator-1': {
                    description: 'Verify simulator personas load correctly from database',
                    module: 'server.js'
                },
                'simulator-2': {
                    description: 'Test API endpoint /api/simulator/generate-response with valid data',
                    module: 'server.js'
                },
                'simulator-3': {
                    description: 'Test Raj persona generates authentic startup founder responses',
                    module: 'simulator_raj prompt'
                },
                'simulator-4': {
                    description: 'Test Sarah persona generates authentic artist responses',
                    module: 'simulator_sarah prompt'
                },
                'simulator-5': {
                    description: 'Verify conversation history is properly passed to simulator API',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-6': {
                    description: 'Test simulator auto-response to Cupido app messages via postMessage',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-7': {
                    description: 'Verify Start/Pause/Resume controls work correctly',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-8': {
                    description: 'Test Stop control properly resets simulator state',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-9': {
                    description: 'Verify speed controls affect typing delay timing (1x/2x/3x)',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-10': {
                    description: 'Test realistic typing delays (1-3 seconds with randomization)',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-11': {
                    description: 'Verify simulator metadata saves correctly to conversations table',
                    module: 'server.js'
                },
                'simulator-12': {
                    description: 'Test error handling when persona prompt not found',
                    module: 'server.js'
                },
                'simulator-13': {
                    description: 'Test error handling when Claude API fails',
                    module: 'server.js'
                },
                'simulator-14': {
                    description: 'Verify simulator state persistence during pause/resume cycles',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-15': {
                    description: 'Test simulator conversation history limit (last 10 messages)',
                    module: 'server.js'
                },
                'simulator-16': {
                    description: 'Verify persona switching updates simulator behavior correctly',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-17': {
                    description: 'Test iframe communication: Cupido app  Dashboard postMessage',
                    module: 'cupido-test-dashboard.html'
                },
                'simulator-18': {
                    description: 'Test iframe communication: Dashboard  Cupido app response injection',
                    module: 'cupido-test-dashboard.html'
                }
            };
            return metadata[testId] || { description: 'Test description', module: 'Unknown' };
        }

        // Render test table (optionally with filtered tests)
        function renderTestTable(filteredTests = null) {
            const tbody = document.getElementById('test-table-body');
            const testsToShow = filteredTests || tests;
            tbody.innerHTML = testsToShow.map(test => `
                <tr id="test-row-${test.id}">
                    <td><input type="checkbox" class="test-checkbox" value="${test.id}" onchange="toggleTestSelection('${test.id}')"></td>
                    <td>${test.name}</td>
                    <td style="color: #6e6e73; font-size: 13px;">${test.description}</td>
                    <td><span class="category-badge">${test.module}</span></td>
                    <td><span class="category-badge">${test.category}</span></td>
                    <td><span class="status-badge status-${test.status}">${test.status.charAt(0).toUpperCase() + test.status.slice(1)}</span></td>
                    <td>${test.lastRun || '-'}</td>
                    <td>${test.duration ? test.duration + 'ms' : '-'}</td>
                    <td><button class="action-btn" onclick="runSingleTest('${test.id}')">Run</button></td>
                </tr>
            `).join('');
        }

        // Filter tests based on category selection
        function filterTestsByCategory() {
            const selectedCategory = document.getElementById('test-scope').value;
            logToConsole(` Filtering tests by category: ${selectedCategory}`, 'info');
            
            // If "all" is selected, show all tests
            if (selectedCategory === 'all') {
                renderTestTable();
                logToConsole(` Showing all ${tests.length} tests`, 'success');
                return;
            }
            
            // Filter tests by category
            const filteredTests = tests.filter(test => {
                const [testCategory] = test.id.split('-');
                return testCategory === selectedCategory;
            });
            
            // Render filtered test table
            renderTestTable(filteredTests);
            logToConsole(` Showing ${filteredTests.length} tests in category: ${testConfig[selectedCategory]?.name || selectedCategory}`, 'success');
        }

        // Tab switching with URL routing
        function switchTab(tabName, event) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Update URL hash without triggering page reload (use user-friendly names)
            if (event && !event.skipUrlUpdate) {
                const friendlyNames = {
                    'health': 'scripts',
                    'tests': 'tests', 
                    'live': 'live',
                    'console': 'console',
                    'history': 'history',
                    'error-monitoring': 'errors',
                    'prompts': 'prompts'
                };
                const friendlyName = friendlyNames[tabName] || tabName;
                window.history.pushState({}, '', `#${friendlyName}`);
            }
            
            // Initialize tab-specific content
            if (tabName === 'health') {
                initializeHealthCheck();
            }
            
            // Load error monitoring data when switching to error monitoring tab
            if (tabName === 'error-monitoring') {
                loadErrorStats();
                // Auto-refresh every 30 seconds
                if (window.errorMonitoringInterval) {
                    clearInterval(window.errorMonitoringInterval);
                }
                window.errorMonitoringInterval = setInterval(loadErrorStats, 30000);
            } else {
                // Clear auto-refresh when leaving error monitoring tab
                if (window.errorMonitoringInterval) {
                    clearInterval(window.errorMonitoringInterval);
                    window.errorMonitoringInterval = null;
                }
            }
            
            // Initialize prompt library when switching to prompts tab
            if (tabName === 'prompts') {
                initializePromptLibrary();
            }
            
            console.log(` Switched to ${tabName} tab - URL: ${window.location.href}`);
        }
        
        // Handle URL hash changes (back/forward browser navigation)
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the # symbol
            
            // Map user-friendly URLs to internal tab names
            const urlMapping = {
                'scripts': 'health',
                'health': 'health',
                'tests': 'tests',
                'live': 'live',
                'preview': 'live',
                'console': 'console',
                'logs': 'console',
                'history': 'history',
                'errors': 'error-monitoring',
                'error-monitoring': 'error-monitoring',
                'prompts': 'prompts',
                'prompt-library': 'prompts'
            };
            
            const tabName = urlMapping[hash];
            
            if (hash && tabName) {
                // Find the tab element and trigger switch (without updating URL again)
                const tabElement = document.querySelector(`[onclick*="'${tabName}'"]`);
                if (tabElement) {
                    switchTab(tabName, { target: tabElement, skipUrlUpdate: true });
                }
            } else if (!hash) {
                // Default to scripts tab if no hash
                switchTab('health', { target: document.querySelector(`[onclick*="'health'"]`), skipUrlUpdate: true });
            } else {
                // Invalid hash - redirect to scripts
                window.history.replaceState({}, '', '#scripts');
                handleHashChange();
            }
        }
        
        // Initialize URL routing
        function initializeUrlRouting() {
            // Handle browser back/forward
            window.addEventListener('hashchange', handleHashChange);
            
            // Handle initial page load with hash
            if (window.location.hash) {
                handleHashChange();
            } else {
                // Set default hash to scripts tab
                window.history.replaceState({}, '', '#scripts');
            }
        }

        // Test selection
        function toggleTestSelection(testId) {
            if (selectedTests.has(testId)) {
                selectedTests.delete(testId);
            } else {
                selectedTests.add(testId);
            }
        }

        function toggleAllTests() {
            const selectAll = document.getElementById('select-all').checked;
            document.querySelectorAll('.test-checkbox').forEach(cb => {
                cb.checked = selectAll;
                if (selectAll) {
                    selectedTests.add(cb.value);
                } else {
                    selectedTests.delete(cb.value);
                }
            });
        }

        function selectAll() {
            document.getElementById('select-all').checked = true;
            toggleAllTests();
        }

        function clearSelection() {
            document.getElementById('select-all').checked = false;
            toggleAllTests();
        }

        // Console logging
        function logToConsole(message, type = 'info', source = 'test') {
            const console = document.getElementById('unified-console');
            if (!console) return;

            const timestamp = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.className = 'console-line';
            line.setAttribute('data-source', source);
            line.innerHTML = `
                <span class="console-timestamp">[${timestamp}]</span>
                <span style="color: #6e6e73;">[${source.toUpperCase()}]</span>
                <span class="console-${type}">${message}</span>
            `;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
        }

        // Unified console functions
        function clearUnifiedConsole() {
            const console = document.getElementById('unified-console');
            if (console) {
                console.innerHTML = '<div class="console-line"><span class="console-timestamp">[' + new Date().toLocaleTimeString() + ']</span><span class="console-info">Console cleared</span></div>';
            }
        }

        function filterConsole(filter) {
            const lines = document.querySelectorAll('#unified-console .console-line');
            lines.forEach(line => {
                const source = line.getAttribute('data-source') || 'test';
                if (filter === 'all' || source === filter) {
                    line.style.display = 'flex';
                } else {
                    line.style.display = 'none';
                }
            });
            // Reapply log level filters
            filterLogLevels();
        }

        // Filter console by log levels (info/warning/error/success)
        function filterLogLevels() {
            const showInfo = document.getElementById('filter-info').checked;
            const showWarning = document.getElementById('filter-warning').checked;
            const showError = document.getElementById('filter-error').checked;
            const showSuccess = document.getElementById('filter-success').checked;
            
            const lines = document.querySelectorAll('#unified-console .console-line');
            lines.forEach(line => {
                // Skip if already hidden by source filter
                if (line.style.display === 'none') return;
                
                const hasInfo = line.querySelector('.console-info');
                const hasWarning = line.querySelector('.console-warning');
                const hasError = line.querySelector('.console-error');
                const hasSuccess = line.querySelector('.console-success');
                
                let shouldShow = false;
                if (hasInfo && showInfo) shouldShow = true;
                if (hasWarning && showWarning) shouldShow = true;
                if (hasError && showError) shouldShow = true;
                if (hasSuccess && showSuccess) shouldShow = true;
                
                // Show timestamps and general messages if info is enabled
                if (!hasInfo && !hasWarning && !hasError && !hasSuccess && showInfo) {
                    shouldShow = true;
                }
                
                line.style.display = shouldShow ? 'flex' : 'none';
            });
        }

        // Copy filtered logs to clipboard
        function copyFilteredLogs() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }
            
            const visibleLines = Array.from(consoleElement.querySelectorAll('.console-line'))
                .filter(line => line.style.display !== 'none');
            
            let logText = '';
            visibleLines.forEach(line => {
                const text = line.textContent.trim();
                if (text) {
                    logText += text + '\n';
                }
            });
            
            if (logText) {
                navigator.clipboard.writeText(logText).then(() => {
                    logToConsole(`Copied ${visibleLines.length} filtered log lines to clipboard`, 'success', 'dashboard');
                }).catch(err => {
                    console.error('Failed to copy logs:', err);
                    logToConsole('Failed to copy logs to clipboard', 'error', 'dashboard');
                });
            } else {
                logToConsole('No visible logs to copy', 'warning', 'dashboard');
            }
        }

        // Copy all console logs to clipboard
        function copyAllLogs() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }

            const lines = consoleElement.querySelectorAll('.console-line');
            let logText = '';

            lines.forEach(line => {
                // Extract text content from the line
                const text = line.textContent || line.innerText;
                if (text.trim()) {
                    logText += text + '\n';
                }
            });

            if (!logText.trim()) {
                alert('No logs to copy');
                return;
            }

            // Copy to clipboard
            navigator.clipboard.writeText(logText).then(() => {
                // Show success message in console
                const originalText = logText;
                logToConsole(' All logs copied to clipboard!', 'success');

                // Remove the success message after 3 seconds
                setTimeout(() => {
                    const lines = consoleElement.querySelectorAll('.console-line');
                    const lastLine = lines[lines.length - 1];
                    if (lastLine && lastLine.textContent.includes('All logs copied')) {
                        lastLine.remove();
                    }
                }, 3000);
            }).catch(err => {
                console.error('Failed to copy logs:', err);
                alert('Failed to copy logs to clipboard. Error: ' + err.message);
            });
        }

        function copyFailuresOnly() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }

            const lines = consoleElement.querySelectorAll('.console-line');
            let allText = '';

            // Collect all text first
            lines.forEach(line => {
                const text = line.textContent || line.innerText;
                if (text.trim()) {
                    allText += text + '\n';
                }
            });

            // Split by test separators
            const testBlocks = allText.split('');

            // Filter to only failed tests
            const failedTests = testBlocks.filter(block => {
                return block.includes('Status: FAILED ');
            });

            if (failedTests.length === 0) {
                alert('No failed tests found');
                return;
            }

            // Reconstruct with separators
            let failureText = 'FAILED TESTS REPORT\n';
            failureText += '\n\n';

            failedTests.forEach((test, index) => {
                if (test.trim()) {
                    failureText += '\n';
                    failureText += test.trim() + '\n';
                    failureText += '\n\n';
                }
            });

            failureText += `\nTotal Failed Tests: ${failedTests.length}\n`;

            // Copy to clipboard
            navigator.clipboard.writeText(failureText).then(() => {
                logToConsole(` ${failedTests.length} failed test(s) copied to clipboard!`, 'success');

                // Remove the success message after 3 seconds
                setTimeout(() => {
                    const lines = consoleElement.querySelectorAll('.console-line');
                    const lastLine = lines[lines.length - 1];
                    if (lastLine && lastLine.textContent.includes('failed test(s) copied')) {
                        lastLine.remove();
                    }
                }, 3000);
            }).catch(err => {
                console.error('Failed to copy failures:', err);
                alert('Failed to copy failures to clipboard. Error: ' + err.message);
            });
        }

        // Copy only errors and warnings with enhanced formatting for debugging
        function copyErrorsOnly() {
            const consoleElement = document.getElementById('unified-console');
            if (!consoleElement) {
                alert('Console not found');
                return;
            }

            const lines = consoleElement.querySelectorAll('.console-line');
            let errorReport = 'ERROR AND WARNING REPORT\n';
            errorReport += '\n';
            errorReport += `Generated: ${new Date().toISOString()}\n`;
            errorReport += '\n\n';

            let errorCount = 0;
            let warningCount = 0;
            let currentTestContext = '';

            lines.forEach((line, index) => {
                const text = line.textContent || line.innerText;
                const hasError = line.querySelector('.console-error');
                const hasWarning = line.querySelector('.console-warning');
                
                // Track current test context
                if (text.includes(' TEST:')) {
                    currentTestContext = text.match(/ TEST: (.+)/)?.[1] || '';
                }
                
                if (hasError || hasWarning) {
                    if (currentTestContext) {
                        errorReport += `[${currentTestContext}] `;
                    }
                    
                    if (hasError) {
                        errorReport += ' ERROR: ';
                        errorCount++;
                    } else {
                        errorReport += '  WARNING: ';
                        warningCount++;
                    }
                    
                    errorReport += text.trim() + '\n';
                    
                    // Add context from previous and next lines if helpful
                    if (index > 0) {
                        const prevLine = lines[index - 1];
                        const prevText = prevLine.textContent || prevLine.innerText;
                        if (prevText.includes('Executing') || prevText.includes('Duration') || prevText.includes('Function')) {
                            errorReport += `   Context: ${prevText.trim()}\n`;
                        }
                    }
                    
                    errorReport += '\n';
                }
            });

            errorReport += '\n\n';
            errorReport += `SUMMARY: ${errorCount} Errors, ${warningCount} Warnings\n`;
            errorReport += '\n';

            if (errorCount === 0 && warningCount === 0) {
                alert('No errors or warnings found in console');
                return;
            }

            // Copy to clipboard
            navigator.clipboard.writeText(errorReport).then(() => {
                logToConsole(` ${errorCount} errors and ${warningCount} warnings copied to clipboard!`, 'success');
            }).catch(err => {
                console.error('Failed to copy errors:', err);
                alert('Failed to copy errors to clipboard. Error: ' + err.message);
            });
        }

        // Run tests
        async function runSelectedTests() {
            const scope = document.getElementById('test-scope').value;
            let testsToRun = [];

            if (scope === 'all') {
                testsToRun = selectedTests.size > 0 ? Array.from(selectedTests) : tests.map(t => t.id);
            } else {
                testsToRun = tests.filter(t => t.id.startsWith(scope + '-')).map(t => t.id);
            }

            if (testsToRun.length === 0) {
                logToConsole('No tests selected', 'warning');
                return;
            }

            logToConsole(`Starting ${testsToRun.length} tests...`, 'info');
            logToConsole('', 'info');

            // Start test run logging
            testLogger.startTestRun();

            // Clear previous results
            testResults = {};
            apiCalls.length = 0;

            for (const testId of testsToRun) {
                await runSingleTest(testId);
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            logToConsole(''.repeat(60), 'info');
            
            // Show detailed test run summary
            const passed = testsToRun.filter(id => testResults[id] === true);
            const failed = testsToRun.filter(id => testResults[id] === false);
            
            logToConsole(` TEST RUN COMPLETE`, 'info');
            logToConsole(` Passed: ${passed.length}/${testsToRun.length}`, 'success');
            logToConsole(` Failed: ${failed.length}/${testsToRun.length}`, failed.length > 0 ? 'error' : 'info');
            logToConsole(` Success Rate: ${Math.round((passed.length / testsToRun.length) * 100)}%`, passed.length === testsToRun.length ? 'success' : 'warning');
            
            if (failed.length > 0) {
                logToConsole(` Failed Tests:`, 'error');
                failed.forEach(testId => {
                    const test = tests.find(t => t.id === testId);
                    logToConsole(`    ${testId}: ${test?.name || 'Unknown'}`, 'error');
                });
            }

            // End test run logging
            testLogger.endTestRun();

            updateStats();
        }

        async function runSingleTest(testId) {
            if (currentTest) {
                logToConsole('Another test is running, please wait...', 'warning');
                return;
            }

            // Start test run logging for single test
            testLogger.startTestRun();

            const test = tests.find(t => t.id === testId);
            if (!test) return;

            currentTest = testId;
            test.status = 'running';
            test.lastRun = new Date().toLocaleTimeString();
            renderTestTable();
            
            // Brief delay to ensure UI updates before execution
            await new Promise(resolve => setTimeout(resolve, 100));

            // Log detailed test start with clear separation
            logToConsole(''.repeat(60), 'info');
            logToConsole(` TEST: ${testId}`, 'info');
            logToConsole(` Name: ${test.name}`, 'info');
            logToConsole(` Category: ${test.category}`, 'info');
            logToConsole(` Started: ${test.lastRun}`, 'info');
            logToConsole(` Status: RUNNING...`, 'info');

            const startTime = Date.now();
            const testApiCalls = [];
            const testErrors = [];
            
            // Set up global reference for API call tracking
            window.currentTestApiCalls = testApiCalls;

            try {
                const testFn = window.TEST_FUNCTIONS[testId];
                if (testFn) {
                    logToConsole(`Executing test function...`, 'info');

                    const result = await testFn();
                    const duration = Date.now() - startTime;

                    test.status = result.pass ? 'pass' : 'fail';
                    test.duration = duration;
                    
                    // Update UI immediately to show final status
                    renderTestTable();

                    // Log detailed results with clear visual indicators
                    logToConsole(`${result.pass ? ' PASSED' : ' FAILED'}: ${testId}`, result.pass ? 'success' : 'error');
                    logToConsole(` Duration: ${duration}ms`, 'info');
                    logToConsole(` Result: ${result.message}`, result.pass ? 'success' : 'error');

                    if (!result.pass) {
                        // Log detailed failure information
                        if (result.errors && result.errors.length > 0) {
                            logToConsole(` Errors Found (${result.errors.length}):`, 'error');
                            result.errors.forEach((err, idx) => {
                                logToConsole(`   ${idx + 1}. ${err}`, 'error');
                            });
                        }

                        // Log metadata for debugging
                        if (result.metadata) {
                            logToConsole(` Debug Information:`, 'info');
                            Object.keys(result.metadata).forEach(key => {
                                logToConsole(`    ${key}: ${JSON.stringify(result.metadata[key])}`, 'info');
                            });
                        }

                        // Log suggestions based on test category
                        logToConsole(` Suggestions:`, 'warning');
                        if (testId.startsWith('console-')) {
                            logToConsole(`  - Check browser console for detailed error messages`, 'warning');
                            logToConsole(`  - Verify all required JavaScript files are loaded`, 'warning');
                            logToConsole(`  - Look for undefined variables or missing imports`, 'warning');
                        } else if (testId.startsWith('message-')) {
                            logToConsole(`  - Verify iframe communication is working`, 'warning');
                            logToConsole(`  - Check if Live Preview tab has loaded the app`, 'warning');
                            logToConsole(`  - Ensure message handlers are registered`, 'warning');
                            logToConsole(`  - Verify testID attributes are rendered as data-testid in DOM`, 'warning');
                            if (result.metadata && result.metadata.issue === 'DOM element not accessible') {
                                logToConsole(`  - HINT: ${result.metadata.hint}`, 'warning');
                            }
                        } else if (testId.startsWith('profile-')) {
                            logToConsole(`  - Check AI response for profile extraction`, 'warning');
                            logToConsole(`  - Verify profile service is running`, 'warning');
                        } else if (testId.startsWith('database-')) {
                            logToConsole(`  - Verify database connection`, 'warning');
                            logToConsole(`  - Check Supabase credentials`, 'warning');
                        } else if (testId.startsWith('api-')) {
                            logToConsole(`  - Ensure server is running on port 3001`, 'warning');
                            logToConsole(`  - Check API credentials`, 'warning');
                        }

                        testErrors.push(result.message);
                    }

                    // Log to database
                    testLogger.logTest(testId, test.name, result.pass ? 'pass' : 'fail', result.message, {
                        duration,
                        apiCalls: result.apiCalls || testApiCalls,
                        errors: testErrors,
                        metadata: result.metadata || {}
                    });

                    testResults[testId] = result.pass;
                    
                    // Add separation line after test completion
                    logToConsole(''.repeat(60), 'info');
                } else {
                    const duration = Date.now() - startTime;
                    test.status = 'fail';
                    test.duration = duration;
                    
                    // Update UI immediately to show final status
                    renderTestTable();

                    logToConsole(`Status: FAILED `, 'error');
                    logToConsole(`Duration: ${duration}ms`, 'info');
                    logToConsole(`Error: Test function not found`, 'error');
                    logToConsole(`Details:`, 'error');
                    logToConsole(`  - Test ID: ${testId}`, 'error');
                    logToConsole(`  - Function should be in: comprehensive-test-functions.js`, 'error');
                    logToConsole(`Suggestions:`, 'warning');
                    logToConsole(`  - Verify comprehensive-test-functions.js is loaded`, 'warning');
                    logToConsole(`  - Check that TEST_FUNCTIONS object contains '${testId}'`, 'warning');
                    logToConsole(`  - Reload the page to refresh test functions`, 'warning');

                    testErrors.push('Test function not found');

                    // Log to database
                    testLogger.logTest(testId, test.name, 'fail', 'Test function not found', {
                        duration,
                        apiCalls: testApiCalls,
                        errors: testErrors,
                        metadata: {}
                    });

                    testResults[testId] = false;
                }
            } catch (error) {
                const duration = Date.now() - startTime;
                test.status = 'fail';
                test.duration = duration;
                
                // Update UI immediately to show final status
                renderTestTable();

                logToConsole(`Status: FAILED `, 'error');
                logToConsole(`Duration: ${duration}ms`, 'info');
                logToConsole(`Error: ${error.message}`, 'error');

                if (error.stack) {
                    logToConsole(`Stack Trace:`, 'error');
                    const stackLines = error.stack.split('\n').slice(0, 5); // First 5 lines
                    stackLines.forEach(line => {
                        logToConsole(`  ${line.trim()}`, 'error');
                    });
                }

                logToConsole(`Details:`, 'error');
                logToConsole(`  - Error Type: ${error.name || 'Unknown'}`, 'error');
                logToConsole(`  - Test ID: ${testId}`, 'error');

                logToConsole(`Suggestions:`, 'warning');
                if (error.message.includes('iframe')) {
                    logToConsole(`  - Verify Live Preview tab has loaded the app`, 'warning');
                    logToConsole(`  - Check iframe ID is 'live-app-iframe'`, 'warning');
                    logToConsole(`  - Ensure app is running without errors`, 'warning');
                } else if (error.message.includes('timeout') || error.message.includes('Timeout')) {
                    logToConsole(`  - Server may be slow or unresponsive`, 'warning');
                    logToConsole(`  - Check network connectivity`, 'warning');
                    logToConsole(`  - Verify API server is running`, 'warning');
                } else {
                    logToConsole(`  - Check browser console for more details`, 'warning');
                    logToConsole(`  - Review the stack trace above`, 'warning');
                }

                testErrors.push(error.message);

                // Log to database
                testLogger.logTest(testId, test.name, 'fail', `Error: ${error.message}`, {
                    duration,
                    apiCalls: testApiCalls,
                    errors: testErrors,
                    metadata: { stack: error.stack }
                });

                testResults[testId] = false;
            }

            logToConsole('', 'info');
            logToConsole('', 'info'); // Blank line for spacing

            currentTest = null;
            
            // Clear API call tracking reference
            window.currentTestApiCalls = null;
            
            // End test run logging for single test
            testLogger.endTestRun();
            
            renderTestTable();
            updateStats();
        }

        // Update stats - automatically calculated from TEST_FUNCTIONS
        function updateStats() {
            // CRITICAL: Calculate total from actual TEST_FUNCTIONS object, not manual config
            const actualTestCount = window.TEST_FUNCTIONS ? Object.keys(window.TEST_FUNCTIONS).length : 0;
            
            const passed = tests.filter(t => t.status === 'pass').length;
            const failed = tests.filter(t => t.status === 'fail').length;
            const pending = tests.filter(t => t.status === 'pending').length;

            // Use actual test count, not hardcoded value
            document.getElementById('total-tests').textContent = actualTestCount;
            document.getElementById('passed-tests').textContent = passed;
            document.getElementById('failed-tests').textContent = failed;
            document.getElementById('pending-tests').textContent = pending;
            
            // Validation: Ensure tests array matches TEST_FUNCTIONS
            if (tests.length !== actualTestCount) {
                console.warn(`Test count mismatch: tests.length=${tests.length}, TEST_FUNCTIONS=${actualTestCount}`);
                logToConsole(`  Test count mismatch detected: ${tests.length} vs ${actualTestCount}`, 'warning');
            }
        }

        // Export results
        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                tests: tests,
                summary: {
                    total: tests.length,
                    passed: tests.filter(t => t.status === 'pass').length,
                    failed: tests.filter(t => t.status === 'fail').length,
                    pending: tests.filter(t => t.status === 'pending').length
                }
            };

            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cupido-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            logToConsole('Test results exported', 'success');
        }

        // Show test history
        function showHistory() {
            const history = testLogger.getHistory();
            console.log('Test History:');
            console.table(history.map(run => ({
                id: run.id.slice(-8),
                startTime: new Date(run.startTime).toLocaleString(),
                total: run.summary?.total || 0,
                passed: run.summary?.passed || 0,
                failed: run.summary?.failed || 0,
                passRate: run.summary?.passRate + '%' || '0%'
            })));
            logToConsole(`Found ${history.length} test runs in history`, 'info');
        }

        // Auto-fix test failures
        async function autoFixFailures() {
            logToConsole('AUTO-FIX: Starting automated failure analysis...', 'info');

            try {
                // Fetch latest test results
                const response = await fetch(`${window.location.origin}/api/test-results/latest`);
                if (!response.ok) {
                    if (response.status === 404) {
                        logToConsole('AUTO-FIX: No test results available. Run tests first.', 'warning');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const testResults = await response.json();
                const failedTests = testResults.tests.filter(t => t.status === 'fail');

                if (failedTests.length === 0) {
                    logToConsole('AUTO-FIX: All tests passing! No fixes needed.', 'success');
                    return;
                }

                logToConsole(`AUTO-FIX: Found ${failedTests.length} failed test(s). Analyzing with Claude AI...`, 'info');

                // Build analysis prompt
                const analysisPrompt = `You are an expert software debugger analyzing test failures for a React Native web app.

Test Results Summary:
- Total: ${testResults.summary.total}
- Passed: ${testResults.summary.passed}
- Failed: ${testResults.summary.failed}

Failed Tests:
${failedTests.map((test, idx) => `
${idx + 1}. ${test.testName} (${test.testId})
   Status: ${test.status}
   Message: ${test.message}
   Errors: ${JSON.stringify(test.errors || [])}
   Metadata: ${JSON.stringify(test.metadata || {})}`).join('\n')}

Analyze these failures and provide:
1. Root cause of each failure
2. Which file(s) need to be fixed
3. Specific code changes needed
4. Risk level (LOW/MEDIUM/HIGH) for each fix

Format as JSON:
{
  "analysis": "overall analysis",
  "fixes": [
    {
      "testId": "test-id",
      "file": "path/to/file",
      "reason": "why this fix is needed",
      "riskLevel": "LOW|MEDIUM|HIGH",
      "changes": "description of changes"
    }
  ]
}`;

                // Call Claude AI for analysis
                const aiResponse = await fetch(`${window.location.origin}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: [
                            { role: 'user', content: analysisPrompt }
                        ],
                        modelType: 'sonnet'
                    })
                });

                if (!aiResponse.ok) {
                    throw new Error(`Claude API error: ${aiResponse.status}`);
                }

                const aiData = await aiResponse.json();
                const analysisText = aiData.message;

                // Try to parse JSON from Claude's response
                const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
                let analysis;
                if (jsonMatch) {
                    analysis = JSON.parse(jsonMatch[0]);
                } else {
                    logToConsole('AUTO-FIX: Could not parse structured response from Claude', 'warning');
                    logToConsole(`Analysis: ${analysisText}`, 'info');
                    return;
                }

                logToConsole(`AUTO-FIX Analysis: ${analysis.analysis}`, 'info');
                logToConsole(`AUTO-FIX: Proposed ${analysis.fixes.length} fix(es)`, 'info');

                // Process each fix
                for (let i = 0; i < analysis.fixes.length; i++) {
                    const fix = analysis.fixes[i];
                    logToConsole(`Fix ${i + 1}/${analysis.fixes.length}: ${fix.file}`, 'info');
                    logToConsole(`Test: ${fix.testId}`, 'info');
                    logToConsole(`Risk: ${fix.riskLevel}`, 'info');
                    logToConsole(`Reason: ${fix.reason}`, 'info');
                    logToConsole(`Changes: ${fix.changes}`, 'info');

                    // Determine if safe to auto-apply
                    const isRiskyFile = /server\.js$|\.env$|package\.json$|tsconfig\.json$/.test(fix.file);
                    const isSafe = fix.riskLevel === 'LOW' && !isRiskyFile;

                    if (isSafe) {
                        logToConsole(`AUTO-FIX: Low risk - requesting detailed fix instructions...`, 'success');

                        // Get detailed fix from Claude
                        const fixPrompt = `Generate the exact code changes for this fix:

File: ${fix.file}
Reason: ${fix.reason}
Changes needed: ${fix.changes}

Provide specific, actionable instructions for the developer to apply this fix manually.
Include the exact code snippets that need to be changed.`;

                        const fixResponse = await fetch(`${window.location.origin}/api/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                messages: [
                                    { role: 'user', content: fixPrompt }
                                ],
                                modelType: 'sonnet'
                            })
                        });

                        if (fixResponse.ok) {
                            const fixData = await fixResponse.json();
                            logToConsole(`Fix Instructions:\n${fixData.message}`, 'info');
                        }
                    } else {
                        logToConsole(`AUTO-FIX: ${fix.riskLevel} risk or critical file - manual review required`, 'warning');
                        logToConsole(`Action required: Please review and apply this fix manually`, 'warning');
                    }
                }

                logToConsole(`AUTO-FIX: Analysis complete! Review the fix instructions above.`, 'success');

            } catch (error) {
                logToConsole(`AUTO-FIX Error: ${error.message}`, 'error');
                console.error('Auto-fix error:', error);
            }
        }

        // Global functions for console access
        window.showHistory = showHistory;
        window.autoFixFailures = autoFixFailures;
        window.exportLogs = () => testLogger.exportLogs();
        window.clearHistory = () => testLogger.clearHistory();

        // Live Preview Functions
        let claudeStatus = 'idle';

        // Persona definitions from chatsim.html
        const SIMULATOR_PERSONAS = {
            sarah: {
                name: 'Sarah Chen',
                age: 28,
                occupation: 'Product Manager at Google',
                location: 'San Francisco, CA',
                bio: 'Tech enthusiast who loves hiking and photography. Looking for someone ambitious and adventurous.',
                interests: ['Technology', 'Hiking', 'Photography', 'Travel']
            },
            mike: {
                name: 'Mike Rodriguez',
                age: 32,
                occupation: 'Graphic Designer',
                location: 'Brooklyn, NY',
                bio: 'Creative soul with a passion for art and good coffee. Seeking genuine connections.',
                interests: ['Design', 'Art', 'Coffee', 'Music']
            },
            emily: {
                name: 'Emily Watson',
                age: 24,
                occupation: 'PhD Student in Biology',
                location: 'Boston, MA',
                bio: 'Science nerd who enjoys running and reading sci-fi novels. Love deep conversations.',
                interests: ['Science', 'Running', 'Reading', 'Nature']
            },
            raj: {
                name: 'Raj Patel',
                age: 35,
                occupation: 'Entrepreneur',
                location: 'Austin, TX',
                bio: 'Startup founder balancing work and life. Foodie who loves trying new restaurants.',
                interests: ['Business', 'Food', 'Travel', 'Fitness']
            },
            rachel: {
                name: 'Rachel Kim',
                age: 29,
                occupation: 'Artist',
                location: 'Portland, OR',
                bio: 'Painter and yoga instructor. Seeking someone creative and mindful.',
                interests: ['Art', 'Yoga', 'Meditation', 'Sustainability']
            },
            alex: {
                name: 'Alex Torres',
                age: 31,
                occupation: 'Startup Founder',
                location: 'Miami, FL',
                bio: 'Serial entrepreneur passionate about tech and social impact. Love the beach and good books.',
                interests: ['Technology', 'Entrepreneurship', 'Reading', 'Beach Sports']
            }
        };


        // Update persona info display
        function updatePersonaInfo() {
            const personaSelect = document.getElementById('simulator-persona');
            if (!personaSelect) return;
            const personaId = personaSelect.value;
            const personaInfo = document.getElementById('persona-info');

            if (!personaId) {
                personaInfo.style.display = 'none';
                return;
            }

            // Get prompt data from the selected option
            const selectedOption = personaSelect.options[personaSelect.selectedIndex];
            const promptData = selectedOption.dataset.promptData;

            if (promptData) {
                // Using Supabase simulator prompt
                const prompt = JSON.parse(promptData);
                personaInfo.style.display = 'block';
                personaInfo.innerHTML = `
                    <div style="margin-top: 8px; padding: 12px; background: #f5f5f7; border-radius: 8px;">
                        <div style="font-weight: 600; color: #1d1d1f;">${prompt.name}</div>
                        <div style="font-size: 12px; color: #6e6e73; margin-top: 4px;">Version: ${prompt.version}</div>
                        ${prompt.description ? `<div style="font-size: 12px; color: #1d1d1f; margin-top: 8px;">${prompt.description}</div>` : ''}
                        <div style="font-size: 11px; color: #86868b; margin-top: 8px;">From Supabase Prompt Library</div>
                    </div>
                `;
            } else if (typeof SIMULATOR_PERSONAS !== 'undefined' && SIMULATOR_PERSONAS[personaId]) {
                // Fallback to hardcoded personas (for backwards compatibility)
                const persona = SIMULATOR_PERSONAS[personaId];
                personaInfo.style.display = 'block';
                personaInfo.innerHTML = `
                    <div style="margin-top: 8px; padding: 12px; background: #f5f5f7; border-radius: 8px;">
                        <div style="font-weight: 600; color: #1d1d1f;">${persona.name}, ${persona.age}</div>
                        <div style="font-size: 12px; color: #6e6e73; margin-top: 4px;">${persona.occupation}</div>
                        <div style="font-size: 12px; color: #6e6e73;">${persona.location}</div>
                        <div style="font-size: 12px; color: #1d1d1f; margin-top: 8px;">${persona.bio}</div>
                    </div>
                `;
            }
        }

        // Load preset messages
        function loadPreset(presetType) {
            const messageInput = document.getElementById('sim-message');
            const presets = {
                intro: "Hey! I just saw your profile and thought we might have some things in common. What do you like to do in your free time?",
                question: "What's something you're really passionate about?",
                casual: "How's your day going?",
                deep: "What's something you've learned about yourself recently?"
            };

            messageInput.value = presets[presetType] || '';
            logToConsole(`Loaded preset: ${presetType}`, 'info', 'app');
        }

        // Update rudeness slider value display
        function updateRudenessValue(value) {
            document.getElementById('rudeness-value').textContent = value;
        }

        // Get contextual search query from message
        function getImageSearchQuery(message) {
            // Extract key nouns/topics from the message for image search
            const keywords = ['coffee', 'travel', 'beach', 'mountain', 'food', 'sunset', 'city', 'nature', 'art', 'music', 'fitness', 'yoga', 'hiking', 'restaurant', 'book', 'movie', 'concert', 'weekend', 'adventure'];
            const lowerMessage = message.toLowerCase();

            for (const keyword of keywords) {
                if (lowerMessage.includes(keyword)) {
                    return keyword;
                }
            }

            // Default to lifestyle images if no keyword found
            return 'lifestyle';
        }

        // Simulator Control Functions
        async function sendSimulatorMessage() {
            const messageInput = document.getElementById('sim-message');
            const message = messageInput.value.trim();
            const includeImage = document.getElementById('include-image').checked;
            const personaId = document.getElementById('simulator-persona').value;
            const rudenessLevel = document.getElementById('rudeness-slider').value;
            const maxMessages = document.getElementById('max-messages').value;
            const responseStyle = document.getElementById('response-style').value;

            if (!message) {
                logToConsole('Error: Message cannot be empty', 'error', 'app');
                return;
            }

            const messageData = {
                type: 'test-send-message',
                message: message,  // Fix: App expects 'message', not 'content'
                content: message,  // Keep for backward compatibility
                persona: personaId ? (SIMULATOR_PERSONAS && SIMULATOR_PERSONAS[personaId] ? SIMULATOR_PERSONAS[personaId] : { name: personaId, id: personaId }) : null,
                testingParams: {
                    rudenessLevel: parseInt(rudenessLevel),
                    maxMessages: parseInt(maxMessages),
                    responseStyle: responseStyle
                }
            };

            // Add contextual image if checkbox is checked
            if (includeImage) {
                const searchQuery = getImageSearchQuery(message);
                // Use Unsplash Source API with contextual search
                messageData.imageUrl = `https://source.unsplash.com/400x300/?${searchQuery}`;
                logToConsole(`Including contextual image (${searchQuery}) in message`, 'info', 'app');
            }

            // Post message to iframe
            const iframe = document.getElementById('live-app-iframe');
            iframe.contentWindow.postMessage(messageData, '*');

            const personaName = personaId ? (SIMULATOR_PERSONAS && SIMULATOR_PERSONAS[personaId] ? SIMULATOR_PERSONAS[personaId].name : personaId) : 'User';
            const params = `Style: ${responseStyle}, Rudeness: ${rudenessLevel}`;
            logToConsole(`Sent message from ${personaName}: "${message}"${includeImage ? ' (with contextual image)' : ''} [${params}]`, 'info', 'app');
            messageInput.value = '';
        }


        function exportChat() {
            const iframe = document.getElementById('live-app-iframe');

            // Request chat export from iframe
            iframe.contentWindow.postMessage({
                type: 'export-chat'
            }, '*');

            logToConsole('Exporting chat history...', 'info', 'app');
        }

        // ============================================
        // ADVANCED TESTING FEATURES
        // ============================================

        // Update delay slider value display
        function updateDelayValue(value) {
            document.getElementById('delay-value').textContent = value;
        }

        // Automation state management
        let autoConversationInterval = null;
        let autoMessageCount = 0;
        let autoTargetCount = 0;
        let testMetrics = {
            messagesSent: 0,
            responseTimes: [],
            startTime: null,
            lastMessageTime: null,
            engagementScore: 0,
            detectedMood: 'neutral'
        };

        // Conversation templates with pre-built message flows
        const CONVERSATION_TEMPLATES = {
            'first-date': [
                "Hi! It's nice to finally meet you ",
                "What kind of things do you enjoy doing on weekends?",
                "That sounds fun! Do you have any favorite spots in the city?",
                "I'd love to hear more about that sometime!"
            ],
            'deep-talk': [
                "What's something you're really passionate about?",
                "That's fascinating. What drew you to that initially?",
                "Do you think that's shaped who you are today?",
                "What's a belief you used to have that you've changed your mind about?"
            ],
            'flirty': [
                "You have such a great vibe! ",
                "What's your idea of a perfect date?",
                "I have to admit, I'm really enjoying talking with you",
                "So when are we making this happen? "
            ],
            'getting-to-know': [
                "Tell me something interesting about yourself!",
                "What's been the highlight of your week so far?",
                "If you could travel anywhere right now, where would you go?",
                "What's something that always makes you smile?"
            ]
        };

        // Start automated conversation with specified message count
        async function startAutoConversation(count) {
            if (autoConversationInterval) {
                logToConsole(' Automation already running. Stop current run first.', 'warn', 'app');
                return;
            }

            autoTargetCount = count;
            autoMessageCount = 0;
            testMetrics.startTime = Date.now();
            testMetrics.messagesSent = 0;
            testMetrics.responseTimes = [];

            const delaySeconds = parseInt(document.getElementById('message-delay').value);
            // Fix: getNextNaturalMessage() is a function that returns a string, not an object with .messages
            // Get the natural messages array directly from the test functions
            const naturalMessages = window.NATURAL_TEST_MESSAGES || [
                "Hey! How's your day going?",
                "What do you think about trying something new this weekend?", 
                "I've been thinking about taking up a new hobby",
                "Have you seen any good movies lately?",
                "What's your favorite way to spend a Saturday?",
                "I'm curious about your thoughts on creativity",
                "Do you enjoy exploring new places?",
                "What kind of music do you like?",
                "I find it interesting how people connect",
                "What makes you feel most alive?"
            ];

            logToConsole(` Starting automated conversation: ${count} messages with ${delaySeconds}s delay`, 'info', 'app');
            updateMetrics();

            autoConversationInterval = setInterval(async () => {
                if (autoMessageCount >= autoTargetCount) {
                    stopAutoConversation();
                    return;
                }

                // Get next message from natural conversation flow
                const messageIndex = autoMessageCount % naturalMessages.length;
                const message = naturalMessages[messageIndex] || `Test message ${autoMessageCount + 1}`;

                // Set the message in the input and send it
                const messageInput = document.getElementById('sim-message');
                messageInput.value = message;

                const sendStartTime = Date.now();
                await sendSimulatorMessage();

                // Track metrics
                autoMessageCount++;
                testMetrics.messagesSent++;
                testMetrics.lastMessageTime = Date.now();

                // Simulate response time tracking (in real scenario, would track actual bot response)
                const responseTime = Math.random() * 2000 + 500; // 0.5-2.5s
                testMetrics.responseTimes.push(responseTime);

                updateMetrics();

                logToConsole(` Auto-sent message ${autoMessageCount}/${autoTargetCount}`, 'info', 'app');
            }, delaySeconds * 1000);
        }

        // Stop automated conversation
        function stopAutoConversation() {
            if (autoConversationInterval) {
                clearInterval(autoConversationInterval);
                autoConversationInterval = null;
                logToConsole(` Automation stopped. Sent ${autoMessageCount}/${autoTargetCount} messages`, 'info', 'app');

                // Final metrics update
                updateMetrics();
            }
        }

        // Load conversation template
        function loadTemplate(templateType) {
            const template = CONVERSATION_TEMPLATES[templateType];

            if (!template) {
                logToConsole(` Template "${templateType}" not found`, 'warn', 'app');
                return;
            }

            // Stop any running automation
            if (autoConversationInterval) {
                stopAutoConversation();
            }

            logToConsole(` Loading "${templateType}" template (${template.length} messages)`, 'info', 'app');

            // Override the natural message flow temporarily
            const originalMessages = getNextNaturalMessage.messages;
            getNextNaturalMessage.messages = [...template];

            // Start automated conversation with template length
            setTimeout(() => {
                startAutoConversation(template.length);

                // Restore original messages after template completes
                setTimeout(() => {
                    getNextNaturalMessage.messages = originalMessages;
                }, template.length * parseInt(document.getElementById('message-delay').value) * 1000 + 1000);
            }, 100);
        }

        // Update live metrics display
        function updateMetrics() {
            // Update messages sent
            document.getElementById('metric-messages').textContent = testMetrics.messagesSent;

            // Calculate and display average response time
            if (testMetrics.responseTimes.length > 0) {
                const avgResponseTime = testMetrics.responseTimes.reduce((a, b) => a + b, 0) / testMetrics.responseTimes.length;
                document.getElementById('metric-response-time').textContent = `${(avgResponseTime / 1000).toFixed(2)}s`;
            } else {
                document.getElementById('metric-response-time').textContent = '--';
            }

            // Calculate engagement score (0-100 based on response time and message count)
            if (testMetrics.messagesSent > 0) {
                const avgResponseTime = testMetrics.responseTimes.length > 0
                    ? testMetrics.responseTimes.reduce((a, b) => a + b, 0) / testMetrics.responseTimes.length
                    : 1000;

                // Lower response time = higher engagement
                // More messages = higher engagement
                const responseScore = Math.max(0, 100 - (avgResponseTime / 30)); // Max 3s for good score
                const messageScore = Math.min(100, testMetrics.messagesSent * 5); // Cap at 100
                testMetrics.engagementScore = Math.round((responseScore + messageScore) / 2);

                document.getElementById('metric-engagement').textContent = `${testMetrics.engagementScore}/100`;
            } else {
                document.getElementById('metric-engagement').textContent = '--';
            }

            // Detect mood based on rudeness level and response style
            const rudenessLevel = parseInt(document.getElementById('rudeness-slider').value);
            const responseStyle = document.getElementById('response-style').value;

            if (rudenessLevel > 70) {
                testMetrics.detectedMood = ' Confrontational';
            } else if (rudenessLevel > 50) {
                testMetrics.detectedMood = ' Neutral';
            } else if (responseStyle === 'flirty') {
                testMetrics.detectedMood = ' Flirty';
            } else if (responseStyle === 'friendly') {
                testMetrics.detectedMood = ' Friendly';
            } else if (responseStyle === 'deep') {
                testMetrics.detectedMood = ' Thoughtful';
            } else if (responseStyle === 'humorous') {
                testMetrics.detectedMood = ' Playful';
            } else {
                testMetrics.detectedMood = ' Casual';
            }

            document.getElementById('metric-mood').textContent = testMetrics.detectedMood;
        }

        // Save current test scenario configuration
        function saveScenario() {
            const scenarioName = document.getElementById('scenario-name').value.trim();

            if (!scenarioName) {
                logToConsole(' Please enter a scenario name', 'warn', 'app');
                return;
            }

            // Collect current configuration
            const scenario = {
                name: scenarioName,
                timestamp: new Date().toISOString(),
                config: {
                    rudenessLevel: parseInt(document.getElementById('rudeness-slider').value),
                    maxMessages: parseInt(document.getElementById('max-messages').value),
                    responseStyle: document.getElementById('response-style').value,
                    messageDelay: parseInt(document.getElementById('message-delay').value),
                    persona: document.getElementById('simulator-persona').value,
                    includeImage: document.getElementById('include-image').checked
                },
                metrics: { ...testMetrics }
            };

            // Save to localStorage, replacing existing scenario with same name
            let savedScenarios = JSON.parse(localStorage.getItem('cupido-test-scenarios') || '[]');
            
            // Check if scenario with same name exists
            const existingIndex = savedScenarios.findIndex(s => s.name === scenarioName);
            if (existingIndex !== -1) {
                if (confirm(`Scenario "${scenarioName}" already exists. Overwrite it?`)) {
                    savedScenarios[existingIndex] = scenario;
                    logToConsole(` Updated scenario: "${scenarioName}"`, 'success', 'app');
                } else {
                    return; // User cancelled overwrite
                }
            } else {
                savedScenarios.push(scenario);
                logToConsole(` Saved scenario: "${scenarioName}"`, 'success', 'app');
            }
            
            localStorage.setItem('cupido-test-scenarios', JSON.stringify(savedScenarios));

            // Update dropdown
            updateScenarioDropdown();

            // Clear scenario name input
            document.getElementById('scenario-name').value = '';
        }

        // Load saved test scenario
        function loadScenario(scenarioName) {
            if (!scenarioName) return;

            const savedScenarios = JSON.parse(localStorage.getItem('cupido-test-scenarios') || '[]');
            const scenario = savedScenarios.find(s => s.name === scenarioName);

            if (!scenario) {
                logToConsole(` Scenario "${scenarioName}" not found`, 'warn', 'app');
                return;
            }

            // Apply configuration
            const config = scenario.config;
            document.getElementById('rudeness-slider').value = config.rudenessLevel;
            updateRudenessValue(config.rudenessLevel);
            document.getElementById('max-messages').value = config.maxMessages;
            document.getElementById('response-style').value = config.responseStyle;
            document.getElementById('message-delay').value = config.messageDelay;
            updateDelayValue(config.messageDelay);
            document.getElementById('simulator-persona').value = config.persona;
            document.getElementById('include-image').checked = config.includeImage;

            logToConsole(` Loaded scenario: "${scenarioName}"`, 'success', 'app');
            logToConsole(`Config: Rudeness=${config.rudenessLevel}, Style=${config.responseStyle}, Delay=${config.messageDelay}s`, 'info', 'app');
        }

        // Update scenario dropdown with saved scenarios
        function updateScenarioDropdown() {
            const savedScenarios = JSON.parse(localStorage.getItem('cupido-test-scenarios') || '[]');
            const dropdown = document.getElementById('saved-scenarios');

            // Clear existing options (except first one)
            dropdown.innerHTML = '<option value="">Load scenario...</option>';

            // Add saved scenarios
            savedScenarios.forEach(scenario => {
                const option = document.createElement('option');
                option.value = scenario.name;
                option.textContent = `${scenario.name} (${new Date(scenario.timestamp).toLocaleDateString()})`;
                dropdown.appendChild(option);
            });
        }

        // Export comprehensive test results
        function exportTestResults() {
            const testResults = {
                exportDate: new Date().toISOString(),
                testConfiguration: {
                    rudenessLevel: parseInt(document.getElementById('rudeness-slider').value),
                    maxMessages: parseInt(document.getElementById('max-messages').value),
                    responseStyle: document.getElementById('response-style').value,
                    messageDelay: parseInt(document.getElementById('message-delay').value),
                    persona: document.getElementById('simulator-persona').value,
                    includeImage: document.getElementById('include-image').checked
                },
                metrics: {
                    ...testMetrics,
                    averageResponseTime: testMetrics.responseTimes.length > 0
                        ? testMetrics.responseTimes.reduce((a, b) => a + b, 0) / testMetrics.responseTimes.length
                        : 0,
                    totalDuration: testMetrics.startTime ? Date.now() - testMetrics.startTime : 0
                },
                testHistory: testLogger.getHistory() || [],
                consoleLog: consoleMessages.slice(-100) || [] // Last 100 console messages
            };

            // Create downloadable JSON file
            const dataStr = JSON.stringify(testResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cupido-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            logToConsole(' Test results exported successfully', 'success', 'app');
            logToConsole(`Exported: ${testMetrics.messagesSent} messages, ${(testLogger.getHistory() || []).length} tests, ${(consoleMessages || []).length} log entries`, 'info', 'app');
        }

        // Initialize scenarios dropdown on load
        function initializeAdvancedFeatures() {
            updateScenarioDropdown();

            // Update metrics display periodically
            setInterval(() => {
                if (autoConversationInterval || testMetrics.messagesSent > 0) {
                    updateMetrics();
                }
            }, 1000);
        }

        // ============================================
        // END ADVANCED TESTING FEATURES
        // ============================================

        // ============================================
        // SELF-HEALING TEST MONITOR
        // ============================================

        let autoHealerInterval = null;
        let lastFailureCheck = null;

        function initializeAutoHealer() {
            // Check for existing failures on initialization
            checkFailuresApi();
            
            // Start polling every 15 seconds
            autoHealerInterval = setInterval(checkFailuresApi, 15000);
            
            logToConsole(' Auto-healer monitoring started (15s interval)', 'info', 'dashboard');
        }

        async function checkFailuresApi() {
            try {
                const response = await fetch('/api/test-results/failures');
                if (!response.ok) return;
                
                const failures = await response.json();
                
                if (failures.failedTests && failures.failedTests.length > 0) {
                    // Skip if we've already processed this timestamp
                    if (lastFailureCheck === failures.timestamp) return;
                    
                    lastFailureCheck = failures.timestamp;
                    showAutoHealerNotification(failures);
                }
            } catch (error) {
                // Silently fail - don't spam console with connection errors
            }
        }

        function showAutoHealerNotification(failures) {
            const count = failures.failedTests.length;
            const total = failures.totalTests;
            
            logToConsole(''.repeat(60), 'warning');
            logToConsole(' SELF-HEALING SYSTEM ALERT', 'error', 'dashboard');
            logToConsole(''.repeat(60), 'warning');
            logToConsole(`Found ${count} failed tests out of ${total} total`, 'error', 'dashboard');
            
            // Show brief summary of failed tests
            failures.failedTests.slice(0, 3).forEach(test => {
                logToConsole(` ${test.id}: ${test.name}`, 'error', 'dashboard');
            });
            
            if (failures.failedTests.length > 3) {
                logToConsole(`... and ${failures.failedTests.length - 3} more`, 'warning', 'dashboard');
            }
            
            logToConsole('', 'info');
            logToConsole(' CLAUDE CODE INTEGRATION AVAILABLE:', 'info', 'dashboard');
            logToConsole('1. Go to Scripts tab  Run "generate-claude-prompt.js"', 'info', 'dashboard');
            logToConsole('2. Copy the generated prompt to Claude Code', 'info', 'dashboard');
            logToConsole('3. Claude will analyze and suggest intelligent fixes', 'info', 'dashboard');
            logToConsole('', 'info');
            logToConsole('This provides AI-powered root cause analysis and fixes.', 'success', 'dashboard');
            logToConsole(''.repeat(60), 'warning');
        }

        function stopAutoHealer() {
            if (autoHealerInterval) {
                clearInterval(autoHealerInterval);
                autoHealerInterval = null;
                logToConsole(' Auto-healer monitoring stopped', 'warning', 'dashboard');
            }
        }

        // ============================================
        // END SELF-HEALING TEST MONITOR  
        // ============================================

        function updateClaudeStatus(status, message) {
            claudeStatus = status;
            const statusDot = document.getElementById('claude-status-dot');
            const statusText = document.getElementById('claude-status-text');

            // Only update if elements exist (they were removed in console simplification)
            if (statusDot) {
                statusDot.className = 'status-dot ' + status;
            }
            if (statusText) {
                statusText.textContent = message || status.charAt(0).toUpperCase() + status.slice(1);
            }

            logToConsole(`Claude Code: ${message || status}`, status === 'idle' ? 'info' : 'success', 'app');
        }

        // Monitor console errors from iframe
        function setupConsoleMonitoring() {
            // Listen for messages from the iframe
            window.addEventListener('message', (event) => {
                if (!event.data || !event.data.type) return;

                switch (event.data.type) {
                    case 'console':
                        const { level, message } = event.data;
                        logToConsole(`[APP] ${message}`, level, 'app');
                        break;

                    case 'app-console-log':
                        // App console forwarding
                        const logLevel = event.data.level === 'error' ? 'error' :
                                       event.data.level === 'warn' ? 'warn' : 'info';
                        logToConsole(`[APP] ${event.data.message}`, logLevel, 'app');
                        break;

                    case 'api-call':
                        // Log API calls from the app
                        const { url, method, duration, status } = event.data;
                        logToConsole(`API Call: ${method} ${url} - ${status} (${duration}ms)`, 'info', 'app');
                        // Track to current test's API calls if a test is running
                        const targetArray = currentTest ? window.currentTestApiCalls : null;
                        trackApiCall(url, method, event.data.body, event.data.response, duration, targetArray);
                        break;

                    case 'message-sent':
                        // Log when user sends a message
                        logToConsole(`User sent message: "${event.data.message}"`, 'info', 'app');
                        break;

                    case 'message-received':
                        // Log when AI response is received
                        logToConsole(`AI response received (${event.data.duration}ms)`, 'success', 'app');
                        break;

                    case 'chat-export':
                        // Handle exported chat data
                        const chatData = event.data.data;
                        downloadChatExport(chatData);
                        logToConsole('Chat exported successfully', 'success', 'app');
                        break;

                    case 'cupido-message':
                        // Handle messages from Cupido app
                        if (simulatorState.isActive && event.data.sender === 'user') {
                            logToConsole(`[CUPIDO USER] ${event.data.message}`, 'info', 'app');
                            // Auto-generate simulator response after a delay
                            handleCupidoMessage(event.data.message);
                        }
                        break;
                    
                    case 'simulator-response':
                        // Handle simulator responses - Fix: App sends 'message', not 'response'
                        const response = event.data.message || event.data.response;
                        logToConsole(`[SIMULATOR] ${response}`, 'info', 'app');
                        break;

                    case 'app-error':
                        logToConsole(`[ERROR] ${event.data.error}`, 'error', 'app');
                        break;

                    case 'app-info':
                        logToConsole(`[INFO] ${event.data.message}`, 'info', 'app');
                        break;

                    case 'chat-exported':
                        // Handle chat export response from TestBridge
                        const chatData = event.data.payload;
                        if (chatData && event.data.success) {
                            logToConsole(` Chat exported: ${chatData.messageCount} messages`, 'success', 'app');
                        } else {
                            logToConsole(' Chat export failed', 'error', 'app');
                        }
                        break;
                }
            });

            // Simulate Claude Code status changes for demo
            // In production, this would be connected to actual backend
            setInterval(() => {
                if (Math.random() > 0.95) {
                    const statuses = [
                        { status: 'analyzing', message: 'Analyzing code...' },
                        { status: 'fixing', message: 'Applying fixes...' },
                        { status: 'testing', message: 'Running tests...' }
                    ];
                    const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
                    updateClaudeStatus(randomStatus.status, randomStatus.message);

                    setTimeout(() => {
                        updateClaudeStatus('idle', 'Idle');
                    }, 3000);
                }
            }, 10000);
        }

        // Download chat export
        function downloadChatExport(chatData) {
            const dataStr = JSON.stringify(chatData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cupido-chat-export-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Add keyboard support for simulator message input
        function setupKeyboardShortcuts() {
            const messageInput = document.getElementById('sim-message');
            if (messageInput) {
                messageInput.addEventListener('keydown', (e) => {
                    // Send on Enter (without Shift for new line)
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendSimulatorMessage();
                    }
                });
            }
        }

        // Initialize Live Preview
        function initializeLivePreview() {
            setupConsoleMonitoring();
            setupKeyboardShortcuts();
            loadSimulatorPersonas(); // Load simulator prompts from Supabase
            logToConsole('Live Preview initialized', 'success', 'app');
            logToConsole('Monitoring console output from app...', 'info', 'app');
            logToConsole('Simulator controls ready for testing', 'info', 'app');
        }

        // Flag to prevent duplicate simulator personas loading
        let simulatorPersonasInitialized = false;

        // Load simulator-tagged prompts for persona selector
        async function loadSimulatorPersonas() {
            if (simulatorPersonasInitialized) {
                return; // Prevent duplicate initialization
            }
            simulatorPersonasInitialized = true;
            try {
                const response = await fetch('/api/prompts');
                if (!response.ok) throw new Error('Failed to load prompts');

                const allPrompts = await response.json();

                // Filter for simulator-tagged prompts only
                const simulatorPrompts = allPrompts.filter(p =>
                    p.tags && p.tags.includes('simulator')
                );

                // Populate the persona selector
                const personaSelect = document.getElementById('simulator-persona');
                if (personaSelect) {
                    // Clear existing options except the first "Select persona..."
                    personaSelect.innerHTML = '<option value="">Select persona...</option>';

                    // Add simulator prompts as options
                    simulatorPrompts.forEach(prompt => {
                        const option = document.createElement('option');
                        option.value = prompt.prompt_id;
                        option.textContent = `${prompt.prompt_name} (v${prompt.active_version || prompt.version_string})`;
                        option.dataset.promptData = JSON.stringify({
                            id: prompt.prompt_id,
                            name: prompt.prompt_name,
                            description: prompt.description || '',
                            systemPrompt: prompt.system_prompt,
                            version: prompt.active_version || prompt.version_string
                        });
                        personaSelect.appendChild(option);
                    });

                    if (simulatorPrompts.length === 0) {
                        personaSelect.innerHTML = '<option value="">No simulator personas available</option>';
                        logToConsole('No simulator personas found. Create prompts with "simulator" tag.', 'warn', 'app');
                    } else {
                        logToConsole(`Loaded ${simulatorPrompts.length} simulator persona(s) from Supabase`, 'success', 'app');
                    }
                }
            } catch (error) {
                console.error('Failed to load simulator personas:', error);
                logToConsole('Failed to load simulator personas from Supabase, using fallback', 'warn', 'app');
                
                // Fallback to hardcoded personas
                const personaSelect = document.getElementById('simulator-persona');
                if (personaSelect && typeof SIMULATOR_PERSONAS !== 'undefined') {
                    personaSelect.innerHTML = '<option value="">Select persona...</option>';
                    Object.keys(SIMULATOR_PERSONAS).forEach(personaId => {
                        const persona = SIMULATOR_PERSONAS[personaId];
                        const option = document.createElement('option');
                        option.value = personaId;
                        option.textContent = `${persona.name} (fallback)`;
                        personaSelect.appendChild(option);
                    });
                    logToConsole(`Loaded ${Object.keys(SIMULATOR_PERSONAS).length} fallback persona(s)`, 'success', 'app');
                } else {
                    simulatorPersonasInitialized = false; // Reset on error to allow retry
                }
            }
        }

        // Update test scope dropdown with actual counts
        function updateTestScopeDropdown() {
            const dropdown = document.getElementById('test-scope');
            if (!dropdown) return;
            
            // Update "All Tests" option
            const allOption = dropdown.querySelector('option[value="all"]');
            if (allOption) {
                allOption.textContent = `All Tests (${tests.length})`;
            }
            
            // Update category counts
            Object.keys(testConfig).forEach(category => {
                const option = dropdown.querySelector(`option[value="${category}"]`);
                if (option) {
                    option.textContent = `${testConfig[category].name} (${testConfig[category].count})`;
                }
            });
        }

        // Error monitoring functions
        async function loadErrorStats() {
            try {
                const response = await fetch('/api/error-stats');
                const stats = await response.json();
                
                document.getElementById('errors-24h').textContent = stats.last24h;
                document.getElementById('errors-week').textContent = stats.lastWeek;
                
                const autoFixed = stats.topErrors.filter(e => e.autoFixed).length;
                document.getElementById('errors-fixed').textContent = autoFixed;
                
                const critical = stats.topErrors.filter(e => !e.autoFixed).length;
                document.getElementById('errors-critical').textContent = critical;
                
                // Render error patterns
                const patternsContainer = document.getElementById('error-patterns-list');
                if (stats.patterns.length === 0) {
                    patternsContainer.innerHTML = '<div class="loading">No error patterns detected</div>';
                } else {
                    patternsContainer.innerHTML = stats.patterns.slice(0, 10).map(pattern => `
                        <div class="error-item">
                            <div class="error-message">${escapeHtml(pattern.pattern)}</div>
                            <div>
                                <span class="error-count-badge">${pattern.count}</span>
                                <span class="error-timestamp">${new Date(pattern.lastSeen).toLocaleString()}</span>
                            </div>
                        </div>
                    `).join('');
                }
                
                // Render recent errors
                const errorsContainer = document.getElementById('recent-errors-list');
                if (stats.topErrors.length === 0) {
                    errorsContainer.innerHTML = '<div class="loading">No recent errors</div>';
                } else {
                    errorsContainer.innerHTML = stats.topErrors.map(error => `
                        <div class="error-item">
                            <div class="error-message">${escapeHtml(error.message)}</div>
                            <div>
                                ${error.autoFixed ? '<span class="auto-fix-badge">Auto-Fixed</span>' : ''}
                                <span class="error-timestamp">${new Date(error.timestamp).toLocaleString()}</span>
                            </div>
                        </div>
                    `).join('');
                }
                
            } catch (error) {
                console.error('Failed to load error stats:', error);
                document.getElementById('errors-24h').textContent = 'Error';
                document.getElementById('errors-week').textContent = 'Error';
                document.getElementById('errors-fixed').textContent = 'Error';
                document.getElementById('errors-critical').textContent = 'Error';
            }
        }

        // HTML escaping function to prevent XSS
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe;
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Tab switching functionality integrated into main switchTab function

        // BROWSER DEBUG FUNCTION - Co-founder level debugging
        function runBrowserDebug() {
            logToConsole(' BROWSER DEBUG STARTING...', 'info');
            logToConsole('', 'info');
            
            // Check TEST_FUNCTIONS availability
            logToConsole(` window.TEST_FUNCTIONS available: ${!!window.TEST_FUNCTIONS}`, 'info');
            if (window.TEST_FUNCTIONS) {
                const functionCount = Object.keys(window.TEST_FUNCTIONS).length;
                logToConsole(` TEST_FUNCTIONS count: ${functionCount}`, 'success');
                logToConsole(` First few functions: ${Object.keys(window.TEST_FUNCTIONS).slice(0, 5).join(', ')}`, 'info');
            } else {
                logToConsole(' TEST_FUNCTIONS is not available', 'error');
            }
            
            // Check tests array
            logToConsole(` tests array length: ${tests ? tests.length : 'tests array not found'}`, 'info');
            
            // Check DOM elements
            logToConsole(' DOM elements:', 'info');
            logToConsole(`  total-tests element: ${document.getElementById('total-tests')?.textContent}`, 'info');
            logToConsole(`  passed-tests element: ${document.getElementById('passed-tests')?.textContent}`, 'info');
            logToConsole(`  pending-tests element: ${document.getElementById('pending-tests')?.textContent}`, 'info');
            
            // Check testConfig
            logToConsole(' testConfig:', 'info');
            if (typeof testConfig !== 'undefined') {
                const totalFromConfig = Object.values(testConfig).reduce((sum, cat) => sum + cat.count, 0);
                logToConsole(`  testConfig total: ${totalFromConfig}`, 'info');
                logToConsole(`  testConfig categories: ${Object.keys(testConfig).length}`, 'info');
            } else {
                logToConsole('  testConfig not found', 'error');
            }
            
            // Check script tags
            logToConsole(' Checking script tags:', 'info');
            const scripts = document.querySelectorAll('script[src]');
            scripts.forEach((script, i) => {
                logToConsole(`  Script ${i + 1}: ${script.src}`, 'info');
            });
            
            // Manual initialization test
            logToConsole(' Manual initialization test:', 'info');
            if (typeof initializeTests === 'function') {
                logToConsole(' initializeTests function exists', 'success');
                logToConsole(' Calling initializeTests manually...', 'info');
                
                // Clear and reinitialize
                tests.length = 0;
                initializeTests();
                renderTestTable();
                updateStats();
                
                logToConsole(` After manual call - tests array length: ${tests ? tests.length : 'tests array not found'}`, 'info');
            } else {
                logToConsole(' initializeTests function not found', 'error');
            }
            
            logToConsole('', 'info');
            logToConsole(' BROWSER DEBUG COMPLETE', 'info');
            logToConsole(' Check console output above for detailed analysis', 'warning');
        }

        // Capture JavaScript errors
        window.jsErrors = [];
        window.addEventListener('error', (event) => {
            const errorMsg = `${event.error?.message || event.message} at ${event.filename}:${event.lineno}`;
            window.jsErrors.push(errorMsg);
            logToConsole(` JS Error: ${errorMsg}`, 'error');
        });

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initializeTests();
            updateTestScopeDropdown();
            renderTestTable();
            loadSimulatorPersonas();
            
            // Initialize URL routing
            initializeUrlRouting();
            
            logToConsole('Cupido Test Dashboard initialized', 'info');
            logToConsole(`${tests.length} tests loaded across ${Object.keys(testConfig).length} categories`, 'info');
            logToConsole('Test logging enabled - all runs saved to localStorage', 'info');

            // Show previous test count
            const history = testLogger.getHistory();
            if (history.length > 0) {
                logToConsole(`Found ${history.length} previous test run(s) in history`, 'info');
            }

            // Show available console commands
            logToConsole('', 'info');
            logToConsole('=== Available Console Commands ===', 'info');
            logToConsole('showHistory()           - View all previous test runs', 'info');
            logToConsole('exportLogs()            - Download logs as JSON file', 'info');
            logToConsole('clearHistory()          - Clear all stored test logs', 'info');
            logToConsole('autoFixFailures()       - Auto-fix failed tests with Claude', 'info');
            logToConsole('', 'info');

            // Initialize live preview
            initializeLivePreview();

            // Initialize advanced testing features
            initializeAdvancedFeatures();
            logToConsole('Advanced testing features ready: Automation, Templates, Metrics, Scenarios', 'success', 'app');

            // Initialize self-healing monitor
            initializeAutoHealer();
            logToConsole(' Self-healing test monitor initialized', 'success', 'dashboard');
            
            // Auto-run debug after initial load to help diagnose issues
            setTimeout(() => {
                logToConsole(' Auto-running debug analysis after page load...', 'warning');
                runBrowserDebug();
            }, 3000);
            
            // Infrastructure tests available for manual execution
            logToConsole('  Infrastructure validation tests ready for manual execution', 'info');
            logToConsole('Use the Tests tab to run infrastructure tests when needed', 'info');
        });

        // ============================================================
        // PROMPT LIBRARY FUNCTIONALITY
        // ============================================================

        // State management for Prompt Library
        const promptLibraryState = {
            allPrompts: [],
            filteredPrompts: [],
            selectedPrompt: null,
            selectedVersionHistory: [],
            currentVersionIndex: 0,
            selectedVersionType: 'patch',
            isDirty: false
        };

        // Initialize Prompt Library when tab is clicked
        function initializePromptLibrary() {
            loadPrompts();
            setupPromptLibraryEventListeners();
        }

        // Load all prompts from API
        async function loadPrompts() {
            try {
                const response = await fetch('/api/prompts');
                if (!response.ok) throw new Error('Failed to load prompts');

                const data = await response.json();
                // API returns array directly, not {prompts: []}
                // Map API fields to expected format
                promptLibraryState.allPrompts = (Array.isArray(data) ? data : []).map(p => ({
                    id: p.prompt_id,
                    prompt_id: p.prompt_id,
                    prompt_name: p.prompt_name,
                    version_string: p.active_version || '1.0.0',
                    system_prompt: p.system_prompt,
                    description: p.description,
                    is_visible: p.is_active !== false, // Default to visible if not specified
                    is_active: p.is_active,
                    is_default: p.is_default,
                    tags: p.tags || [],
                    category: p.category,
                    status: p.is_active ? 'active' : 'draft'
                }));
                filterAndRenderPrompts();
            } catch (error) {
                console.error('Error loading prompts:', error);
                document.getElementById('prompt-list').innerHTML =
                    '<div class="prompt-list-loading" style="color: #ff3b30;">Error loading prompts</div>';
            }
        }

        // Filter and render prompts based on search and filters
        function filterAndRenderPrompts() {
            const searchTerm = document.getElementById('prompt-search')?.value.toLowerCase() || '';

            // Get selected tags from checkboxes
            const selectedTags = Array.from(document.querySelectorAll('.tag-checkbox:checked'))
                .map(cb => cb.value);

            // Get selected statuses from checkboxes
            const selectedStatuses = Array.from(document.querySelectorAll('.status-checkbox:checked'))
                .map(cb => cb.value);

            promptLibraryState.filteredPrompts = promptLibraryState.allPrompts.filter(prompt => {
                const matchesSearch = !searchTerm || prompt.prompt_name.toLowerCase().includes(searchTerm);

                // If no tags selected, show all; otherwise, prompt must have at least one selected tag
                const matchesTag = selectedTags.length === 0 ||
                    (prompt.tags && prompt.tags.some(tag => selectedTags.includes(tag)));

                // If no statuses selected, show all; otherwise, prompt must match one of the selected statuses
                const matchesStatus = selectedStatuses.length === 0 ||
                    selectedStatuses.includes(prompt.status);

                return matchesSearch && matchesTag && matchesStatus;
            });

            renderPromptList();
        }

        // Render the prompt list in the sidebar
        function renderPromptList() {
            const listContainer = document.getElementById('prompt-list');

            if (promptLibraryState.filteredPrompts.length === 0) {
                listContainer.innerHTML = '<div class="prompt-list-loading">No prompts found</div>';
                return;
            }

            listContainer.innerHTML = promptLibraryState.filteredPrompts.map(prompt => {
                const isSelected = promptLibraryState.selectedPrompt?.prompt_id === prompt.id;
                const tags = prompt.tags || [];

                return `
                    <div class="prompt-item ${isSelected ? 'selected' : ''}" data-prompt-id="${prompt.id}">
                        <div class="prompt-item-header">
                            <div class="prompt-item-name">${prompt.prompt_name}</div>
                            <label class="toggle-switch" onclick="event.stopPropagation()">
                                <input type="checkbox" ${prompt.is_active ? 'checked' : ''}
                                       onchange="togglePromptActive('${prompt.id}', '${prompt.version_string}', this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="prompt-item-footer">
                            ${tags.map(tag => `<span class="prompt-tag ${tag}">${tag}</span>`).join('')}
                            <span class="prompt-version-badge">v${prompt.version_string}</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Add click handlers to prompt items
            document.querySelectorAll('.prompt-item').forEach(item => {
                item.addEventListener('click', () => {
                    const promptId = item.dataset.promptId;
                    selectPrompt(promptId);
                });
            });
        }

        // Toggle prompt activation
        async function togglePromptActive(promptId, versionString, isActive) {
            try {
                console.log(`Toggling ${promptId} v${versionString} to ${isActive ? 'active' : 'inactive'}`);

                const response = await fetch(`/api/prompts/${promptId}/toggle-active`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        versionString: versionString,
                        isActive: isActive
                    })
                });

                if (!response.ok) throw new Error('Failed to update activation');

                const result = await response.json();
                console.log(` ${result.message}`);

                // Update local state
                const prompt = promptLibraryState.allPrompts.find(p => p.id === promptId);
                if (prompt) {
                    prompt.is_active = isActive;
                    prompt.status = isActive ? 'active' : 'draft';
                }

                // If we're viewing this prompt's versions, reload them to see the change
                if (promptLibraryState.selectedPrompt?.prompt_id === promptId) {
                    await selectPrompt(promptId);
                }
            } catch (error) {
                console.error('Error updating activation:', error);
                // Reload prompts to reset the toggle
                await loadPrompts();
            }
        }

        // Select a prompt and display it
        async function selectPrompt(promptId) {
            console.log('Selecting prompt:', promptId);
            const prompt = promptLibraryState.allPrompts.find(p => p.id === promptId);

            if (!prompt) {
                console.error('Prompt not found:', promptId);
                return;
            }

            console.log('Found prompt:', prompt.prompt_name);

            try {
                // Fetch all versions of this prompt
                console.log('Fetching all versions for:', promptId);
                const response = await fetch(`/api/prompts/${promptId}/versions`);
                if (!response.ok) throw new Error('Failed to load versions');

                const versions = await response.json();
                console.log(`Loaded ${versions.length} versions:`, versions.map(v => v.version_string));

                // Map versions to expected format
                const mappedVersions = versions.map(v => ({
                    id: v.id,
                    prompt_id: v.prompt_id,
                    prompt_name: v.prompt_name,
                    version_string: v.version_string,
                    system_prompt: v.system_prompt,
                    description: v.description,
                    is_active: v.is_active,
                    is_visible: v.is_visible,
                    tags: v.tags || [],
                    category: v.category,
                    status: v.status,
                    major_version: v.major_version,
                    minor_version: v.minor_version,
                    patch_version: v.patch_version
                }));

                // Set as selected prompt
                promptLibraryState.selectedPrompt = mappedVersions[0]; // Most recent version first
                promptLibraryState.selectedVersionHistory = mappedVersions;
                promptLibraryState.currentVersionIndex = 0;

                renderPromptEditor();
                renderPromptList(); // Re-render to update selection
            } catch (error) {
                console.error('Error loading versions:', error);
                // Fallback to single version
                promptLibraryState.selectedPrompt = prompt;
                promptLibraryState.selectedVersionHistory = [prompt];
                promptLibraryState.currentVersionIndex = 0;
                renderPromptEditor();
                renderPromptList();
            }
        }

        // Navigate between versions
        function navigateVersion(direction) {
            const history = promptLibraryState.selectedVersionHistory;
            let newIndex = promptLibraryState.currentVersionIndex + direction;

            // Clamp to valid range
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= history.length) newIndex = history.length - 1;

            if (newIndex !== promptLibraryState.currentVersionIndex) {
                promptLibraryState.currentVersionIndex = newIndex;
                promptLibraryState.selectedPrompt = history[newIndex];
                renderPromptEditor();
                console.log(`Navigated to version ${newIndex + 1}/${history.length}: v${history[newIndex].version_string}`);
            }
        }

        // Render the prompt editor panel
        function renderPromptEditor() {
            const editorPanel = document.getElementById('prompt-editor-panel');
            const prompt = promptLibraryState.selectedPrompt;

            if (!prompt) {
                editorPanel.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"></div>
                        <h3>No Prompt Selected</h3>
                        <p>Select a prompt from the list or create a new one</p>
                    </div>
                `;
                return;
            }

            const canGoPrev = promptLibraryState.currentVersionIndex > 0;
            const canGoNext = promptLibraryState.currentVersionIndex < promptLibraryState.selectedVersionHistory.length - 1;

            editorPanel.innerHTML = `
                <!-- Header with version navigation -->
                <div class="prompt-editor-header">
                    <div class="prompt-editor-title">Prompt Editor</div>
                    <div class="version-navigator">
                        <button class="version-arrow" onclick="navigateVersion(-1)" ${!canGoPrev ? 'disabled' : ''}>
                            
                        </button>
                        <div class="version-display">v${prompt.version_string}</div>
                        <button class="version-arrow" onclick="navigateVersion(1)" ${!canGoNext ? 'disabled' : ''}>
                            
                        </button>
                        ${promptLibraryState.selectedVersionHistory.length > 1 ?
                            '<button class="btn btn-compare" onclick="openCompareModal()" style="margin-left: 12px; padding: 6px 12px; font-size: 13px;">Compare</button>' : ''}
                    </div>
                </div>

                <!-- Editor content -->
                <div class="prompt-editor-content">
                    <div class="form-group">
                        <label class="form-label">Prompt Name</label>
                        <input type="text" class="form-input" id="prompt-name-input"
                               value="${promptLibraryState.draftEdits?.name || prompt.prompt_name}" onchange="markDirty()">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" class="form-input" id="prompt-description-input"
                               value="${promptLibraryState.draftEdits?.description || prompt.description || ''}" onchange="markDirty()">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Tag (Use Case)</label>
                        <select class="form-input" id="prompt-tag-input" onchange="markDirty()">
                            <option value="cupido" ${(prompt.tags && prompt.tags.includes('cupido')) ? 'selected' : ''}>Cupido (Main App)</option>
                            <option value="simulator" ${(prompt.tags && prompt.tags.includes('simulator')) ? 'selected' : ''}>Simulator (Testing)</option>
                            <option value="extractor" ${(prompt.tags && prompt.tags.includes('extractor')) ? 'selected' : ''}>Extractor (Profile)</option>
                            <option value="money2020" ${(prompt.tags && prompt.tags.includes('money2020')) ? 'selected' : ''}>Money2020 (Demo)</option>
                            <option value="custom" ${(prompt.tags && prompt.tags.includes('custom')) ? 'selected' : ''}>Custom</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="prompt-default-input"
                                   ${prompt.is_default ? 'checked' : ''}
                                   onchange="markDirty()"
                                   style="width: auto; height: auto;">
                            <span>Set as default prompt for this tag</span>
                        </label>
                        <div style="font-size: 12px; color: #86868b; margin-top: 4px;">
                            Default prompt will be automatically selected when the app starts
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">System Prompt</label>
                        <textarea class="form-input form-textarea" id="prompt-text-input"
                                  onchange="markDirty()">${prompt.system_prompt}</textarea>
                    </div>
                </div>

                <!-- Actions -->
                <div class="prompt-editor-actions">
                    <div class="action-group">
                        <button class="btn btn-delete" onclick="deletePrompt()">Delete</button>
                    </div>
                    <div class="action-group">
                        <button class="btn btn-save-draft" onclick="saveDraft()">Save Draft</button>
                        <div class="version-selector">
                            <button class="version-type-btn ${promptLibraryState.selectedVersionType === 'patch' ? 'selected' : ''}"
                                    onclick="selectVersionType('patch')">Patch</button>
                            <button class="version-type-btn ${promptLibraryState.selectedVersionType === 'minor' ? 'selected' : ''}"
                                    onclick="selectVersionType('minor')">Minor</button>
                            <button class="version-type-btn ${promptLibraryState.selectedVersionType === 'major' ? 'selected' : ''}"
                                    onclick="selectVersionType('major')">Major</button>
                        </div>
                        <button class="btn btn-update-version" onclick="updateVersion()">Update Version</button>
                    </div>
                </div>
            `;
        }

        // Mark editor as dirty (has unsaved changes)
        function markDirty() {
            promptLibraryState.isDirty = true;
        }

        // Select version type for update
        function selectVersionType(type) {
            // Cache current form values before changing type
            if (promptLibraryState.selectedPrompt) {
                promptLibraryState.draftEdits = {
                    name: document.getElementById('prompt-name-input')?.value || '',
                    description: document.getElementById('prompt-description-input')?.value || '',
                    systemPrompt: document.getElementById('prompt-system-input')?.value || '',
                    tag: document.getElementById('prompt-tag-select')?.value || ''
                };
            }
            
            promptLibraryState.selectedVersionType = type;
            renderPromptEditor();
        }

        // Save draft without creating new version
        async function saveDraft() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt) return;

            const name = document.getElementById('prompt-name-input').value;
            const description = document.getElementById('prompt-description-input').value;
            const systemPrompt = document.getElementById('prompt-text-input').value;
            const tag = document.getElementById('prompt-tag-input').value;
            const isDefault = document.getElementById('prompt-default-input').checked;

            try {
                console.log('Saving draft for prompt:', prompt.prompt_id);
                const response = await fetch(`/api/prompts/${prompt.prompt_id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        promptName: name,         // Server expects camelCase
                        description: description,
                        systemPrompt: systemPrompt,  // Server expects camelCase
                        tags: [...(prompt.tags || []).filter(t => t !== tag), tag], // Preserve existing tags, update current
                        isDefault: isDefault,
                        commitMessage: 'Draft saved via dashboard'
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error:', response.status, errorText);
                    throw new Error(`Failed to save draft: ${response.status}`);
                }

                const data = await response.json();
                console.log('Draft saved response:', data);
                promptLibraryState.isDirty = false;
                await loadPrompts();
                console.log(' Draft saved successfully');
            } catch (error) {
                console.error('Error saving draft:', error);
                alert('Failed to save draft');
            }
        }

        // Update version (create new version)
        async function updateVersion() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt) return;

            const name = document.getElementById('prompt-name-input').value;
            const description = document.getElementById('prompt-description-input').value;
            const systemPrompt = document.getElementById('prompt-text-input').value;
            const tag = document.getElementById('prompt-tag-input').value;
            const isDefault = document.getElementById('prompt-default-input').checked;
            const versionType = promptLibraryState.selectedVersionType;

            try {
                console.log('Creating new version:', versionType, 'for prompt:', prompt.prompt_id);
                const response = await fetch(`/api/prompts/${prompt.prompt_id}/versions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        promptName: name,              // Server expects camelCase
                        systemPrompt: systemPrompt,    // Server expects camelCase
                        versionType: versionType,      // Server expects camelCase
                        tags: [...(prompt.tags || []).filter(t => t !== tag), tag], // Preserve existing tags, update current
                        isDefault: isDefault,
                        commitMessage: `${versionType} version update via dashboard`,
                        notes: description || '',
                        createdBy: 'dashboard',
                        activate: false
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error response:', response.status, errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText}`);
                }

                const data = await response.json();
                console.log('Server response:', data);
                promptLibraryState.isDirty = false;
                await loadPrompts();
                // Server returns versionId directly, not nested in .version
                if (data.prompt_id || data.versionId) {
                    await selectPrompt(data.prompt_id || data.versionId);
                }
                console.log(` New ${versionType} version created: v${data.version_string}`);
            } catch (error) {
                console.error('Error creating version:', error);
                alert(`Failed to create new version: ${error.message}`);
            }
        }

        // Delete current version
        async function deletePrompt() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt) return;

            // Check if version is active
            if (prompt.is_active) {
                alert(`Cannot delete active version!\n\nPlease deactivate v${prompt.version_string} before deleting it.`);
                return;
            }

            if (!confirm(`Delete version ${prompt.version_string} of "${prompt.prompt_name}"?\n\nThis cannot be undone.`)) {
                return;
            }

            try {
                console.log(`Deleting ${prompt.prompt_id} v${prompt.version_string}`);

                const response = await fetch(`/api/prompts/${prompt.prompt_id}/versions/${prompt.version_string}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to delete version');
                }

                const result = await response.json();
                console.log(` ${result.message}`);

                // Reload prompts and clear selection
                promptLibraryState.selectedPrompt = null;
                promptLibraryState.selectedVersionHistory = [];
                await loadPrompts();
                renderPromptEditor();

            } catch (error) {
                console.error('Error deleting version:', error);
                alert(`Failed to delete version: ${error.message}`);
            }
        }

        // Create new prompt
        async function createNewPrompt() {
            const name = prompt('Enter prompt name:');
            if (!name) return;

            try {
                const response = await fetch('/api/prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt_name: name,
                        system_prompt: 'Enter your system prompt here...',
                        description: ''
                    })
                });

                if (!response.ok) throw new Error('Failed to create prompt');

                const data = await response.json();
                await loadPrompts();
                await selectPrompt(data.prompt.id);
                console.log('New prompt created successfully');
            } catch (error) {
                console.error('Error creating prompt:', error);
                alert('Failed to create new prompt');
            }
        }

        // Setup event listeners for Prompt Library
        let promptLibraryListenersInitialized = false;

        function setupPromptLibraryEventListeners() {
            // Prevent duplicate listeners
            if (promptLibraryListenersInitialized) return;
            
            // Search input
            const searchInput = document.getElementById('prompt-search');
            if (searchInput) {
                searchInput.addEventListener('input', filterAndRenderPrompts);
            }

            // Filter button toggle
            const filterBtn = document.getElementById('filter-btn');
            const filterPanel = document.getElementById('filter-panel');
            if (filterBtn && filterPanel) {
                filterBtn.addEventListener('click', () => {
                    const isVisible = filterPanel.style.display !== 'none';
                    filterPanel.style.display = isVisible ? 'none' : 'grid';
                });
            }

            // Filter checkboxes
            const tagCheckboxes = document.querySelectorAll('.tag-checkbox');
            const statusCheckboxes = document.querySelectorAll('.status-checkbox');
            tagCheckboxes.forEach(cb => cb.addEventListener('change', filterAndRenderPrompts));
            statusCheckboxes.forEach(cb => cb.addEventListener('change', filterAndRenderPrompts));

            // New prompt button
            const newPromptBtn = document.getElementById('new-prompt-btn');
            if (newPromptBtn) {
                newPromptBtn.addEventListener('click', createNewPrompt);
            }
            
            promptLibraryListenersInitialized = true;
        }

        // ============================================================
        // COMPARE VERSIONS MODAL FUNCTIONALITY
        // ============================================================

        // Compare versions state
        let compareState = {
            fromVersion: null,
            toVersion: null,
            versions: []
        };

        // Open compare modal
        function openCompareModal() {
            const prompt = promptLibraryState.selectedPrompt;
            if (!prompt || !promptLibraryState.selectedVersionHistory) {
                alert('Please select a prompt first');
                return;
            }

            const versions = promptLibraryState.selectedVersionHistory;
            if (versions.length < 2) {
                alert('This prompt only has one version. Cannot compare.');
                return;
            }

            compareState.versions = versions;

            // Populate version selectors
            const fromSelect = document.getElementById('compare-from-version');
            const toSelect = document.getElementById('compare-to-version');

            fromSelect.innerHTML = versions.map((v, i) =>
                `<option value="${i}">${v.version_string}${v.is_active ? ' (active)' : ''}</option>`
            ).join('');

            toSelect.innerHTML = versions.map((v, i) =>
                `<option value="${i}">${v.version_string}${v.is_active ? ' (active)' : ''}</option>`
            ).join('');

            // Default: compare current vs previous (or latest vs previous)
            const currentIndex = promptLibraryState.currentVersionIndex || 0;
            const previousIndex = Math.min(currentIndex + 1, versions.length - 1);

            fromSelect.value = previousIndex;
            toSelect.value = currentIndex;

            compareState.fromVersion = versions[previousIndex];
            compareState.toVersion = versions[currentIndex];

            // Show modal
            document.getElementById('compare-modal').style.display = 'flex';

            // Update comparison
            updateComparison();
        }

        // Close compare modal
        function closeCompareModal() {
            document.getElementById('compare-modal').style.display = 'none';
        }

        // Update comparison when selectors change
        function updateComparison() {
            const fromIndex = parseInt(document.getElementById('compare-from-version').value);
            const toIndex = parseInt(document.getElementById('compare-to-version').value);

            compareState.fromVersion = compareState.versions[fromIndex];
            compareState.toVersion = compareState.versions[toIndex];

            renderComparison();
        }

        // Render the comparison with diff highlighting
        function renderComparison() {
            const from = compareState.fromVersion;
            const to = compareState.toVersion;

            // Update headers
            document.getElementById('compare-from-header').textContent =
                `v${from.version_string}${from.is_active ? ' (active)' : ''}`;
            document.getElementById('compare-to-header').textContent =
                `v${to.version_string}${to.is_active ? ' (active)' : ''}`;

            // Simple line-by-line diff
            const fromLines = (from.system_prompt || '').split('\n');
            const toLines = (to.system_prompt || '').split('\n');

            const fromHtml = generateDiffHtml(fromLines, toLines, 'from');
            const toHtml = generateDiffHtml(fromLines, toLines, 'to');

            document.getElementById('compare-from-content').innerHTML = fromHtml;
            document.getElementById('compare-to-content').innerHTML = toHtml;
        }

        // Generate diff HTML (simple line-based diff)
        function generateDiffHtml(fromLines, toLines, side) {
            const lines = side === 'from' ? fromLines : toLines;
            const otherLines = side === 'from' ? toLines : fromLines;

            let html = '';

            lines.forEach((line, i) => {
                let className = 'diff-unchanged';

                if (i >= otherLines.length) {
                    // Line was added/removed
                    className = side === 'from' ? 'diff-removed' : 'diff-added';
                } else if (line !== otherLines[i]) {
                    // Line was changed
                    if (side === 'from' && !toLines.includes(line)) {
                        className = 'diff-removed';
                    } else if (side === 'to' && !fromLines.includes(line)) {
                        className = 'diff-added';
                    } else {
                        className = 'diff-changed';
                    }
                }

                html += `<span class="diff-line ${className}">${escapeHtml(line)}\n</span>`;
            });

            return html;
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add prompt library initialization to the existing switchTab override
        // This should be combined with the error monitoring switchTab override above

        // ============================================================================
        // HEALTH CHECK FUNCTIONALITY
        // ============================================================================

        // System scripts and services configuration
        const SYSTEM_SCRIPTS = {
            coreServices: [
                {
                    name: 'server.js',
                    description: 'Main Express.js server with API endpoints and proxy configuration',
                    command: 'node server.js',
                    port: 3001,
                    category: 'Core Services',
                    essential: true
                },
                {
                    name: 'Expo Development Server',
                    description: 'React Native/Expo development server for main application',
                    command: 'npx expo start --web --port 8081',
                    port: 8081,
                    category: 'Core Services',
                    essential: true
                }
            ],
            automationScripts: [
                {
                    name: 'session-logger.js',
                    description: 'Automated session logging and CLAUDE.md context updates',
                    command: 'node session-logger.js',
                    status: 'ready',
                    category: 'Automation Scripts'
                },
                {
                    name: 'auto-remediation-service.js',
                    description: 'Background service for automatic test failure detection and fixing',
                    command: 'node auto-remediation-service.js start',
                    status: 'ready',
                    category: 'Automation Scripts'
                },
                {
                    name: 'auto-init.js',
                    description: 'Auto-initialization for Claude Code context loading',
                    command: 'node auto-init.js',
                    status: 'ready',
                    category: 'Automation Scripts'
                }
            ],
            revolutionarySystems: [
                {
                    name: 'prompt-analytics-engine.js',
                    description: 'Phase 2: Advanced prompt analytics with A/B testing and performance metrics',
                    command: 'node prompt-analytics-engine.js',
                    status: 'ready',
                    category: 'Revolutionary Systems'
                },
                {
                    name: 'prompt-template-engine.js',
                    description: 'Phase 2: Advanced template engine with Handlebars-style templating',
                    command: 'node prompt-template-engine.js',
                    status: 'ready',
                    category: 'Revolutionary Systems'
                },
                {
                    name: 'automation-workflow-engine.js',
                    description: 'Phase 3: Advanced automation workflow engine',
                    command: 'node automation-workflow-engine.js',
                    status: 'ready',
                    category: 'Revolutionary Systems'
                },
                {
                    name: 'production-deployment-pipeline.js',
                    description: 'Phase 3: Production deployment pipeline with CI/CD automation',
                    command: 'node production-deployment-pipeline.js',
                    status: 'ready',
                    category: 'Revolutionary Systems'
                }
            ],
            testDebugScripts: [
                {
                    name: 'test-auto-healer.js',
                    description: ' Self-healing test monitor - automatically detects and fixes test failures',
                    command: 'node test-auto-healer.js --monitor',
                    status: 'ready',
                    category: 'Self-Healing System',
                    background: true
                },
                {
                    name: 'comprehensive-test-functions.js',
                    description: '99 comprehensive tests across 11 categories for complete system validation',
                    command: 'Browser-based execution',
                    status: 'active',
                    category: 'Test & Debug Scripts'
                },
                {
                    name: 'infrastructure-tests.js',
                    description: 'Infrastructure validation tests for system health monitoring',
                    command: 'Browser-based execution',
                    status: 'active',
                    category: 'Test & Debug Scripts'
                },
                {
                    name: 'generate-claude-prompt.js',
                    description: ' Generate Claude Code analysis request for test failures',
                    command: 'node test-auto-healer.js --generate-prompt',
                    status: 'ready',
                    category: 'Self-Healing System'
                },
                {
                    name: 'test-simulator.js',
                    description: 'Direct simulator testing for chat functionality validation',
                    command: 'node test-simulator.js',
                    status: 'ready',
                    category: 'Test & Debug Scripts'
                },
                {
                    name: 'browser-debug.js',
                    description: 'Browser debugging utilities for real-time issue detection',
                    command: 'node browser-debug.js',
                    status: 'ready',
                    category: 'Test & Debug Scripts'
                }
            ],
            dataAnalytics: [
                {
                    name: 'analyze-supabase-data.js',
                    description: 'Supabase database analysis and data validation',
                    command: 'node analyze-supabase-data.js',
                    status: 'ready',
                    category: 'Data & Analytics'
                },
                {
                    name: 'detailed-supabase-analysis.js',
                    description: 'Detailed database analysis with comprehensive reporting',
                    command: 'node detailed-supabase-analysis.js',
                    status: 'ready',
                    category: 'Data & Analytics'
                },
                {
                    name: 'monitor-chat-db.js',
                    description: 'Real-time chat database monitoring and analysis',
                    command: 'node monitor-chat-db.js',
                    status: 'ready',
                    category: 'Data & Analytics'
                }
            ],
            infrastructure: [
                {
                    name: 'promptManager.js',
                    description: 'Core prompt management system with versioning and validation',
                    command: 'Integrated service',
                    status: 'active',
                    category: 'Infrastructure'
                },
                {
                    name: 'claude-hooks.json',
                    description: 'Claude Code hooks configuration for automated context loading',
                    command: 'Configuration file',
                    status: 'active',
                    category: 'Infrastructure'
                },
                {
                    name: 'CLAUDE.md',
                    description: 'Comprehensive project documentation with auto-updates',
                    command: 'Documentation system',
                    status: 'active',
                    category: 'Infrastructure'
                }
            ]
        };

        // Health check state
        let healthLogs = [];

        // Initialize Health Check tab
        function initializeHealthCheck() {
            logToHealthCheck(' Health Check initialized', 'info');
            refreshHealthStatus();
            initializeHealthTable();
        }

        // Refresh all health status
        async function refreshHealthStatus() {
            logToHealthCheck(' Refreshing system health status...', 'info');
            
            let totalScripts = 0;
            let runningServices = 0;
            let failedServices = 0;

            // Process each category
            for (const [categoryKey, scripts] of Object.entries(SYSTEM_SCRIPTS)) {
                const categoryElement = document.getElementById(categoryKey.replace(/([A-Z])/g, '-$1').toLowerCase() + '-items');
                const countElement = document.getElementById(categoryKey.replace(/([A-Z])/g, '-$1').toLowerCase() + '-count');
                
                if (!categoryElement || !countElement) continue;

                categoryElement.innerHTML = '';
                let categoryRunning = 0;

                for (const script of scripts) {
                    totalScripts++;
                    const status = await checkScriptStatus(script);
                    
                    if (status.running) {
                        runningServices++;
                        categoryRunning++;
                    } else if (status.error) {
                        failedServices++;
                    }

                    const scriptElement = createHealthItem(script, status);
                    categoryElement.appendChild(scriptElement);
                }

                countElement.textContent = `${categoryRunning}/${scripts.length}`;
            }

            // Update overview stats
            document.getElementById('total-scripts').textContent = totalScripts;
            document.getElementById('running-services').textContent = runningServices;
            document.getElementById('failed-services').textContent = failedServices;
            
            const healthPercentage = totalScripts > 0 ? Math.round((runningServices / totalScripts) * 100) : 100;
            document.getElementById('system-health').textContent = healthPercentage + '%';
            
            const healthElement = document.getElementById('system-health');
            if (healthPercentage >= 80) {
                healthElement.style.color = '#34c759';
            } else if (healthPercentage >= 60) {
                healthElement.style.color = '#ff9500';
            } else {
                healthElement.style.color = '#ff3b30';
            }

            logToHealthCheck(` Health check complete: ${runningServices}/${totalScripts} services running (${healthPercentage}%)`, 'success');
        }

        // Check individual script status
        async function checkScriptStatus(script) {
            try {
                if (script.port) {
                    // Check if service is running on port
                    try {
                        const response = await fetch(`${window.location.origin.replace(/:\d+/, '')}:${script.port}/`, { 
                            method: 'HEAD',
                            mode: 'no-cors'
                        });
                        
                        return {
                            running: true,
                            status: 'running',
                            message: `Service active on port ${script.port}`
                        };
                    } catch (error) {
                        return {
                            running: false,
                            status: 'stopped',
                            message: `Service not responding on port ${script.port}`
                        };
                    }
                } else if (script.status === 'active') {
                    return {
                        running: true,
                        status: 'running',
                        message: 'Active and integrated'
                    };
                } else if (script.status === 'ready') {
                    return {
                        running: false,
                        status: 'stopped',
                        message: 'Ready to run'
                    };
                }
            } catch (error) {
                return {
                    running: false,
                    status: 'error',
                    error: true,
                    message: error.message
                };
            }
            
            return {
                running: false,
                status: 'stopped',
                message: 'Not running'
            };
        }

        // Create health item element
        function createHealthItem(script, status) {
            const item = document.createElement('div');
            item.className = 'health-item';
            
            const statusClass = status.running ? 'running' : 
                               status.error ? 'error' : 'stopped';
            
            const statusText = status.running ? 'Running' :
                              status.error ? 'Error' : 'Stopped';

            item.innerHTML = `
                <div class="health-item-info">
                    <div class="health-item-name">${script.name}</div>
                    <div class="health-item-description">${script.description}</div>
                </div>
                <div class="health-item-status">
                    <div class="health-status-indicator ${statusClass}"></div>
                    <div class="health-status-text">${statusText}</div>
                    ${script.command && !script.command.includes('Browser-based') && !script.command.includes('Integrated') && !script.command.includes('Configuration') && !script.command.includes('Documentation') ? 
                        `<button class="health-action-btn" onclick="executeScript('${script.command}')">Run</button>` : ''
                    }
                </div>
            `;
            
            return item;
        }

        // Execute script command
        function executeScript(command) {
            logToHealthCheck(` Executing: ${command}`, 'info');
            // In a real implementation, this would execute the command
            logToHealthCheck(` Script execution requires manual terminal operation`, 'warning');
        }

        // Log to health check console
        function logToHealthCheck(message, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                message,
                level
            };
            
            healthLogs.unshift(logEntry);
            
            // Keep only last 50 entries
            if (healthLogs.length > 50) {
                healthLogs = healthLogs.slice(0, 50);
            }
            
            updateHealthLogs();
        }

        // Update health logs display
        function updateHealthLogs() {
            const logsContainer = document.getElementById('health-logs-content');
            if (!logsContainer) return;
            
            logsContainer.innerHTML = healthLogs.map(log => `
                <div class="health-log-entry">
                    <span class="health-log-timestamp">${log.timestamp}</span>
                    <span class="health-log-message health-log-level-${log.level}">${log.message}</span>
                </div>
            `).join('');
        }

        // Clear health logs
        function clearHealthLogs() {
            healthLogs = [];
            updateHealthLogs();
            logToHealthCheck(' Health logs cleared', 'info');
        }

        // ============================================
        // HEALTH TABLE FUNCTIONS
        // ============================================

        // Use single shared healthTableData (no local copy)
        window.healthTableData = window.healthTableData || {};

        // Initialize health table
        function initializeHealthTable() {
            populateHealthTable();
            updateHealthSummary();
        }

        // Populate the health table with consolidated health scripts
        function populateHealthTable() {
            const tableBody = document.getElementById('health-table-body');
            if (!tableBody) return;

            // Initialize healthTableData if it doesn't exist
            if (!window.healthTableData) {
                window.healthTableData = {};
            }

            // Define all available scripts
            const availableScripts = {
                // Health & Monitoring Scripts
                'system-health': {
                    name: 'System Health',
                    description: 'Core system components, network connectivity, and resource monitoring',
                    category: 'Health',
                    module: 'Infrastructure'
                },
                'development-health': {
                    name: 'Development Environment',
                    description: 'Development tools, syntax validation, and debugging capabilities',
                    category: 'Health',
                    module: 'Tools'
                },
                'testing-health': {
                    name: 'Testing Infrastructure',
                    description: 'Testing framework, automation capabilities, and test environment validation',
                    category: 'Health',
                    module: 'Quality'
                },
                'continuous-monitor': {
                    name: 'Continuous Monitor',
                    description: '24/7 production monitoring with alerting and automatic recovery',
                    category: 'Monitoring',
                    module: 'Production'
                },
                
                // Development & Automation Scripts  
                'dev-server': {
                    name: 'Development Server',
                    description: 'Enhanced development server with auto-restart and coordination',
                    category: 'Development',
                    module: 'Server'
                },
                'init': {
                    name: 'Context Initialization',
                    description: 'Initialize Cupido context for Claude Code sessions',
                    category: 'Development', 
                    module: 'Context'
                },
                'setup-context-automation': {
                    name: 'Setup Context Automation',
                    description: 'Configure automated context preservation and loading system',
                    category: 'Development',
                    module: 'Automation'
                },
                'install-claude-hooks': {
                    name: 'Install Claude Hooks',
                    description: 'Install Claude Code hooks for seamless workflow integration',
                    category: 'Development',
                    module: 'Integration'
                },
                
                // Testing & Debugging Scripts
                'auto-test-reflect': {
                    name: 'Auto Test Reflect',
                    description: 'Automated Chrome-based UI testing for Reflect tab functionality',
                    category: 'Testing',
                    module: 'Automation'
                },
                'debug-browser-reality': {
                    name: 'Debug Browser Reality',
                    description: 'Advanced browser state debugging and analysis',
                    category: 'Debug',
                    module: 'Browser'
                },
                
                // Deployment & Build Scripts
                'deploy': {
                    name: 'Deploy',
                    description: 'Build for web and deploy to Surge with automated validation',
                    category: 'Deployment',
                    module: 'Production'
                },
                
                // Utilities
                'version-control': {
                    name: 'Version Control',
                    description: 'App.tsx backup/restore system with version history',
                    category: 'Utilities',
                    module: 'Backup'
                },
                
                // JavaScript Utilities
                'analyze-supabase-data': {
                    name: 'Analyze Supabase Data',
                    description: 'Comprehensive Supabase database analysis and insights',
                    category: 'Analysis',
                    module: 'Database'
                },
                'test-simulator': {
                    name: 'Test Simulator',
                    description: 'Test simulator API endpoints and persona responses',
                    category: 'Testing',
                    module: 'Simulator'
                },
                'import-prompts': {
                    name: 'Import Prompts',
                    description: 'Import prompts from JSON to Supabase database',
                    category: 'Management',
                    module: 'Prompts'
                },
                'check-supabase-schema': {
                    name: 'Check Supabase Schema',
                    description: 'Validate and analyze Supabase database schema',
                    category: 'Analysis',
                    module: 'Database'
                },
                'session-logger': {
                    name: 'Session Logger',
                    description: 'Log and track development session activities',
                    category: 'Development',
                    module: 'Logging'
                },
                'auto-init': {
                    name: 'Auto Initialize',
                    description: 'Automatic context initialization for development sessions',
                    category: 'Development',
                    module: 'Context'
                }
            };

            const rows = Object.entries(availableScripts).map(([scriptId, metadata]) => {
                const status = window.healthTableData[scriptId] || { status: 'pending', lastRun: null, message: null };
                return createHealthScriptRow(scriptId, metadata, status);
            }).join('');

            tableBody.innerHTML = rows;
        }

        // Create a table row for a health script
        function createHealthScriptRow(scriptId, metadata, status) {
            const statusClass = status.status;
            const statusIcon = getStatusIcon(status.status);
            const lastRun = status.lastRun ? new Date(status.lastRun).toLocaleTimeString() : 'Never';

            return `
                <tr data-script-id="${scriptId}">
                    <td>
                        <span class="health-status ${statusClass}">
                            ${statusIcon}
                            ${status.status.charAt(0).toUpperCase() + status.status.slice(1)}
                        </span>
                    </td>
                    <td>
                        <strong>${metadata.name}</strong>
                        <div style="font-size: 12px; color: #8E8E93; margin-top: 2px;">
                            ${metadata.description}
                        </div>
                    </td>
                    <td>${metadata.category}</td>
                    <td>${metadata.module}</td>
                    <td>${lastRun}</td>
                    <td>
                        <button class="test-action-btn" onclick="runSingleHealthScript('${scriptId}')">
                            Run
                        </button>
                    </td>
                </tr>
            `;
        }

        // Create a table row for a test
        function createHealthTableRow(testId, metadata, status) {
            const statusClass = status.status;
            const statusIcon = getStatusIcon(status.status);
            const lastRun = status.lastRun ? new Date(status.lastRun).toLocaleTimeString() : 'Never';

            return `
                <tr>
                    <td>
                        <span class="health-status ${statusClass}">
                            ${statusIcon}
                            ${status.status.charAt(0).toUpperCase() + status.status.slice(1)}
                        </span>
                    </td>
                    <td>
                        <strong>${metadata.name}</strong>
                        <div style="font-size: 12px; color: #8E8E93; margin-top: 2px;">
                            ${metadata.description}
                        </div>
                    </td>
                    <td>${metadata.category}</td>
                    <td>${metadata.module}</td>
                    <td>${lastRun}</td>
                    <td>
                        <button class="test-action-btn" onclick="runScript('${testId}')">
                            Run
                        </button>
                    </td>
                </tr>
            `;
        }

        // Get status icon
        function getStatusIcon(status) {
            switch (status) {
                case 'passed': return '';
                case 'failed': return '';
                case 'pending': return '';
                case 'running': return '';
                default: return '';
            }
        }

        // Update health table with script results
        function updateHealthTableWithScript(scriptId, name, description, status, message) {
            // Initialize healthTableData if it doesn't exist for scripts
            if (!window.healthTableData) {
                window.healthTableData = {};
            }
            
            window.healthTableData[scriptId] = {
                status: status,
                lastRun: new Date().toISOString(),
                message: message || ''
            };
            
            // Create a simple health table entry for scripts
            const tableBody = document.getElementById('health-table-body');
            if (!tableBody) return;
            
            const statusIcon = getStatusIcon(status);
            const lastRun = new Date().toLocaleTimeString();
            
            // Find existing row or create new one
            let existingRow = document.querySelector(`tr[data-script-id="${scriptId}"]`);
            
            const rowHTML = `
                <tr data-script-id="${scriptId}">
                    <td>
                        <span class="health-status ${status}">
                            ${statusIcon}
                            ${status.charAt(0).toUpperCase() + status.slice(1)}
                        </span>
                    </td>
                    <td>
                        <strong>${name}</strong>
                        <div style="font-size: 12px; color: #8E8E93; margin-top: 2px;">
                            ${description}
                        </div>
                    </td>
                    <td>Health Check</td>
                    <td>System</td>
                    <td>${lastRun}</td>
                    <td>
                        <button class="test-action-btn" onclick="runSingleHealthScript('${scriptId}')">
                            Run
                        </button>
                    </td>
                </tr>
            `;
            
            if (existingRow) {
                existingRow.outerHTML = rowHTML;
            } else {
                tableBody.insertAdjacentHTML('beforeend', rowHTML);
            }
        }

        // Run a single health script
        async function runSingleHealthScript(scriptId) {
            console.log(`Running health script: ${scriptId}`);
            
            try {
                const response = await fetch(`/api/run-script/${scriptId}`);
                const output = await response.text();
                
                if (response.ok) {
                    console.log(`${scriptId} completed successfully`);
                    logToHealthCheck(` ${scriptId} completed successfully`, 'success');
                    
                    const scriptNames = {
                        'system-health': 'System Health',
                        'development-health': 'Development Environment', 
                        'testing-health': 'Testing Infrastructure',
                        'continuous-monitor': 'Continuous Monitor',
                        'dev-server': 'Development Server',
                        'init': 'Context Initialization',
                        'setup-context-automation': 'Setup Context Automation',
                        'install-claude-hooks': 'Install Claude Hooks',
                        'auto-test-reflect': 'Auto Test Reflect',
                        'debug-browser-reality': 'Debug Browser Reality',
                        'deploy': 'Deploy',
                        'version-control': 'Version Control',
                        'analyze-supabase-data': 'Analyze Supabase Data',
                        'test-simulator': 'Test Simulator',
                        'import-prompts': 'Import Prompts',
                        'check-supabase-schema': 'Check Supabase Schema',
                        'session-logger': 'Session Logger',
                        'auto-init': 'Auto Initialize'
                    };
                    
                    const scriptDescriptions = {
                        'system-health': 'System core components and connectivity',
                        'development-health': 'Development tools and environment validation',
                        'testing-health': 'Testing framework and automation validation',
                        'continuous-monitor': '24/7 production monitoring with alerting',
                        'dev-server': 'Enhanced development server with coordination',
                        'init': 'Initialize Cupido context for Claude Code sessions',
                        'setup-context-automation': 'Configure automated context preservation',
                        'install-claude-hooks': 'Install Claude Code hooks for seamless workflow',
                        'auto-test-reflect': 'Automated Chrome-based UI testing',
                        'debug-browser-reality': 'Advanced browser state debugging',
                        'deploy': 'Build for web and deploy to Surge',
                        'version-control': 'App.tsx backup/restore system',
                        'analyze-supabase-data': 'Comprehensive Supabase database analysis',
                        'test-simulator': 'Test simulator API endpoints and responses',
                        'import-prompts': 'Import prompts from JSON to Supabase',
                        'check-supabase-schema': 'Validate Supabase database schema',
                        'session-logger': 'Log and track development session activities',
                        'auto-init': 'Automatic context initialization'
                    };
                    
                    updateHealthTableWithScript(
                        scriptId, 
                        scriptNames[scriptId] || scriptId, 
                        scriptDescriptions[scriptId] || 'Health check script',
                        'passed', 
                        'Health check completed successfully'
                    );
                } else {
                    console.error(`${scriptId} failed`);
                    logToHealthCheck(` ${scriptId} failed`, 'error');
                    updateHealthTableWithScript(scriptId, scriptId, 'Health check script', 'failed', 'Health check failed');
                }
            } catch (error) {
                console.error(`Error running ${scriptId}:`, error);
                logToHealthCheck(` ${scriptId} error: ${error.message}`, 'error');
                updateHealthTableWithScript(scriptId, scriptId, 'Health check script', 'failed', error.message);
            }
        }

        // Run all health checks using consolidated scripts
        async function runAllHealthChecks() {
            console.log(' Starting system health checks...');
            logToHealthCheck(' Starting comprehensive system health check...', 'info');
            
            const button = document.querySelector('.health-run-btn');
            if (button) {
                button.disabled = true;
                button.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="2" fill="none"/>
                    </svg>
                    Running...
                `;
            }

            try {
                let healthChecksPassed = 0;
                let totalHealthChecks = 3; // We have 3 consolidated scripts

                // Run System Health Check
                try {
                    logToHealthCheck(' Running system health check...', 'info');
                    const systemHealthResponse = await fetch('/api/run-script/system-health');
                    const systemHealthText = await systemHealthResponse.text();
                    
                    if (systemHealthResponse.ok) {
                        logToHealthCheck(' System health check completed', 'success');
                        console.log('System Health Output:', systemHealthText);
                        healthChecksPassed++;
                        
                        // Update health table with system health status
                        updateHealthTableWithScript('system-health', 'System Health', 'System core components and connectivity', 'passed', 'All system components operational');
                    } else {
                        logToHealthCheck(' System health check failed', 'error');
                        updateHealthTableWithScript('system-health', 'System Health', 'System core components and connectivity', 'failed', 'System health check failed');
                    }
                } catch (error) {
                    console.error('System health check error:', error);
                    logToHealthCheck(` System health check failed: ${error.message}`, 'error');
                    updateHealthTableWithScript('system-health', 'System Health', 'System core components and connectivity', 'failed', error.message);
                }

                // Run Development Health Check
                try {
                    logToHealthCheck(' Running development environment check...', 'info');
                    const devHealthResponse = await fetch('/api/run-script/development-health');
                    const devHealthText = await devHealthResponse.text();
                    
                    if (devHealthResponse.ok) {
                        logToHealthCheck(' Development environment check completed', 'success');
                        console.log('Development Health Output:', devHealthText);
                        healthChecksPassed++;
                        
                        updateHealthTableWithScript('development-health', 'Development Environment', 'Development tools and environment validation', 'passed', 'Development environment healthy');
                    } else {
                        logToHealthCheck(' Development environment check failed', 'error');
                        updateHealthTableWithScript('development-health', 'Development Environment', 'Development tools and environment validation', 'failed', 'Development environment check failed');
                    }
                } catch (error) {
                    console.error('Development health check error:', error);
                    logToHealthCheck(` Development environment check failed: ${error.message}`, 'error');
                    updateHealthTableWithScript('development-health', 'Development Environment', 'Development tools and environment validation', 'failed', error.message);
                }

                // Run Testing Infrastructure Health Check
                try {
                    logToHealthCheck(' Running testing infrastructure check...', 'info');
                    const testingHealthResponse = await fetch('/api/run-script/testing-health');
                    const testingHealthText = await testingHealthResponse.text();
                    
                    if (testingHealthResponse.ok) {
                        logToHealthCheck(' Testing infrastructure check completed', 'success');
                        console.log('Testing Health Output:', testingHealthText);
                        healthChecksPassed++;
                        
                        updateHealthTableWithScript('testing-health', 'Testing Infrastructure', 'Testing framework and automation validation', 'passed', 'Testing infrastructure healthy');
                    } else {
                        logToHealthCheck(' Testing infrastructure check failed', 'error');
                        updateHealthTableWithScript('testing-health', 'Testing Infrastructure', 'Testing framework and automation validation', 'failed', 'Testing infrastructure check failed');
                    }
                } catch (error) {
                    console.error('Testing health check error:', error);
                    logToHealthCheck(` Testing infrastructure check failed: ${error.message}`, 'error');
                    updateHealthTableWithScript('testing-health', 'Testing Infrastructure', 'Testing framework and automation validation', 'failed', error.message);
                }
                
                // Summary
                logToHealthCheck(` Health check complete: ${healthChecksPassed}/${totalHealthChecks} health checks passed`, 'info');
                
                // Update summary display
                updateHealthSummary();
                
            } catch (error) {
                console.error('Health check failed:', error);
                logToHealthCheck(` Health check failed: ${error.message}`, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    button.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                            <path d="M8 1l7 4-7 4L1 5l7-4z" fill="currentColor"/>
                        </svg>
                        Run Health Checks
                    `;
                }
                populateHealthTable();
                updateHealthSummary();
            }
        }

        // Run a script
        async function runScript(scriptId) {
            // Use shared available scripts definition
            const availableScripts = HEALTH_AVAILABLE_SCRIPTS;

            if (!availableScripts[scriptId]) {
                console.warn(`Script not found: ${scriptId}`);
                return;
            }

            window.healthTableData = window.healthTableData || {};
            window.healthTableData[scriptId] = { status: 'running', lastRun: new Date(), message: 'Running...' };
            populateHealthTable();
            
            logToConsole(` Started script: ${availableScripts[scriptId]?.name || scriptId}`, 'info', 'script');

            try {
                const response = await fetch(`/api/run-script/${scriptId}`);
                const result = await response.text();
                const success = response.ok;
                
                window.healthTableData[scriptId] = {
                    status: success ? 'passed' : 'failed',
                    lastRun: new Date(),
                    message: success ? 'Completed successfully' : result.substring(0, 100)
                };
                populateHealthTable();
                
                const scriptName = availableScripts[scriptId]?.name || scriptId;
                if (success) {
                    logToConsole(` Script completed: ${scriptName}`, 'info', 'script');
                } else {
                    logToConsole(` Script failed: ${scriptName} - ${result.substring(0, 50)}`, 'error', 'script');
                }
            } catch (error) {
                window.healthTableData[scriptId] = {
                    status: 'failed',
                    lastRun: new Date(),
                    message: error.message
                };
                populateHealthTable();
                
                const scriptName = availableScripts[scriptId]?.name || scriptId;
                logToConsole(` Script error: ${scriptName} - ${error.message}`, 'error', 'script');
            }

            updateHealthSummary();
        }


        // Update health table with test results
        function updateHealthTableResults(results) {
            if (!results || typeof results !== 'object') return;

            Object.entries(results).forEach(([testId, result]) => {
                healthTableData[testId] = {
                    status: result.pass ? 'passed' : 'failed',
                    lastRun: new Date(),
                    message: result.message
                };
            });
        }

        // Refresh health table
        function refreshHealthTable() {
            populateHealthTable();
            updateHealthSummary();
            logToHealthCheck(' Health table refreshed', 'info');
        }

        // Update health summary stats
        function updateHealthSummary() {
            // Use shared available scripts definition
            const availableScripts = HEALTH_AVAILABLE_SCRIPTS;
            
            const totalScripts = Object.keys(availableScripts).length;
            const passedScripts = Object.values(window.healthTableData || {}).filter(script => script.status === 'passed').length;
            const failedScripts = Object.values(window.healthTableData || {}).filter(script => script.status === 'failed').length;
            const availableCount = totalScripts; // All scripts are available
            const healthPercentage = totalScripts > 0 ? Math.round((passedScripts / totalScripts) * 100) : 0;

            // Update summary display
            const passedEl = document.getElementById('passed-count');
            const failedEl = document.getElementById('failed-count');
            const pendingEl = document.getElementById('pending-count');
            const healthEl = document.getElementById('health-percentage');

            if (passedEl) passedEl.textContent = passedScripts;
            if (failedEl) failedEl.textContent = failedScripts;
            if (pendingEl) pendingEl.textContent = availableCount;
            if (healthEl) healthEl.textContent = `${healthPercentage}%`;
        }

        // Auto-refresh health table every 30 seconds
        setInterval(() => {
            if (document.getElementById('health-tab').classList.contains('active')) {
                refreshHealthTable();
            }
        }, 30000);
    </script>
</body>
</html>
